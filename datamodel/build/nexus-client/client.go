// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	customerrors "errors"
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "example/build/client/clientset/versioned"
	fakeBaseClienset "example/build/client/clientset/versioned/fake"
	"example/build/common"
	"example/build/helper"

	baseconfigexamplecomv1 "example/build/apis/config.example.com/v1"
	baseevaluationexamplecomv1 "example/build/apis/evaluation.example.com/v1"
	baseeventexamplecomv1 "example/build/apis/event.example.com/v1"
	baseinterestexamplecomv1 "example/build/apis/interest.example.com/v1"
	basequizexamplecomv1 "example/build/apis/quiz.example.com/v1"
	basequizchoiceexamplecomv1 "example/build/apis/quizchoice.example.com/v1"
	basequizquestionexamplecomv1 "example/build/apis/quizquestion.example.com/v1"
	baserootexamplecomv1 "example/build/apis/root.example.com/v1"
	basetenantexamplecomv1 "example/build/apis/tenant.example.com/v1"
	baseuserexamplecomv1 "example/build/apis/user.example.com/v1"
	basewannaexamplecomv1 "example/build/apis/wanna.example.com/v1"

	informerconfigexamplecomv1 "example/build/client/informers/externalversions/config.example.com/v1"
	informerevaluationexamplecomv1 "example/build/client/informers/externalversions/evaluation.example.com/v1"
	informereventexamplecomv1 "example/build/client/informers/externalversions/event.example.com/v1"
	informerinterestexamplecomv1 "example/build/client/informers/externalversions/interest.example.com/v1"
	informerquizexamplecomv1 "example/build/client/informers/externalversions/quiz.example.com/v1"
	informerquizchoiceexamplecomv1 "example/build/client/informers/externalversions/quizchoice.example.com/v1"
	informerquizquestionexamplecomv1 "example/build/client/informers/externalversions/quizquestion.example.com/v1"
	informerrootexamplecomv1 "example/build/client/informers/externalversions/root.example.com/v1"
	informertenantexamplecomv1 "example/build/client/informers/externalversions/tenant.example.com/v1"
	informeruserexamplecomv1 "example/build/client/informers/externalversions/user.example.com/v1"
	informerwannaexamplecomv1 "example/build/client/informers/externalversions/wanna.example.com/v1"
)

var log = logrus.New()

const maxRetryCount = 60
const sleepTime = 5
const maxRetryCount1SecSleep = 300

const ownershipAnnotation string = "Ownership"

// informerResyncPeriod is in second, default value is 10 Hrs(36000 Sec). INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
var informerResyncPeriod time.Duration = 36000

type Clientset struct {
	baseClient            baseClientset.Interface
	dynamicClient         *dynamic.DynamicClient
	rootExampleV1         *RootExampleV1
	evaluationExampleV1   *EvaluationExampleV1
	quizExampleV1         *QuizExampleV1
	quizquestionExampleV1 *QuizquestionExampleV1
	quizchoiceExampleV1   *QuizchoiceExampleV1
	tenantExampleV1       *TenantExampleV1
	configExampleV1       *ConfigExampleV1
	eventExampleV1        *EventExampleV1
	userExampleV1         *UserExampleV1
	wannaExampleV1        *WannaExampleV1
	interestExampleV1     *InterestExampleV1
}

type subscription struct {
	informer          cache.SharedIndexInformer
	stop              chan struct{}
	WriteCacheObjects *sync.Map
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer:          informer,
		stop:              make(chan struct{}),
		WriteCacheObjects: &sync.Map{},
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "roots.root.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootexamplecomv1.NewRootInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	key = "evaluations.evaluation.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerevaluationexamplecomv1.NewEvaluationInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := evaluationEvaluationExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "quizes.quiz.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizexamplecomv1.NewQuizInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := quizQuizExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "quizquestions.quizquestion.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := quizquestionQuizquestionExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "quizchoices.quizchoice.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := quizchoiceQuizchoiceExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "tenants.tenant.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenantexamplecomv1.NewTenantInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := tenantTenantExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "configs.config.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigexamplecomv1.NewConfigInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := configConfigExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "events.event.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informereventexamplecomv1.NewEventInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := eventEventExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "users.user.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informeruserexamplecomv1.NewUserInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := userUserExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "wannas.wanna.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerwannaexamplecomv1.NewWannaInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := wannaWannaExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

	key = "interests.interest.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerinterestexamplecomv1.NewInterestInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		chainer := interestInterestExampleV1Chainer{
			client: c,
		}
		chainer.RegisterAddCallback(chainer.addCallback)
		chainer.RegisterDeleteCallback(chainer.deleteCallback)

	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	customFormatter := new(logrus.TextFormatter)
	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
	log.SetFormatter(customFormatter)
	customFormatter.FullTimestamp = true
	if os.Getenv("NEXUS_LOG_LEVEL") == "debug" {
		log.SetLevel(logrus.DebugLevel)
		log.Debug("Nexus debug log enabled")
	}

	// INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
	stringResyncPeriod := os.Getenv("INFORMER_RESYNC_PERIOD")
	if stringResyncPeriod != "" {
		intResyncPeriod, err := strconv.Atoi(stringResyncPeriod)
		if err != nil {
			log.Errorf("env INFORMER_RESYNC_PERIOD is not set with correct value")
		} else {
			informerResyncPeriod = time.Duration(intResyncPeriod)
			log.Debugf("Resync Period for informers is set to %+v second", informerResyncPeriod)
		}
	}

	client := &Clientset{}
	client.baseClient = baseClient
	client.dynamicClient, _ = dynamic.NewForConfig(config) // TBD: check and react for error
	client.rootExampleV1 = newRootExampleV1(client)
	client.evaluationExampleV1 = newEvaluationExampleV1(client)
	client.quizExampleV1 = newQuizExampleV1(client)
	client.quizquestionExampleV1 = newQuizquestionExampleV1(client)
	client.quizchoiceExampleV1 = newQuizchoiceExampleV1(client)
	client.tenantExampleV1 = newTenantExampleV1(client)
	client.configExampleV1 = newConfigExampleV1(client)
	client.eventExampleV1 = newEventExampleV1(client)
	client.userExampleV1 = newUserExampleV1(client)
	client.wannaExampleV1 = newWannaExampleV1(client)
	client.interestExampleV1 = newInterestExampleV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.rootExampleV1 = newRootExampleV1(client)
	client.evaluationExampleV1 = newEvaluationExampleV1(client)
	client.quizExampleV1 = newQuizExampleV1(client)
	client.quizquestionExampleV1 = newQuizquestionExampleV1(client)
	client.quizchoiceExampleV1 = newQuizchoiceExampleV1(client)
	client.tenantExampleV1 = newTenantExampleV1(client)
	client.configExampleV1 = newConfigExampleV1(client)
	client.eventExampleV1 = newEventExampleV1(client)
	client.userExampleV1 = newUserExampleV1(client)
	client.wannaExampleV1 = newWannaExampleV1(client)
	client.interestExampleV1 = newInterestExampleV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootExampleV1 {
	return c.rootExampleV1
}
func (c *Clientset) Evaluation() *EvaluationExampleV1 {
	return c.evaluationExampleV1
}
func (c *Clientset) Quiz() *QuizExampleV1 {
	return c.quizExampleV1
}
func (c *Clientset) Quizquestion() *QuizquestionExampleV1 {
	return c.quizquestionExampleV1
}
func (c *Clientset) Quizchoice() *QuizchoiceExampleV1 {
	return c.quizchoiceExampleV1
}
func (c *Clientset) Tenant() *TenantExampleV1 {
	return c.tenantExampleV1
}
func (c *Clientset) Config() *ConfigExampleV1 {
	return c.configExampleV1
}
func (c *Clientset) Event() *EventExampleV1 {
	return c.eventExampleV1
}
func (c *Clientset) User() *UserExampleV1 {
	return c.userExampleV1
}
func (c *Clientset) Wanna() *WannaExampleV1 {
	return c.wannaExampleV1
}
func (c *Clientset) Interest() *InterestExampleV1 {
	return c.interestExampleV1
}

type RootExampleV1 struct {
	client *Clientset
}

func newRootExampleV1(client *Clientset) *RootExampleV1 {
	return &RootExampleV1{
		client: client,
	}
}

type EvaluationExampleV1 struct {
	client *Clientset
}

func newEvaluationExampleV1(client *Clientset) *EvaluationExampleV1 {
	return &EvaluationExampleV1{
		client: client,
	}
}

type QuizExampleV1 struct {
	client *Clientset
}

func newQuizExampleV1(client *Clientset) *QuizExampleV1 {
	return &QuizExampleV1{
		client: client,
	}
}

type QuizquestionExampleV1 struct {
	client *Clientset
}

func newQuizquestionExampleV1(client *Clientset) *QuizquestionExampleV1 {
	return &QuizquestionExampleV1{
		client: client,
	}
}

type QuizchoiceExampleV1 struct {
	client *Clientset
}

func newQuizchoiceExampleV1(client *Clientset) *QuizchoiceExampleV1 {
	return &QuizchoiceExampleV1{
		client: client,
	}
}

type TenantExampleV1 struct {
	client *Clientset
}

func newTenantExampleV1(client *Clientset) *TenantExampleV1 {
	return &TenantExampleV1{
		client: client,
	}
}

type ConfigExampleV1 struct {
	client *Clientset
}

func newConfigExampleV1(client *Clientset) *ConfigExampleV1 {
	return &ConfigExampleV1{
		client: client,
	}
}

type EventExampleV1 struct {
	client *Clientset
}

func newEventExampleV1(client *Clientset) *EventExampleV1 {
	return &EventExampleV1{
		client: client,
	}
}

type UserExampleV1 struct {
	client *Clientset
}

func newUserExampleV1(client *Clientset) *UserExampleV1 {
	return &UserExampleV1{
		client: client,
	}
}

type WannaExampleV1 struct {
	client *Clientset
}

func newWannaExampleV1(client *Clientset) *WannaExampleV1 {
	return &WannaExampleV1{
		client: client,
	}
}

type InterestExampleV1 struct {
	client *Clientset
}

func newInterestExampleV1(client *Clientset) *InterestExampleV1 {
	return &InterestExampleV1{
		client: client,
	}
}

func (group *RootExampleV1) GetRootChildrenMap() map[string]baserootexamplecomv1.Child {
	return map[string]baserootexamplecomv1.Child{}
}

func (group *RootExampleV1) GetRootChild(grp, kind, name string) baserootexamplecomv1.Child {
	return baserootexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) GetRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRootByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baserootexamplecomv1.Root)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRootByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baserootexamplecomv1.Root).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRootByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootRoot{
					client: group.client,
					Root:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootRoot{
				client: group.client,
				Root:   resWrCache.(*baserootexamplecomv1.Root),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRootByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRootByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) ForceReadRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	log.Debugf("[ForceReadRootByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRootByName] Failed to Get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRootByName] Executed Successfully :%s", hashedName)
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		}
	}
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRootByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baserootexamplecomv1.Root
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] Failed to get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("roots.root.example.com", hashedName, "tenants.tenant.example.com") {
		err := group.client.Tenant().DeleteTenantByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("roots.root.example.com", hashedName, "tenants.tenant.example.com", child)
	}

	for _, child := range GetChildren("roots.root.example.com", hashedName, "evaluations.evaluation.example.com") {
		err := group.client.Evaluation().DeleteEvaluationByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("roots.root.example.com", hashedName, "evaluations.evaluation.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootExampleV1().
			Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] failed to delete Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	return nil
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootExampleV1) CreateRootByName(ctx context.Context,
	objToCreate *baserootexamplecomv1.Root) (*RootRoot, error) {
	log.Debugf("[CreateRootByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.TenantGvk = nil
	objToCreate.Spec.EvaluationGvk = nil

	var (
		retryCount int
		result     *baserootexamplecomv1.Root
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRootByName] Failed to create Root: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Root: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRootByName] context canceled while creating Root: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateRootByName] found unexpected error while creating Root: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRootByName] Root: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				log.Debugf("[CreateRootByName] Root: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	log.Debugf("[CreateRootByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootExampleV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baserootexamplecomv1.Root) (*RootRoot, error) {
	log.Debugf("[UpdateRootByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetRootByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["roots.root.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baserootexamplecomv1.Root
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRootByName] Failed to patch Root %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Root: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Root deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRootByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRootByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Root: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Root Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRootByName] Patch Root Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				log.Debugf("[UpdateRootByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRootByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootExampleV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*RootRoot, err error) {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootRoot, len(items))
		for k, v := range items {
			item, _ := v.(*baserootexamplecomv1.Root)
			result[k] = &RootRoot{
				client: group.client,
				Root:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootExampleV1().
			Roots().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootRoot, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootRoot{
				client: group.client,
				Root:   &item,
			}
		}
	}
	return
}

type RootRoot struct {
	client *Clientset
	*baserootexamplecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *RootRoot) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootRoot) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetRootRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetRootRoot(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", nil, helper.DEFAULT_KEY)
	return c.Root().GetRootByName(ctx, hashedName)
}

func (c *Clientset) RootRoot() *rootRootExampleV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.root.example.com"] = helper.DEFAULT_KEY
	return &rootRootExampleV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddRootRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootRoot(ctx context.Context,
	objToCreate *baserootexamplecomv1.Root) (result *RootRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateRootByName(ctx, objToCreate)
}

// DeleteRootRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteRootRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", nil, helper.DEFAULT_KEY)
	return c.Root().DeleteRootByName(ctx, hashedName)
}

type RootRootTenant struct {
	client *Clientset
	Tenant []baserootexamplecomv1.Child
}

func (n *RootRootTenant) Next(ctx context.Context) (*TenantTenant, error) {
	for index, child := range n.Tenant {
		obj, err := n.client.Tenant().GetTenantByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Tenant)-1 {
				n.Tenant = nil
			} else {
				n.Tenant = n.Tenant[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllTenantIter returns an iterator for all children of given type
func (obj *RootRoot) GetAllTenantIter(ctx context.Context) (
	result RootRootTenant) {
	result.client = obj.client
	for _, v := range GetChildren("roots.root.example.com", obj.Name, "tenants.tenant.example.com") {
		result.Tenant = append(result.Tenant, baserootexamplecomv1.Child{
			Group: "tenant.example.com",
			Kind:  "Tenant",
			Name:  v,
		})
	}
	return
}

// GetAllTenant returns all children of a given type
func (obj *RootRoot) GetAllTenant(ctx context.Context) (
	result []*TenantTenant, err error) {
	for _, v := range GetChildren("roots.root.example.com", obj.Name, "tenants.tenant.example.com") {
		l, err := obj.client.Tenant().GetTenantByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTenant returns child which has given displayName
func (obj *RootRoot) GetTenant(ctx context.Context,
	displayName string) (result *TenantTenant, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["roots.root.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("tenants.tenant.example.com", parentLabels, displayName)
	if IsChildExists("roots.root.example.com", obj.Name, "tenants.tenant.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Tenant", displayName)
	}

	result, err = obj.client.Tenant().GetTenantByName(ctx, childHashName)
	return
}

// AddTenant calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddTenant(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (result *TenantTenant, err error) {
	log.Debugf("[AddTenant] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Tenant().CreateTenantByName(ctx, objToCreate)
	log.Debugf("[AddTenant] Tenant created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	log.Debugf("[AddTenant] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteTenant calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteTenant(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteTenant] Received for Tenant object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["roots.root.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("tenants.tenant.example.com", parentLabels, displayName)
	if IsChildExists("roots.root.example.com", obj.Name, "tenants.tenant.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Root.Root", "Tenant", displayName)
	}

	err = obj.client.Tenant().DeleteTenantByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteTenant] Tenant object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// GetEvaluation returns child of given type
func (obj *RootRoot) GetEvaluation(ctx context.Context) (
	result *EvaluationEvaluation, err error) {
	children := GetChildren("roots.root.example.com", obj.Name, "evaluations.evaluation.example.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Evaluation")
	}
	return obj.client.Evaluation().GetEvaluationByName(ctx, children[0])
}

// AddEvaluation calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddEvaluation(ctx context.Context,
	objToCreate *baseevaluationexamplecomv1.Evaluation) (result *EvaluationEvaluation, err error) {
	log.Debugf("[AddEvaluation] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Evaluation().CreateEvaluationByName(ctx, objToCreate)
	log.Debugf("[AddEvaluation] Evaluation created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	log.Debugf("[AddEvaluation] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteEvaluation calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteEvaluation(ctx context.Context) (err error) {
	children := GetChildren("roots.root.example.com", obj.Name, "evaluations.evaluation.example.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteEvaluation] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Evaluation().DeleteEvaluationByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootRootExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootRootExampleV1Chainer) Subscribe() {
	key := "roots.root.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
}

func (c *rootRootExampleV1Chainer) Unsubscribe() {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *rootRootExampleV1Chainer) IsSubscribed() bool {
	key := "roots.root.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *rootRootExampleV1Chainer) RegisterEventHandler(addCB func(obj *RootRoot), updateCB func(oldObj, newObj *RootRoot), deleteCB func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootRoot{
				client: c.client,
				Root:   oldObj.(*baserootexamplecomv1.Root),
			}
			newData := &RootRoot{
				client: c.client,
				Root:   newObj.(*baserootexamplecomv1.Root),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootRoot{
				client: c.client,
				Root:   oldObj.(*baserootexamplecomv1.Root),
			}
			newData := &RootRoot{
				client: c.client,
				Root:   newObj.(*baserootexamplecomv1.Root),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *rootRootExampleV1Chainer) Tenant(name string) *tenantTenantExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["tenants.tenant.example.com"] = name
	return &tenantTenantExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTenant calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootRootExampleV1Chainer) GetTenant(ctx context.Context, displayName string) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, displayName)
	return c.client.Tenant().GetTenantByName(ctx, hashedName)
}

// AddTenant calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootExampleV1Chainer) AddTenant(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (result *TenantTenant, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Tenant().CreateTenantByName(ctx, objToCreate)
}

// DeleteTenant calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootExampleV1Chainer) DeleteTenant(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, name)
	return c.client.Tenant().DeleteTenantByName(ctx, hashedName)
}

func (c *rootRootExampleV1Chainer) Evaluation() *evaluationEvaluationExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["evaluations.evaluation.example.com"] = helper.DEFAULT_KEY
	return &evaluationEvaluationExampleV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetEvaluation calculates hashed name of the object based on it's parents and returns the object
func (c *rootRootExampleV1Chainer) GetEvaluation(ctx context.Context) (result *EvaluationEvaluation, err error) {
	hashedName := helper.GetHashedName("evaluations.evaluation.example.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Evaluation().GetEvaluationByName(ctx, hashedName)
}

// AddEvaluation calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootExampleV1Chainer) AddEvaluation(ctx context.Context,
	objToCreate *baseevaluationexamplecomv1.Evaluation) (result *EvaluationEvaluation, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("evaluations.evaluation.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Evaluation().CreateEvaluationByName(ctx, objToCreate)
}

// DeleteEvaluation calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootExampleV1Chainer) DeleteEvaluation(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("evaluations.evaluation.example.com", c.parentLabels, name)
	return c.client.Evaluation().DeleteEvaluationByName(ctx, hashedName)
}

func (group *EvaluationExampleV1) GetEvaluationChildrenMap() map[string]baseevaluationexamplecomv1.Child {
	return map[string]baseevaluationexamplecomv1.Child{}
}

func (group *EvaluationExampleV1) GetEvaluationChild(grp, kind, name string) baseevaluationexamplecomv1.Child {
	return baseevaluationexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetEvaluationByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EvaluationExampleV1) GetEvaluationByName(ctx context.Context, hashedName string) (*EvaluationEvaluation, error) {
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetEvaluationByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseevaluationexamplecomv1.Evaluation)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetEvaluationByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseevaluationexamplecomv1.Evaluation).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetEvaluationByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &EvaluationEvaluation{
					client:     group.client,
					Evaluation: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &EvaluationEvaluation{
				client:     group.client,
				Evaluation: resWrCache.(*baseevaluationexamplecomv1.Evaluation),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &EvaluationEvaluation{
				client:     group.client,
				Evaluation: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetEvaluationByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Evaluations: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetEvaluationByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetEvaluationByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadEvaluationByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EvaluationExampleV1) ForceReadEvaluationByName(ctx context.Context, hashedName string) (*EvaluationEvaluation, error) {
	log.Debugf("[ForceReadEvaluationByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadEvaluationByName] Failed to Get Evaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Evaluations: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadEvaluationByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadEvaluationByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadEvaluationByName] Executed Successfully :%s", hashedName)
			return &EvaluationEvaluation{
				client:     group.client,
				Evaluation: result,
			}, nil
		}
	}
}

// DeleteEvaluationByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *EvaluationExampleV1) DeleteEvaluationByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteEvaluationByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseevaluationexamplecomv1.Evaluation
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteEvaluationByName] Failed to get Evaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Evaluations: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEvaluationByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEvaluationByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEvaluationByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("evaluations.evaluation.example.com", hashedName, "quizes.quiz.example.com") {
		err := group.client.Quiz().DeleteQuizByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("evaluations.evaluation.example.com", hashedName, "quizes.quiz.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteEvaluationByName] failed to delete Evaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Evaluations: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEvaluationByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEvaluationByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEvaluationByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("evaluations.evaluation.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteEvaluationByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
	}
	RemoveChild("roots.root.example.com", parentName, "evaluations.evaluation.example.com", hashedName)

	return nil
}

// CreateEvaluationByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *EvaluationExampleV1) CreateEvaluationByName(ctx context.Context,
	objToCreate *baseevaluationexamplecomv1.Evaluation) (*EvaluationEvaluation, error) {
	log.Debugf("[CreateEvaluationByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.QuizGvk = nil

	var (
		retryCount int
		result     *baseevaluationexamplecomv1.Evaluation
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateEvaluationByName] Failed to create Evaluation: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Evaluation: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateEvaluationByName] context canceled while creating Evaluation: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateEvaluationByName] Evaluation: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.EvaluationExampleV1().Evaluations().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateEvaluationByName] Unable to Get Evaluation %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateEvaluationByName] found unexpected error while creating Evaluation: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateEvaluationByName] Evaluation: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("evaluations.evaluation.example.com"); ok {
				log.Debugf("[CreateEvaluationByName] Evaluation: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("roots.root.example.com", objToCreate.GetLabels(), parentName)

	AddChild("roots.root.example.com", parentHashedName, "evaluations.evaluation.example.com", objToCreate.Name)

	log.Debugf("[CreateEvaluationByName] Executed Successfully: %s", objToCreate.GetName())
	return &EvaluationEvaluation{
		client:     group.client,
		Evaluation: result,
	}, nil
}

// UpdateEvaluationByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *EvaluationExampleV1) UpdateEvaluationByName(ctx context.Context,
	objToUpdate *baseevaluationexamplecomv1.Evaluation) (*EvaluationEvaluation, error) {
	log.Debugf("[UpdateEvaluationByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Evaluation().GetEvaluationByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["evaluations.evaluation.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseevaluationexamplecomv1.Evaluation
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateEvaluationByName] Failed to patch Evaluation %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Evaluation Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteEvaluationByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Evaluation: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Evaluation deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateEvaluationByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateEvaluationByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Evaluation Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteEvaluationByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Evaluation: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Evaluation Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateEvaluationByName] Patch Evaluation Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("evaluations.evaluation.example.com"); ok {
				log.Debugf("[UpdateEvaluationByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateEvaluationByName] Executed Successfully %s", objToUpdate.GetName())
	return &EvaluationEvaluation{
		client:     group.client,
		Evaluation: result,
	}, nil
}

// ListEvaluations returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *EvaluationExampleV1) ListEvaluations(ctx context.Context,
	opts metav1.ListOptions) (result []*EvaluationEvaluation, err error) {
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*EvaluationEvaluation, len(items))
		for k, v := range items {
			item, _ := v.(*baseevaluationexamplecomv1.Evaluation)
			result[k] = &EvaluationEvaluation{
				client:     group.client,
				Evaluation: item,
			}
		}
	} else {
		list, err := group.client.baseClient.EvaluationExampleV1().
			Evaluations().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*EvaluationEvaluation, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &EvaluationEvaluation{
				client:     group.client,
				Evaluation: &item,
			}
		}
	}
	return
}

type EvaluationEvaluation struct {
	client *Clientset
	*baseevaluationexamplecomv1.Evaluation
}

// Delete removes obj and all it's children from the database.
func (obj *EvaluationEvaluation) Delete(ctx context.Context) error {
	err := obj.client.Evaluation().DeleteEvaluationByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Evaluation = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *EvaluationEvaluation) Update(ctx context.Context) error {
	result, err := obj.client.Evaluation().UpdateEvaluationByName(ctx, obj.Evaluation)
	if err != nil {
		return err
	}
	obj.Evaluation = result.Evaluation
	return nil
}

func (obj *EvaluationEvaluation) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", obj.Labels, obj.Labels["roots.root.example.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

type EvaluationEvaluationQuiz struct {
	client *Clientset
	Quiz   []baseevaluationexamplecomv1.Child
}

func (n *EvaluationEvaluationQuiz) Next(ctx context.Context) (*QuizQuiz, error) {
	for index, child := range n.Quiz {
		obj, err := n.client.Quiz().GetQuizByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Quiz)-1 {
				n.Quiz = nil
			} else {
				n.Quiz = n.Quiz[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllQuizIter returns an iterator for all children of given type
func (obj *EvaluationEvaluation) GetAllQuizIter(ctx context.Context) (
	result EvaluationEvaluationQuiz) {
	result.client = obj.client
	for _, v := range GetChildren("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com") {
		result.Quiz = append(result.Quiz, baseevaluationexamplecomv1.Child{
			Group: "quiz.example.com",
			Kind:  "Quiz",
			Name:  v,
		})
	}
	return
}

// GetAllQuiz returns all children of a given type
func (obj *EvaluationEvaluation) GetAllQuiz(ctx context.Context) (
	result []*QuizQuiz, err error) {
	for _, v := range GetChildren("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com") {
		l, err := obj.client.Quiz().GetQuizByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetQuiz returns child which has given displayName
func (obj *EvaluationEvaluation) GetQuiz(ctx context.Context,
	displayName string) (result *QuizQuiz, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["evaluations.evaluation.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizes.quiz.example.com", parentLabels, displayName)
	if IsChildExists("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Evaluation.Evaluation", "Quiz", displayName)
	}

	result, err = obj.client.Quiz().GetQuizByName(ctx, childHashName)
	return
}

// AddQuiz calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *EvaluationEvaluation) AddQuiz(ctx context.Context,
	objToCreate *basequizexamplecomv1.Quiz) (result *QuizQuiz, err error) {
	log.Debugf("[AddQuiz] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["evaluations.evaluation.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["evaluations.evaluation.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Quiz().CreateQuizByName(ctx, objToCreate)
	log.Debugf("[AddQuiz] Quiz created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Evaluation().GetEvaluationByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Evaluation = updatedObj.Evaluation
	}
	log.Debugf("[AddQuiz] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteQuiz calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *EvaluationEvaluation) DeleteQuiz(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteQuiz] Received for Quiz object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["evaluations.evaluation.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizes.quiz.example.com", parentLabels, displayName)
	if IsChildExists("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Evaluation.Evaluation", "Quiz", displayName)
	}

	err = obj.client.Quiz().DeleteQuizByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteQuiz] Quiz object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Evaluation().GetEvaluationByName(ctx, obj.GetName())
	if err == nil {
		obj.Evaluation = updatedObj.Evaluation
	}
	return
}

type evaluationEvaluationExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *evaluationEvaluationExampleV1Chainer) Subscribe() {
	key := "evaluations.evaluation.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *evaluationEvaluationExampleV1Chainer) Unsubscribe() {
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *evaluationEvaluationExampleV1Chainer) IsSubscribed() bool {
	key := "evaluations.evaluation.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *evaluationEvaluationExampleV1Chainer) addCallback(obj *EvaluationEvaluation) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	AddChild("roots.root.example.com", parentHashName, "evaluations.evaluation.example.com", obj.Name)
}

func (c *evaluationEvaluationExampleV1Chainer) deleteCallback(obj *EvaluationEvaluation) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	RemoveChild("roots.root.example.com", parentHashName, "evaluations.evaluation.example.com", obj.Name)
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterEventHandler(addCB func(obj *EvaluationEvaluation), updateCB func(oldObj, newObj *EvaluationEvaluation), deleteCB func(obj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EvaluationEvaluation")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EvaluationEvaluation, so creating a new one")
		informer = informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name) {
				AddChild("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: oldObj.(*baseevaluationexamplecomv1.Evaluation),
			}
			newData := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: newObj.(*baseevaluationexamplecomv1.Evaluation),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name) {
				RemoveChild("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterAddCallback(cbfn func(obj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EvaluationEvaluation")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EvaluationEvaluation, so creating a new one")
		informer = informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name) {
				AddChild("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EvaluationEvaluation")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EvaluationEvaluation, so creating a new one")
		informer = informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: oldObj.(*baseevaluationexamplecomv1.Evaluation),
			}
			newData := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: newObj.(*baseevaluationexamplecomv1.Evaluation),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EvaluationEvaluation")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EvaluationEvaluation, so creating a new one")
		informer = informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name) {
				RemoveChild("roots.root.example.com", parent.Name, "evaluations.evaluation.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) Quiz(name string) *quizQuizExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["quizes.quiz.example.com"] = name
	return &quizQuizExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetQuiz calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *evaluationEvaluationExampleV1Chainer) GetQuiz(ctx context.Context, displayName string) (result *QuizQuiz, err error) {
	hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, displayName)
	return c.client.Quiz().GetQuizByName(ctx, hashedName)
}

// AddQuiz calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *evaluationEvaluationExampleV1Chainer) AddQuiz(ctx context.Context,
	objToCreate *basequizexamplecomv1.Quiz) (result *QuizQuiz, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Quiz().CreateQuizByName(ctx, objToCreate)
}

// DeleteQuiz calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *evaluationEvaluationExampleV1Chainer) DeleteQuiz(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, name)
	return c.client.Quiz().DeleteQuizByName(ctx, hashedName)
}

func (group *QuizExampleV1) GetQuizChildrenMap() map[string]basequizexamplecomv1.Child {
	return map[string]basequizexamplecomv1.Child{}
}

func (group *QuizExampleV1) GetQuizChild(grp, kind, name string) basequizexamplecomv1.Child {
	return basequizexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetQuizByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizExampleV1) GetQuizByName(ctx context.Context, hashedName string) (*QuizQuiz, error) {
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetQuizByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basequizexamplecomv1.Quiz)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetQuizByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basequizexamplecomv1.Quiz).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetQuizByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &QuizQuiz{
					client: group.client,
					Quiz:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &QuizQuiz{
				client: group.client,
				Quiz:   resWrCache.(*basequizexamplecomv1.Quiz),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizExampleV1().
			Quizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &QuizQuiz{
				client: group.client,
				Quiz:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetQuizByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Quizes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetQuizByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetQuizByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadQuizByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizExampleV1) ForceReadQuizByName(ctx context.Context, hashedName string) (*QuizQuiz, error) {
	log.Debugf("[ForceReadQuizByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizExampleV1().
			Quizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadQuizByName] Failed to Get Quizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Quizes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadQuizByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadQuizByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadQuizByName] Executed Successfully :%s", hashedName)
			return &QuizQuiz{
				client: group.client,
				Quiz:   result,
			}, nil
		}
	}
}

// DeleteQuizByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *QuizExampleV1) DeleteQuizByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteQuizByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basequizexamplecomv1.Quiz
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizByName] Failed to get Quizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Quizes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("quizes.quiz.example.com", hashedName, "quizquestions.quizquestion.example.com") {
		err := group.client.Quizquestion().DeleteQuizQuestionByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("quizes.quiz.example.com", hashedName, "quizquestions.quizquestion.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizByName] failed to delete Quizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Quizes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("quizes.quiz.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteQuizByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["evaluations.evaluation.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("evaluations.evaluation.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("evaluations.evaluation.example.com", parents, parentName)
	}
	RemoveChild("evaluations.evaluation.example.com", parentName, "quizes.quiz.example.com", hashedName)

	return nil
}

// CreateQuizByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *QuizExampleV1) CreateQuizByName(ctx context.Context,
	objToCreate *basequizexamplecomv1.Quiz) (*QuizQuiz, error) {
	log.Debugf("[CreateQuizByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.QuestionGvk = nil

	var (
		retryCount int
		result     *basequizexamplecomv1.Quiz
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateQuizByName] Failed to create Quiz: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Quiz: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateQuizByName] context canceled while creating Quiz: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateQuizByName] Quiz: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.QuizExampleV1().Quizes().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateQuizByName] Unable to Get Quiz %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateQuizByName] found unexpected error while creating Quiz: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateQuizByName] Quiz: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("quizes.quiz.example.com"); ok {
				log.Debugf("[CreateQuizByName] Quiz: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["evaluations.evaluation.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("evaluations.evaluation.example.com", objToCreate.GetLabels(), parentName)

	AddChild("evaluations.evaluation.example.com", parentHashedName, "quizes.quiz.example.com", objToCreate.Name)

	log.Debugf("[CreateQuizByName] Executed Successfully: %s", objToCreate.GetName())
	return &QuizQuiz{
		client: group.client,
		Quiz:   result,
	}, nil
}

// UpdateQuizByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *QuizExampleV1) UpdateQuizByName(ctx context.Context,
	objToUpdate *basequizexamplecomv1.Quiz) (*QuizQuiz, error) {
	log.Debugf("[UpdateQuizByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Quiz().GetQuizByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["quizes.quiz.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.DefaultScorePerQuestion)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.DefaultScorePerQuestion).IsNil() {
			patchValueDefaultScorePerQuestion := objToUpdate.Spec.DefaultScorePerQuestion
			patchOpDefaultScorePerQuestion := PatchOp{
				Op:    "replace",
				Path:  "/spec/defaultScorePerQuestion",
				Value: patchValueDefaultScorePerQuestion,
			}
			patch = append(patch, patchOpDefaultScorePerQuestion)
		}
	} else {
		patchValueDefaultScorePerQuestion := objToUpdate.Spec.DefaultScorePerQuestion
		patchOpDefaultScorePerQuestion := PatchOp{
			Op:    "replace",
			Path:  "/spec/defaultScorePerQuestion",
			Value: patchValueDefaultScorePerQuestion,
		}
		patch = append(patch, patchOpDefaultScorePerQuestion)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basequizexamplecomv1.Quiz
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateQuizByName] Failed to patch Quiz %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Quiz Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteQuizByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Quiz: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Quiz deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateQuizByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateQuizByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Quiz Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteQuizByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Quiz: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Quiz Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateQuizByName] Patch Quiz Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("quizes.quiz.example.com"); ok {
				log.Debugf("[UpdateQuizByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateQuizByName] Executed Successfully %s", objToUpdate.GetName())
	return &QuizQuiz{
		client: group.client,
		Quiz:   result,
	}, nil
}

// ListQuizes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *QuizExampleV1) ListQuizes(ctx context.Context,
	opts metav1.ListOptions) (result []*QuizQuiz, err error) {
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*QuizQuiz, len(items))
		for k, v := range items {
			item, _ := v.(*basequizexamplecomv1.Quiz)
			result[k] = &QuizQuiz{
				client: group.client,
				Quiz:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.QuizExampleV1().
			Quizes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*QuizQuiz, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &QuizQuiz{
				client: group.client,
				Quiz:   &item,
			}
		}
	}
	return
}

type QuizQuiz struct {
	client *Clientset
	*basequizexamplecomv1.Quiz
}

// Delete removes obj and all it's children from the database.
func (obj *QuizQuiz) Delete(ctx context.Context) error {
	err := obj.client.Quiz().DeleteQuizByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Quiz = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *QuizQuiz) Update(ctx context.Context) error {
	result, err := obj.client.Quiz().UpdateQuizByName(ctx, obj.Quiz)
	if err != nil {
		return err
	}
	obj.Quiz = result.Quiz
	return nil
}

func (obj *QuizQuiz) GetParent(ctx context.Context) (result *EvaluationEvaluation, err error) {
	hashedName := helper.GetHashedName("evaluations.evaluation.example.com", obj.Labels, obj.Labels["evaluations.evaluation.example.com"])
	return obj.client.Evaluation().GetEvaluationByName(ctx, hashedName)
}

type QuizQuizQuestion struct {
	client   *Clientset
	Question []basequizexamplecomv1.Child
}

func (n *QuizQuizQuestion) Next(ctx context.Context) (*QuizquestionQuizQuestion, error) {
	for index, child := range n.Question {
		obj, err := n.client.Quizquestion().GetQuizQuestionByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Question)-1 {
				n.Question = nil
			} else {
				n.Question = n.Question[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllQuestionIter returns an iterator for all children of given type
func (obj *QuizQuiz) GetAllQuestionIter(ctx context.Context) (
	result QuizQuizQuestion) {
	result.client = obj.client
	for _, v := range GetChildren("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com") {
		result.Question = append(result.Question, basequizexamplecomv1.Child{
			Group: "quizquestion.example.com",
			Kind:  "QuizQuestion",
			Name:  v,
		})
	}
	return
}

// GetAllQuestion returns all children of a given type
func (obj *QuizQuiz) GetAllQuestion(ctx context.Context) (
	result []*QuizquestionQuizQuestion, err error) {
	for _, v := range GetChildren("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com") {
		l, err := obj.client.Quizquestion().GetQuizQuestionByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetQuestion returns child which has given displayName
func (obj *QuizQuiz) GetQuestion(ctx context.Context,
	displayName string) (result *QuizquestionQuizQuestion, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizes.quiz.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", parentLabels, displayName)
	if IsChildExists("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Quiz.Quiz", "Question", displayName)
	}

	result, err = obj.client.Quizquestion().GetQuizQuestionByName(ctx, childHashName)
	return
}

// AddQuestion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *QuizQuiz) AddQuestion(ctx context.Context,
	objToCreate *basequizquestionexamplecomv1.QuizQuestion) (result *QuizquestionQuizQuestion, err error) {
	log.Debugf("[AddQuestion] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["quizes.quiz.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["quizes.quiz.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Quizquestion().CreateQuizQuestionByName(ctx, objToCreate)
	log.Debugf("[AddQuestion] QuizQuestion created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Quiz().GetQuizByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Quiz = updatedObj.Quiz
	}
	log.Debugf("[AddQuestion] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteQuestion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *QuizQuiz) DeleteQuestion(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteQuestion] Received for QuizQuestion object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizes.quiz.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", parentLabels, displayName)
	if IsChildExists("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Quiz.Quiz", "Question", displayName)
	}

	err = obj.client.Quizquestion().DeleteQuizQuestionByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteQuestion] QuizQuestion object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Quiz().GetQuizByName(ctx, obj.GetName())
	if err == nil {
		obj.Quiz = updatedObj.Quiz
	}
	return
}

type quizQuizExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *quizQuizExampleV1Chainer) Subscribe() {
	key := "quizes.quiz.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *quizQuizExampleV1Chainer) Unsubscribe() {
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *quizQuizExampleV1Chainer) IsSubscribed() bool {
	key := "quizes.quiz.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *quizQuizExampleV1Chainer) addCallback(obj *QuizQuiz) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["evaluations.evaluation.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("evaluations.evaluation.example.com", obj.Labels, parentDisplayName)

	AddChild("evaluations.evaluation.example.com", parentHashName, "quizes.quiz.example.com", obj.Name)
}

func (c *quizQuizExampleV1Chainer) deleteCallback(obj *QuizQuiz) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["evaluations.evaluation.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("evaluations.evaluation.example.com", obj.Labels, parentDisplayName)

	RemoveChild("evaluations.evaluation.example.com", parentHashName, "quizes.quiz.example.com", obj.Name)
}

func (c *quizQuizExampleV1Chainer) RegisterEventHandler(addCB func(obj *QuizQuiz), updateCB func(oldObj, newObj *QuizQuiz), deleteCB func(obj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizQuiz")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizQuiz, so creating a new one")
		informer = informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizQuiz{
				client: c.client,
				Quiz:   obj.(*basequizexamplecomv1.Quiz),
			}

			var parent *EvaluationEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
				parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name) {
				AddChild("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizQuiz{
				client: c.client,
				Quiz:   oldObj.(*basequizexamplecomv1.Quiz),
			}
			newData := &QuizQuiz{
				client: c.client,
				Quiz:   newObj.(*basequizexamplecomv1.Quiz),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &QuizQuiz{
				client: c.client,
				Quiz:   obj.(*basequizexamplecomv1.Quiz),
			}

			var parent *EvaluationEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
				parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name) {
				RemoveChild("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *quizQuizExampleV1Chainer) RegisterAddCallback(cbfn func(obj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizQuiz")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizQuiz, so creating a new one")
		informer = informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizQuiz{
				client: c.client,
				Quiz:   obj.(*basequizexamplecomv1.Quiz),
			}

			var parent *EvaluationEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
				parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name) {
				AddChild("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *quizQuizExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizQuiz")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizQuiz, so creating a new one")
		informer = informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizQuiz{
				client: c.client,
				Quiz:   oldObj.(*basequizexamplecomv1.Quiz),
			}
			newData := &QuizQuiz{
				client: c.client,
				Quiz:   newObj.(*basequizexamplecomv1.Quiz),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *quizQuizExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizQuiz")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizQuiz, so creating a new one")
		informer = informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &QuizQuiz{
				client: c.client,
				Quiz:   obj.(*basequizexamplecomv1.Quiz),
			}

			var parent *EvaluationEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
				parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name) {
				RemoveChild("evaluations.evaluation.example.com", parent.Name, "quizes.quiz.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *quizQuizExampleV1Chainer) Question(name string) *quizquestionQuizquestionExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["quizquestions.quizquestion.example.com"] = name
	return &quizquestionQuizquestionExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetQuestion calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *quizQuizExampleV1Chainer) GetQuestion(ctx context.Context, displayName string) (result *QuizquestionQuizQuestion, err error) {
	hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", c.parentLabels, displayName)
	return c.client.Quizquestion().GetQuizQuestionByName(ctx, hashedName)
}

// AddQuestion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *quizQuizExampleV1Chainer) AddQuestion(ctx context.Context,
	objToCreate *basequizquestionexamplecomv1.QuizQuestion) (result *QuizquestionQuizQuestion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Quizquestion().CreateQuizQuestionByName(ctx, objToCreate)
}

// DeleteQuestion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *quizQuizExampleV1Chainer) DeleteQuestion(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", c.parentLabels, name)
	return c.client.Quizquestion().DeleteQuizQuestionByName(ctx, hashedName)
}

func (group *QuizquestionExampleV1) GetQuizQuestionChildrenMap() map[string]basequizquestionexamplecomv1.Child {
	return map[string]basequizquestionexamplecomv1.Child{}
}

func (group *QuizquestionExampleV1) GetQuizQuestionChild(grp, kind, name string) basequizquestionexamplecomv1.Child {
	return basequizquestionexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetQuizQuestionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizquestionExampleV1) GetQuizQuestionByName(ctx context.Context, hashedName string) (*QuizquestionQuizQuestion, error) {
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetQuizQuestionByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basequizquestionexamplecomv1.QuizQuestion)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetQuizQuestionByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basequizquestionexamplecomv1.QuizQuestion).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetQuizQuestionByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &QuizquestionQuizQuestion{
					client:       group.client,
					QuizQuestion: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: resWrCache.(*basequizquestionexamplecomv1.QuizQuestion),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetQuizQuestionByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get QuizQuestions: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetQuizQuestionByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetQuizQuestionByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadQuizQuestionByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizquestionExampleV1) ForceReadQuizQuestionByName(ctx context.Context, hashedName string) (*QuizquestionQuizQuestion, error) {
	log.Debugf("[ForceReadQuizQuestionByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadQuizQuestionByName] Failed to Get QuizQuestions: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get QuizQuestions: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadQuizQuestionByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadQuizQuestionByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadQuizQuestionByName] Executed Successfully :%s", hashedName)
			return &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: result,
			}, nil
		}
	}
}

// DeleteQuizQuestionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *QuizquestionExampleV1) DeleteQuizQuestionByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteQuizQuestionByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basequizquestionexamplecomv1.QuizQuestion
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizQuestionByName] Failed to get QuizQuestions: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get QuizQuestions: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizQuestionByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("quizquestions.quizquestion.example.com", hashedName, "quizchoices.quizchoice.example.com") {
		err := group.client.Quizchoice().DeleteQuizChoiceByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("quizquestions.quizquestion.example.com", hashedName, "quizchoices.quizchoice.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizQuestionByName] failed to delete QuizQuestions: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete QuizQuestions: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizQuestionByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("quizquestions.quizquestion.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteQuizQuestionByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["quizes.quiz.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("quizes.quiz.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("quizes.quiz.example.com", parents, parentName)
	}
	RemoveChild("quizes.quiz.example.com", parentName, "quizquestions.quizquestion.example.com", hashedName)

	return nil
}

// CreateQuizQuestionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *QuizquestionExampleV1) CreateQuizQuestionByName(ctx context.Context,
	objToCreate *basequizquestionexamplecomv1.QuizQuestion) (*QuizquestionQuizQuestion, error) {
	log.Debugf("[CreateQuizQuestionByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ChoiceGvk = nil

	var (
		retryCount int
		result     *basequizquestionexamplecomv1.QuizQuestion
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateQuizQuestionByName] Failed to create QuizQuestion: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create QuizQuestion: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateQuizQuestionByName] context canceled while creating QuizQuestion: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateQuizQuestionByName] QuizQuestion: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.QuizquestionExampleV1().QuizQuestions().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateQuizQuestionByName] Unable to Get QuizQuestion %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateQuizQuestionByName] found unexpected error while creating QuizQuestion: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateQuizQuestionByName] QuizQuestion: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("quizquestions.quizquestion.example.com"); ok {
				log.Debugf("[CreateQuizQuestionByName] QuizQuestion: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["quizes.quiz.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("quizes.quiz.example.com", objToCreate.GetLabels(), parentName)

	AddChild("quizes.quiz.example.com", parentHashedName, "quizquestions.quizquestion.example.com", objToCreate.Name)

	log.Debugf("[CreateQuizQuestionByName] Executed Successfully: %s", objToCreate.GetName())
	return &QuizquestionQuizQuestion{
		client:       group.client,
		QuizQuestion: result,
	}, nil
}

// UpdateQuizQuestionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *QuizquestionExampleV1) UpdateQuizQuestionByName(ctx context.Context,
	objToUpdate *basequizquestionexamplecomv1.QuizQuestion) (*QuizquestionQuizQuestion, error) {
	log.Debugf("[UpdateQuizQuestionByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Quizquestion().GetQuizQuestionByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["quizquestions.quizquestion.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Question)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Question).IsNil() {
			patchValueQuestion := objToUpdate.Spec.Question
			patchOpQuestion := PatchOp{
				Op:    "replace",
				Path:  "/spec/question",
				Value: patchValueQuestion,
			}
			patch = append(patch, patchOpQuestion)
		}
	} else {
		patchValueQuestion := objToUpdate.Spec.Question
		patchOpQuestion := PatchOp{
			Op:    "replace",
			Path:  "/spec/question",
			Value: patchValueQuestion,
		}
		patch = append(patch, patchOpQuestion)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Hint)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Hint).IsNil() {
			patchValueHint := objToUpdate.Spec.Hint
			patchOpHint := PatchOp{
				Op:    "replace",
				Path:  "/spec/hint",
				Value: patchValueHint,
			}
			patch = append(patch, patchOpHint)
		}
	} else {
		patchValueHint := objToUpdate.Spec.Hint
		patchOpHint := PatchOp{
			Op:    "replace",
			Path:  "/spec/hint",
			Value: patchValueHint,
		}
		patch = append(patch, patchOpHint)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Answer)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Answer).IsNil() {
			patchValueAnswer := objToUpdate.Spec.Answer
			patchOpAnswer := PatchOp{
				Op:    "replace",
				Path:  "/spec/answer",
				Value: patchValueAnswer,
			}
			patch = append(patch, patchOpAnswer)
		}
	} else {
		patchValueAnswer := objToUpdate.Spec.Answer
		patchOpAnswer := PatchOp{
			Op:    "replace",
			Path:  "/spec/answer",
			Value: patchValueAnswer,
		}
		patch = append(patch, patchOpAnswer)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Format)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Format).IsNil() {
			patchValueFormat := objToUpdate.Spec.Format
			patchOpFormat := PatchOp{
				Op:    "replace",
				Path:  "/spec/format",
				Value: patchValueFormat,
			}
			patch = append(patch, patchOpFormat)
		}
	} else {
		patchValueFormat := objToUpdate.Spec.Format
		patchOpFormat := PatchOp{
			Op:    "replace",
			Path:  "/spec/format",
			Value: patchValueFormat,
		}
		patch = append(patch, patchOpFormat)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Score)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Score).IsNil() {
			patchValueScore := objToUpdate.Spec.Score
			patchOpScore := PatchOp{
				Op:    "replace",
				Path:  "/spec/score",
				Value: patchValueScore,
			}
			patch = append(patch, patchOpScore)
		}
	} else {
		patchValueScore := objToUpdate.Spec.Score
		patchOpScore := PatchOp{
			Op:    "replace",
			Path:  "/spec/score",
			Value: patchValueScore,
		}
		patch = append(patch, patchOpScore)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.AnimationFilePath)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.AnimationFilePath).IsNil() {
			patchValueAnimationFilePath := objToUpdate.Spec.AnimationFilePath
			patchOpAnimationFilePath := PatchOp{
				Op:    "replace",
				Path:  "/spec/animationFilePath",
				Value: patchValueAnimationFilePath,
			}
			patch = append(patch, patchOpAnimationFilePath)
		}
	} else {
		patchValueAnimationFilePath := objToUpdate.Spec.AnimationFilePath
		patchOpAnimationFilePath := PatchOp{
			Op:    "replace",
			Path:  "/spec/animationFilePath",
			Value: patchValueAnimationFilePath,
		}
		patch = append(patch, patchOpAnimationFilePath)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PictureFilePath)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PictureFilePath).IsNil() {
			patchValuePictureFilePath := objToUpdate.Spec.PictureFilePath
			patchOpPictureFilePath := PatchOp{
				Op:    "replace",
				Path:  "/spec/pictureFilePath",
				Value: patchValuePictureFilePath,
			}
			patch = append(patch, patchOpPictureFilePath)
		}
	} else {
		patchValuePictureFilePath := objToUpdate.Spec.PictureFilePath
		patchOpPictureFilePath := PatchOp{
			Op:    "replace",
			Path:  "/spec/pictureFilePath",
			Value: patchValuePictureFilePath,
		}
		patch = append(patch, patchOpPictureFilePath)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basequizquestionexamplecomv1.QuizQuestion
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateQuizQuestionByName] Failed to patch QuizQuestion %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger QuizQuestion Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteQuizQuestionByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting QuizQuestion: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("QuizQuestion deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateQuizQuestionByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateQuizQuestionByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger QuizQuestion Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteQuizQuestionByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting QuizQuestion: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("QuizQuestion Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateQuizQuestionByName] Patch QuizQuestion Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("quizquestions.quizquestion.example.com"); ok {
				log.Debugf("[UpdateQuizQuestionByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateQuizQuestionByName] Executed Successfully %s", objToUpdate.GetName())
	return &QuizquestionQuizQuestion{
		client:       group.client,
		QuizQuestion: result,
	}, nil
}

// ListQuizQuestions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *QuizquestionExampleV1) ListQuizQuestions(ctx context.Context,
	opts metav1.ListOptions) (result []*QuizquestionQuizQuestion, err error) {
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*QuizquestionQuizQuestion, len(items))
		for k, v := range items {
			item, _ := v.(*basequizquestionexamplecomv1.QuizQuestion)
			result[k] = &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: item,
			}
		}
	} else {
		list, err := group.client.baseClient.QuizquestionExampleV1().
			QuizQuestions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*QuizquestionQuizQuestion, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: &item,
			}
		}
	}
	return
}

type QuizquestionQuizQuestion struct {
	client *Clientset
	*basequizquestionexamplecomv1.QuizQuestion
}

// Delete removes obj and all it's children from the database.
func (obj *QuizquestionQuizQuestion) Delete(ctx context.Context) error {
	err := obj.client.Quizquestion().DeleteQuizQuestionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.QuizQuestion = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *QuizquestionQuizQuestion) Update(ctx context.Context) error {
	result, err := obj.client.Quizquestion().UpdateQuizQuestionByName(ctx, obj.QuizQuestion)
	if err != nil {
		return err
	}
	obj.QuizQuestion = result.QuizQuestion
	return nil
}

func (obj *QuizquestionQuizQuestion) GetParent(ctx context.Context) (result *QuizQuiz, err error) {
	hashedName := helper.GetHashedName("quizes.quiz.example.com", obj.Labels, obj.Labels["quizes.quiz.example.com"])
	return obj.client.Quiz().GetQuizByName(ctx, hashedName)
}

type QuizquestionQuizQuestionChoice struct {
	client *Clientset
	Choice []basequizquestionexamplecomv1.Child
}

func (n *QuizquestionQuizQuestionChoice) Next(ctx context.Context) (*QuizchoiceQuizChoice, error) {
	for index, child := range n.Choice {
		obj, err := n.client.Quizchoice().GetQuizChoiceByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Choice)-1 {
				n.Choice = nil
			} else {
				n.Choice = n.Choice[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllChoiceIter returns an iterator for all children of given type
func (obj *QuizquestionQuizQuestion) GetAllChoiceIter(ctx context.Context) (
	result QuizquestionQuizQuestionChoice) {
	result.client = obj.client
	for _, v := range GetChildren("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com") {
		result.Choice = append(result.Choice, basequizquestionexamplecomv1.Child{
			Group: "quizchoice.example.com",
			Kind:  "QuizChoice",
			Name:  v,
		})
	}
	return
}

// GetAllChoice returns all children of a given type
func (obj *QuizquestionQuizQuestion) GetAllChoice(ctx context.Context) (
	result []*QuizchoiceQuizChoice, err error) {
	for _, v := range GetChildren("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com") {
		l, err := obj.client.Quizchoice().GetQuizChoiceByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetChoice returns child which has given displayName
func (obj *QuizquestionQuizQuestion) GetChoice(ctx context.Context,
	displayName string) (result *QuizchoiceQuizChoice, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizquestions.quizquestion.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizchoices.quizchoice.example.com", parentLabels, displayName)
	if IsChildExists("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Quizquestion.QuizQuestion", "Choice", displayName)
	}

	result, err = obj.client.Quizchoice().GetQuizChoiceByName(ctx, childHashName)
	return
}

// AddChoice calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *QuizquestionQuizQuestion) AddChoice(ctx context.Context,
	objToCreate *basequizchoiceexamplecomv1.QuizChoice) (result *QuizchoiceQuizChoice, err error) {
	log.Debugf("[AddChoice] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["quizquestions.quizquestion.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["quizquestions.quizquestion.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Quizchoice().CreateQuizChoiceByName(ctx, objToCreate)
	log.Debugf("[AddChoice] QuizChoice created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Quizquestion().GetQuizQuestionByName(ctx, obj.GetName())
	if getErr == nil {
		obj.QuizQuestion = updatedObj.QuizQuestion
	}
	log.Debugf("[AddChoice] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteChoice calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *QuizquestionQuizQuestion) DeleteChoice(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteChoice] Received for QuizChoice object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizquestions.quizquestion.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizchoices.quizchoice.example.com", parentLabels, displayName)
	if IsChildExists("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Quizquestion.QuizQuestion", "Choice", displayName)
	}

	err = obj.client.Quizchoice().DeleteQuizChoiceByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteChoice] QuizChoice object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Quizquestion().GetQuizQuestionByName(ctx, obj.GetName())
	if err == nil {
		obj.QuizQuestion = updatedObj.QuizQuestion
	}
	return
}

type quizquestionQuizquestionExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *quizquestionQuizquestionExampleV1Chainer) Subscribe() {
	key := "quizquestions.quizquestion.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *quizquestionQuizquestionExampleV1Chainer) Unsubscribe() {
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *quizquestionQuizquestionExampleV1Chainer) IsSubscribed() bool {
	key := "quizquestions.quizquestion.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *quizquestionQuizquestionExampleV1Chainer) addCallback(obj *QuizquestionQuizQuestion) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizes.quiz.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizes.quiz.example.com", obj.Labels, parentDisplayName)

	AddChild("quizes.quiz.example.com", parentHashName, "quizquestions.quizquestion.example.com", obj.Name)
}

func (c *quizquestionQuizquestionExampleV1Chainer) deleteCallback(obj *QuizquestionQuizQuestion) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizes.quiz.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizes.quiz.example.com", obj.Labels, parentDisplayName)

	RemoveChild("quizes.quiz.example.com", parentHashName, "quizquestions.quizquestion.example.com", obj.Name)
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterEventHandler(addCB func(obj *QuizquestionQuizQuestion), updateCB func(oldObj, newObj *QuizquestionQuizQuestion), deleteCB func(obj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizquestionQuizQuestion")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizquestionQuizQuestion, so creating a new one")
		informer = informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
			}

			var parent *QuizQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
				parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name) {
				AddChild("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: oldObj.(*basequizquestionexamplecomv1.QuizQuestion),
			}
			newData := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: newObj.(*basequizquestionexamplecomv1.QuizQuestion),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
			}

			var parent *QuizQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
				parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name) {
				RemoveChild("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterAddCallback(cbfn func(obj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizquestionQuizQuestion")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizquestionQuizQuestion, so creating a new one")
		informer = informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
			}

			var parent *QuizQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
				parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name) {
				AddChild("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizquestionQuizQuestion")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizquestionQuizQuestion, so creating a new one")
		informer = informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: oldObj.(*basequizquestionexamplecomv1.QuizQuestion),
			}
			newData := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: newObj.(*basequizquestionexamplecomv1.QuizQuestion),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizquestionQuizQuestion")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizquestionQuizQuestion, so creating a new one")
		informer = informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
			}

			var parent *QuizQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
				parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name) {
				RemoveChild("quizes.quiz.example.com", parent.Name, "quizquestions.quizquestion.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) Choice(name string) *quizchoiceQuizchoiceExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["quizchoices.quizchoice.example.com"] = name
	return &quizchoiceQuizchoiceExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetChoice calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *quizquestionQuizquestionExampleV1Chainer) GetChoice(ctx context.Context, displayName string) (result *QuizchoiceQuizChoice, err error) {
	hashedName := helper.GetHashedName("quizchoices.quizchoice.example.com", c.parentLabels, displayName)
	return c.client.Quizchoice().GetQuizChoiceByName(ctx, hashedName)
}

// AddChoice calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *quizquestionQuizquestionExampleV1Chainer) AddChoice(ctx context.Context,
	objToCreate *basequizchoiceexamplecomv1.QuizChoice) (result *QuizchoiceQuizChoice, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("quizchoices.quizchoice.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Quizchoice().CreateQuizChoiceByName(ctx, objToCreate)
}

// DeleteChoice calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *quizquestionQuizquestionExampleV1Chainer) DeleteChoice(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("quizchoices.quizchoice.example.com", c.parentLabels, name)
	return c.client.Quizchoice().DeleteQuizChoiceByName(ctx, hashedName)
}

func (group *QuizchoiceExampleV1) GetQuizChoiceChildrenMap() map[string]basequizchoiceexamplecomv1.Child {
	return map[string]basequizchoiceexamplecomv1.Child{}
}

func (group *QuizchoiceExampleV1) GetQuizChoiceChild(grp, kind, name string) basequizchoiceexamplecomv1.Child {
	return basequizchoiceexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetQuizChoiceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizchoiceExampleV1) GetQuizChoiceByName(ctx context.Context, hashedName string) (*QuizchoiceQuizChoice, error) {
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetQuizChoiceByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basequizchoiceexamplecomv1.QuizChoice)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetQuizChoiceByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basequizchoiceexamplecomv1.QuizChoice).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetQuizChoiceByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &QuizchoiceQuizChoice{
					client:     group.client,
					QuizChoice: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: resWrCache.(*basequizchoiceexamplecomv1.QuizChoice),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetQuizChoiceByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get QuizChoices: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetQuizChoiceByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetQuizChoiceByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadQuizChoiceByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizchoiceExampleV1) ForceReadQuizChoiceByName(ctx context.Context, hashedName string) (*QuizchoiceQuizChoice, error) {
	log.Debugf("[ForceReadQuizChoiceByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadQuizChoiceByName] Failed to Get QuizChoices: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get QuizChoices: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadQuizChoiceByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadQuizChoiceByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadQuizChoiceByName] Executed Successfully :%s", hashedName)
			return &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: result,
			}, nil
		}
	}
}

// DeleteQuizChoiceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *QuizchoiceExampleV1) DeleteQuizChoiceByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteQuizChoiceByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basequizchoiceexamplecomv1.QuizChoice
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizChoiceByName] Failed to get QuizChoices: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get QuizChoices: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizChoiceByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizChoiceByName] failed to delete QuizChoices: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete QuizChoices: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizChoiceByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("quizchoices.quizchoice.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteQuizChoiceByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["quizquestions.quizquestion.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("quizquestions.quizquestion.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("quizquestions.quizquestion.example.com", parents, parentName)
	}
	RemoveChild("quizquestions.quizquestion.example.com", parentName, "quizchoices.quizchoice.example.com", hashedName)

	return nil
}

// CreateQuizChoiceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *QuizchoiceExampleV1) CreateQuizChoiceByName(ctx context.Context,
	objToCreate *basequizchoiceexamplecomv1.QuizChoice) (*QuizchoiceQuizChoice, error) {
	log.Debugf("[CreateQuizChoiceByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *basequizchoiceexamplecomv1.QuizChoice
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateQuizChoiceByName] Failed to create QuizChoice: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create QuizChoice: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateQuizChoiceByName] context canceled while creating QuizChoice: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateQuizChoiceByName] QuizChoice: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.QuizchoiceExampleV1().QuizChoices().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateQuizChoiceByName] Unable to Get QuizChoice %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateQuizChoiceByName] found unexpected error while creating QuizChoice: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateQuizChoiceByName] QuizChoice: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("quizchoices.quizchoice.example.com"); ok {
				log.Debugf("[CreateQuizChoiceByName] QuizChoice: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["quizquestions.quizquestion.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", objToCreate.GetLabels(), parentName)

	AddChild("quizquestions.quizquestion.example.com", parentHashedName, "quizchoices.quizchoice.example.com", objToCreate.Name)

	log.Debugf("[CreateQuizChoiceByName] Executed Successfully: %s", objToCreate.GetName())
	return &QuizchoiceQuizChoice{
		client:     group.client,
		QuizChoice: result,
	}, nil
}

// UpdateQuizChoiceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *QuizchoiceExampleV1) UpdateQuizChoiceByName(ctx context.Context,
	objToUpdate *basequizchoiceexamplecomv1.QuizChoice) (*QuizchoiceQuizChoice, error) {
	log.Debugf("[UpdateQuizChoiceByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Quizchoice().GetQuizChoiceByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["quizchoices.quizchoice.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Choice)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Choice).IsNil() {
			patchValueChoice := objToUpdate.Spec.Choice
			patchOpChoice := PatchOp{
				Op:    "replace",
				Path:  "/spec/choice",
				Value: patchValueChoice,
			}
			patch = append(patch, patchOpChoice)
		}
	} else {
		patchValueChoice := objToUpdate.Spec.Choice
		patchOpChoice := PatchOp{
			Op:    "replace",
			Path:  "/spec/choice",
			Value: patchValueChoice,
		}
		patch = append(patch, patchOpChoice)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Hint)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Hint).IsNil() {
			patchValueHint := objToUpdate.Spec.Hint
			patchOpHint := PatchOp{
				Op:    "replace",
				Path:  "/spec/hint",
				Value: patchValueHint,
			}
			patch = append(patch, patchOpHint)
		}
	} else {
		patchValueHint := objToUpdate.Spec.Hint
		patchOpHint := PatchOp{
			Op:    "replace",
			Path:  "/spec/hint",
			Value: patchValueHint,
		}
		patch = append(patch, patchOpHint)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PictureName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PictureName).IsNil() {
			patchValuePictureName := objToUpdate.Spec.PictureName
			patchOpPictureName := PatchOp{
				Op:    "replace",
				Path:  "/spec/pictureName",
				Value: patchValuePictureName,
			}
			patch = append(patch, patchOpPictureName)
		}
	} else {
		patchValuePictureName := objToUpdate.Spec.PictureName
		patchOpPictureName := PatchOp{
			Op:    "replace",
			Path:  "/spec/pictureName",
			Value: patchValuePictureName,
		}
		patch = append(patch, patchOpPictureName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basequizchoiceexamplecomv1.QuizChoice
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateQuizChoiceByName] Failed to patch QuizChoice %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger QuizChoice Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteQuizChoiceByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting QuizChoice: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("QuizChoice deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateQuizChoiceByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateQuizChoiceByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger QuizChoice Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteQuizChoiceByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting QuizChoice: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("QuizChoice Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateQuizChoiceByName] Patch QuizChoice Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("quizchoices.quizchoice.example.com"); ok {
				log.Debugf("[UpdateQuizChoiceByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateQuizChoiceByName] Executed Successfully %s", objToUpdate.GetName())
	return &QuizchoiceQuizChoice{
		client:     group.client,
		QuizChoice: result,
	}, nil
}

// ListQuizChoices returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *QuizchoiceExampleV1) ListQuizChoices(ctx context.Context,
	opts metav1.ListOptions) (result []*QuizchoiceQuizChoice, err error) {
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*QuizchoiceQuizChoice, len(items))
		for k, v := range items {
			item, _ := v.(*basequizchoiceexamplecomv1.QuizChoice)
			result[k] = &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: item,
			}
		}
	} else {
		list, err := group.client.baseClient.QuizchoiceExampleV1().
			QuizChoices().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*QuizchoiceQuizChoice, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: &item,
			}
		}
	}
	return
}

type QuizchoiceQuizChoice struct {
	client *Clientset
	*basequizchoiceexamplecomv1.QuizChoice
}

// Delete removes obj and all it's children from the database.
func (obj *QuizchoiceQuizChoice) Delete(ctx context.Context) error {
	err := obj.client.Quizchoice().DeleteQuizChoiceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.QuizChoice = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *QuizchoiceQuizChoice) Update(ctx context.Context) error {
	result, err := obj.client.Quizchoice().UpdateQuizChoiceByName(ctx, obj.QuizChoice)
	if err != nil {
		return err
	}
	obj.QuizChoice = result.QuizChoice
	return nil
}

func (obj *QuizchoiceQuizChoice) GetParent(ctx context.Context) (result *QuizquestionQuizQuestion, err error) {
	hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", obj.Labels, obj.Labels["quizquestions.quizquestion.example.com"])
	return obj.client.Quizquestion().GetQuizQuestionByName(ctx, hashedName)
}

type quizchoiceQuizchoiceExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) Subscribe() {
	key := "quizchoices.quizchoice.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) Unsubscribe() {
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) IsSubscribed() bool {
	key := "quizchoices.quizchoice.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) addCallback(obj *QuizchoiceQuizChoice) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizquestions.quizquestion.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", obj.Labels, parentDisplayName)

	AddChild("quizquestions.quizquestion.example.com", parentHashName, "quizchoices.quizchoice.example.com", obj.Name)
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) deleteCallback(obj *QuizchoiceQuizChoice) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizquestions.quizquestion.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", obj.Labels, parentDisplayName)

	RemoveChild("quizquestions.quizquestion.example.com", parentHashName, "quizchoices.quizchoice.example.com", obj.Name)
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterEventHandler(addCB func(obj *QuizchoiceQuizChoice), updateCB func(oldObj, newObj *QuizchoiceQuizChoice), deleteCB func(obj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizchoiceQuizChoice")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizchoiceQuizChoice, so creating a new one")
		informer = informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
			}

			var parent *QuizquestionQuizQuestion
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
				parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name) {
				AddChild("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: oldObj.(*basequizchoiceexamplecomv1.QuizChoice),
			}
			newData := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: newObj.(*basequizchoiceexamplecomv1.QuizChoice),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
			}

			var parent *QuizquestionQuizQuestion
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
				parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name) {
				RemoveChild("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterAddCallback(cbfn func(obj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizchoiceQuizChoice")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizchoiceQuizChoice, so creating a new one")
		informer = informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
			}

			var parent *QuizquestionQuizQuestion
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
				parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name) {
				AddChild("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizchoiceQuizChoice")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizchoiceQuizChoice, so creating a new one")
		informer = informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: oldObj.(*basequizchoiceexamplecomv1.QuizChoice),
			}
			newData := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: newObj.(*basequizchoiceexamplecomv1.QuizChoice),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizchoiceQuizChoice")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizchoiceQuizChoice, so creating a new one")
		informer = informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
			}

			var parent *QuizquestionQuizQuestion
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
				parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name) {
				RemoveChild("quizquestions.quizquestion.example.com", parent.Name, "quizchoices.quizchoice.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *TenantExampleV1) GetTenantChildrenMap() map[string]basetenantexamplecomv1.Child {
	return map[string]basetenantexamplecomv1.Child{}
}

func (group *TenantExampleV1) GetTenantChild(grp, kind, name string) basetenantexamplecomv1.Child {
	return basetenantexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetTenantByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) GetTenantByName(ctx context.Context, hashedName string) (*TenantTenant, error) {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetTenantByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basetenantexamplecomv1.Tenant)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetTenantByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basetenantexamplecomv1.Tenant).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetTenantByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &TenantTenant{
					client: group.client,
					Tenant: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &TenantTenant{
				client: group.client,
				Tenant: resWrCache.(*basetenantexamplecomv1.Tenant),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &TenantTenant{
				client: group.client,
				Tenant: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetTenantByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Tenants: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetTenantByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetTenantByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadTenantByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) ForceReadTenantByName(ctx context.Context, hashedName string) (*TenantTenant, error) {
	log.Debugf("[ForceReadTenantByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadTenantByName] Failed to Get Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Tenants: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadTenantByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadTenantByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadTenantByName] Executed Successfully :%s", hashedName)
			return &TenantTenant{
				client: group.client,
				Tenant: result,
			}, nil
		}
	}
}

// DeleteTenantByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) DeleteTenantByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteTenantByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basetenantexamplecomv1.Tenant
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteTenantByName] Failed to get Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Tenants: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteTenantByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteTenantByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteTenantByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("tenants.tenant.example.com", hashedName, "configs.config.example.com") {
		err := group.client.Config().DeleteConfigByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("tenants.tenant.example.com", hashedName, "configs.config.example.com", child)
	}

	for _, child := range GetChildren("tenants.tenant.example.com", hashedName, "interests.interest.example.com") {
		err := group.client.Interest().DeleteInterestByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("tenants.tenant.example.com", hashedName, "interests.interest.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteTenantByName] failed to delete Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Tenants: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteTenantByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteTenantByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteTenantByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteTenantByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
	}
	RemoveChild("roots.root.example.com", parentName, "tenants.tenant.example.com", hashedName)

	return nil
}

// CreateTenantByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *TenantExampleV1) CreateTenantByName(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (*TenantTenant, error) {
	log.Debugf("[CreateTenantByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConfigGvk = nil
	objToCreate.Spec.InterestGvk = nil

	var (
		retryCount int
		result     *basetenantexamplecomv1.Tenant
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateTenantByName] Failed to create Tenant: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Tenant: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateTenantByName] context canceled while creating Tenant: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateTenantByName] Tenant: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.TenantExampleV1().Tenants().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateTenantByName] Unable to Get Tenant %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateTenantByName] found unexpected error while creating Tenant: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateTenantByName] Tenant: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				log.Debugf("[CreateTenantByName] Tenant: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("roots.root.example.com", objToCreate.GetLabels(), parentName)

	AddChild("roots.root.example.com", parentHashedName, "tenants.tenant.example.com", objToCreate.Name)

	log.Debugf("[CreateTenantByName] Executed Successfully: %s", objToCreate.GetName())
	return &TenantTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// UpdateTenantByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *TenantExampleV1) UpdateTenantByName(ctx context.Context,
	objToUpdate *basetenantexamplecomv1.Tenant) (*TenantTenant, error) {
	log.Debugf("[UpdateTenantByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Tenant().GetTenantByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["tenants.tenant.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basetenantexamplecomv1.Tenant
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateTenantByName] Failed to patch Tenant %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Tenant Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteTenantByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Tenant: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Tenant deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateTenantByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateTenantByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Tenant Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteTenantByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Tenant: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Tenant Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateTenantByName] Patch Tenant Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				log.Debugf("[UpdateTenantByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateTenantByName] Executed Successfully %s", objToUpdate.GetName())
	return &TenantTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// ListTenants returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *TenantExampleV1) ListTenants(ctx context.Context,
	opts metav1.ListOptions) (result []*TenantTenant, err error) {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*TenantTenant, len(items))
		for k, v := range items {
			item, _ := v.(*basetenantexamplecomv1.Tenant)
			result[k] = &TenantTenant{
				client: group.client,
				Tenant: item,
			}
		}
	} else {
		list, err := group.client.baseClient.TenantExampleV1().
			Tenants().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*TenantTenant, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &TenantTenant{
				client: group.client,
				Tenant: &item,
			}
		}
	}
	return
}

type TenantTenant struct {
	client *Clientset
	*basetenantexamplecomv1.Tenant
}

// Delete removes obj and all it's children from the database.
func (obj *TenantTenant) Delete(ctx context.Context) error {
	err := obj.client.Tenant().DeleteTenantByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Tenant = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *TenantTenant) Update(ctx context.Context) error {
	result, err := obj.client.Tenant().UpdateTenantByName(ctx, obj.Tenant)
	if err != nil {
		return err
	}
	obj.Tenant = result.Tenant
	return nil
}

func (obj *TenantTenant) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", obj.Labels, obj.Labels["roots.root.example.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *TenantTenant) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "configs.config.example.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Config")
	}
	return obj.client.Config().GetConfigByName(ctx, children[0])
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenantTenant) AddConfig(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (result *ConfigConfig, err error) {
	log.Debugf("[AddConfig] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.tenant.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.tenant.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	log.Debugf("[AddConfig] Config created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	log.Debugf("[AddConfig] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenantTenant) DeleteConfig(ctx context.Context) (err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "configs.config.example.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteConfig] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Config().DeleteConfigByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Tenant().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

type TenantTenantInterest struct {
	client   *Clientset
	Interest []basetenantexamplecomv1.Child
}

func (n *TenantTenantInterest) Next(ctx context.Context) (*InterestInterest, error) {
	for index, child := range n.Interest {
		obj, err := n.client.Interest().GetInterestByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Interest)-1 {
				n.Interest = nil
			} else {
				n.Interest = n.Interest[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllInterestIter returns an iterator for all children of given type
func (obj *TenantTenant) GetAllInterestIter(ctx context.Context) (
	result TenantTenantInterest) {
	result.client = obj.client
	for _, v := range GetChildren("tenants.tenant.example.com", obj.Name, "interests.interest.example.com") {
		result.Interest = append(result.Interest, basetenantexamplecomv1.Child{
			Group: "interest.example.com",
			Kind:  "Interest",
			Name:  v,
		})
	}
	return
}

// GetAllInterest returns all children of a given type
func (obj *TenantTenant) GetAllInterest(ctx context.Context) (
	result []*InterestInterest, err error) {
	for _, v := range GetChildren("tenants.tenant.example.com", obj.Name, "interests.interest.example.com") {
		l, err := obj.client.Interest().GetInterestByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetInterest returns child which has given displayName
func (obj *TenantTenant) GetInterest(ctx context.Context,
	displayName string) (result *InterestInterest, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["tenants.tenant.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("interests.interest.example.com", parentLabels, displayName)
	if IsChildExists("tenants.tenant.example.com", obj.Name, "interests.interest.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Interest", displayName)
	}

	result, err = obj.client.Interest().GetInterestByName(ctx, childHashName)
	return
}

// AddInterest calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenantTenant) AddInterest(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (result *InterestInterest, err error) {
	log.Debugf("[AddInterest] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.tenant.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.tenant.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Interest().CreateInterestByName(ctx, objToCreate)
	log.Debugf("[AddInterest] Interest created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	log.Debugf("[AddInterest] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteInterest calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenantTenant) DeleteInterest(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteInterest] Received for Interest object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["tenants.tenant.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("interests.interest.example.com", parentLabels, displayName)
	if IsChildExists("tenants.tenant.example.com", obj.Name, "interests.interest.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Interest", displayName)
	}

	err = obj.client.Interest().DeleteInterestByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteInterest] Interest object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

type tenantTenantExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *tenantTenantExampleV1Chainer) Subscribe() {
	key := "tenants.tenant.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *tenantTenantExampleV1Chainer) Unsubscribe() {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *tenantTenantExampleV1Chainer) IsSubscribed() bool {
	key := "tenants.tenant.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *tenantTenantExampleV1Chainer) addCallback(obj *TenantTenant) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	AddChild("roots.root.example.com", parentHashName, "tenants.tenant.example.com", obj.Name)
}

func (c *tenantTenantExampleV1Chainer) deleteCallback(obj *TenantTenant) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	RemoveChild("roots.root.example.com", parentHashName, "tenants.tenant.example.com", obj.Name)
}

func (c *tenantTenantExampleV1Chainer) RegisterEventHandler(addCB func(obj *TenantTenant), updateCB func(oldObj, newObj *TenantTenant), deleteCB func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenantTenant")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenantTenant, so creating a new one")
		informer = informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name) {
				AddChild("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &TenantTenant{
				client: c.client,
				Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
			}
			newData := &TenantTenant{
				client: c.client,
				Tenant: newObj.(*basetenantexamplecomv1.Tenant),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name) {
				RemoveChild("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterAddCallback(cbfn func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenantTenant")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenantTenant, so creating a new one")
		informer = informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name) {
				AddChild("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenantTenant")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenantTenant, so creating a new one")
		informer = informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &TenantTenant{
				client: c.client,
				Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
			}
			newData := &TenantTenant{
				client: c.client,
				Tenant: newObj.(*basetenantexamplecomv1.Tenant),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenantTenant")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenantTenant, so creating a new one")
		informer = informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name) {
				RemoveChild("roots.root.example.com", parent.Name, "tenants.tenant.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) Config() *configConfigExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.example.com"] = helper.DEFAULT_KEY
	return &configConfigExampleV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on it's parents and returns the object
func (c *tenantTenantExampleV1Chainer) GetConfig(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantTenantExampleV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantTenantExampleV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

func (c *tenantTenantExampleV1Chainer) Interest(name string) *interestInterestExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["interests.interest.example.com"] = name
	return &interestInterestExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetInterest calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *tenantTenantExampleV1Chainer) GetInterest(ctx context.Context, displayName string) (result *InterestInterest, err error) {
	hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, displayName)
	return c.client.Interest().GetInterestByName(ctx, hashedName)
}

// AddInterest calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantTenantExampleV1Chainer) AddInterest(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (result *InterestInterest, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Interest().CreateInterestByName(ctx, objToCreate)
}

// DeleteInterest calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantTenantExampleV1Chainer) DeleteInterest(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, name)
	return c.client.Interest().DeleteInterestByName(ctx, hashedName)
}

func (group *ConfigExampleV1) GetConfigChildrenMap() map[string]baseconfigexamplecomv1.Child {
	return map[string]baseconfigexamplecomv1.Child{}
}

func (group *ConfigExampleV1) GetConfigChild(grp, kind, name string) baseconfigexamplecomv1.Child {
	return baseconfigexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetConfigByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseconfigexamplecomv1.Config)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetConfigByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseconfigexamplecomv1.Config).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetConfigByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ConfigConfig{
					client: group.client,
					Config: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ConfigConfig{
				client: group.client,
				Config: resWrCache.(*baseconfigexamplecomv1.Config),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetConfigByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadConfigByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) ForceReadConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	log.Debugf("[ForceReadConfigByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadConfigByName] Failed to Get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadConfigByName] Executed Successfully :%s", hashedName)
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		}
	}
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteConfigByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseconfigexamplecomv1.Config
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] Failed to get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("configs.config.example.com", hashedName, "users.user.example.com") {
		err := group.client.User().DeleteUserByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.example.com", hashedName, "users.user.example.com", child)
	}

	for _, child := range GetChildren("configs.config.example.com", hashedName, "events.event.example.com") {
		err := group.client.Event().DeleteEventByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.example.com", hashedName, "events.event.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] failed to delete Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteConfigByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
	}
	RemoveChild("tenants.tenant.example.com", parentName, "configs.config.example.com", hashedName)

	return nil
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigExampleV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[CreateConfigByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.UserGvk = nil
	objToCreate.Spec.EventGvk = nil

	var (
		retryCount int
		result     *baseconfigexamplecomv1.Config
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateConfigByName] Failed to create Config: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Config: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateConfigByName] context canceled while creating Config: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateConfigByName] Config: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ConfigExampleV1().Configs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateConfigByName] Unable to Get Config %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateConfigByName] found unexpected error while creating Config: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateConfigByName] Config: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				log.Debugf("[CreateConfigByName] Config: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("tenants.tenant.example.com", objToCreate.GetLabels(), parentName)

	AddChild("tenants.tenant.example.com", parentHashedName, "configs.config.example.com", objToCreate.Name)

	log.Debugf("[CreateConfigByName] Executed Successfully: %s", objToCreate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigExampleV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigexamplecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[UpdateConfigByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Config().GetConfigByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["configs.config.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseconfigexamplecomv1.Config
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateConfigByName] Failed to patch Config %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Config: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Config deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateConfigByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateConfigByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Config: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Config Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateConfigByName] Patch Config Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				log.Debugf("[UpdateConfigByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateConfigByName] Executed Successfully %s", objToUpdate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigExampleV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigexamplecomv1.Config)
			result[k] = &ConfigConfig{
				client: group.client,
				Config: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigExampleV1().
			Configs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigConfig{
				client: group.client,
				Config: &item,
			}
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigexamplecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, obj.Labels["tenants.tenant.example.com"])
	return obj.client.Tenant().GetTenantByName(ctx, hashedName)
}

type ConfigConfigUser struct {
	client *Clientset
	User   []baseconfigexamplecomv1.Child
}

func (n *ConfigConfigUser) Next(ctx context.Context) (*UserUser, error) {
	for index, child := range n.User {
		obj, err := n.client.User().GetUserByName(ctx, child.Name)
		if err == nil {
			if index == len(n.User)-1 {
				n.User = nil
			} else {
				n.User = n.User[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllUserIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllUserIter(ctx context.Context) (
	result ConfigConfigUser) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "users.user.example.com") {
		result.User = append(result.User, baseconfigexamplecomv1.Child{
			Group: "user.example.com",
			Kind:  "User",
			Name:  v,
		})
	}
	return
}

// GetAllUser returns all children of a given type
func (obj *ConfigConfig) GetAllUser(ctx context.Context) (
	result []*UserUser, err error) {
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "users.user.example.com") {
		l, err := obj.client.User().GetUserByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUser returns child which has given displayName
func (obj *ConfigConfig) GetUser(ctx context.Context,
	displayName string) (result *UserUser, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("users.user.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "users.user.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "User", displayName)
	}

	result, err = obj.client.User().GetUserByName(ctx, childHashName)
	return
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddUser(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (result *UserUser, err error) {
	log.Debugf("[AddUser] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.User().CreateUserByName(ctx, objToCreate)
	log.Debugf("[AddUser] User created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddUser] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteUser(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteUser] Received for User object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("users.user.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "users.user.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "User", displayName)
	}

	err = obj.client.User().DeleteUserByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteUser] User object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type ConfigConfigEvent struct {
	client *Clientset
	Event  []baseconfigexamplecomv1.Child
}

func (n *ConfigConfigEvent) Next(ctx context.Context) (*EventEvent, error) {
	for index, child := range n.Event {
		obj, err := n.client.Event().GetEventByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Event)-1 {
				n.Event = nil
			} else {
				n.Event = n.Event[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllEventIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllEventIter(ctx context.Context) (
	result ConfigConfigEvent) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "events.event.example.com") {
		result.Event = append(result.Event, baseconfigexamplecomv1.Child{
			Group: "event.example.com",
			Kind:  "Event",
			Name:  v,
		})
	}
	return
}

// GetAllEvent returns all children of a given type
func (obj *ConfigConfig) GetAllEvent(ctx context.Context) (
	result []*EventEvent, err error) {
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "events.event.example.com") {
		l, err := obj.client.Event().GetEventByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEvent returns child which has given displayName
func (obj *ConfigConfig) GetEvent(ctx context.Context,
	displayName string) (result *EventEvent, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("events.event.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "events.event.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "Event", displayName)
	}

	result, err = obj.client.Event().GetEventByName(ctx, childHashName)
	return
}

// AddEvent calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddEvent(ctx context.Context,
	objToCreate *baseeventexamplecomv1.Event) (result *EventEvent, err error) {
	log.Debugf("[AddEvent] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Event().CreateEventByName(ctx, objToCreate)
	log.Debugf("[AddEvent] Event created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddEvent] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteEvent calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteEvent(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteEvent] Received for Event object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("events.event.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "events.event.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "Event", displayName)
	}

	err = obj.client.Event().DeleteEventByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteEvent] Event object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigExampleV1Chainer) Subscribe() {
	key := "configs.config.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *configConfigExampleV1Chainer) Unsubscribe() {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configConfigExampleV1Chainer) IsSubscribed() bool {
	key := "configs.config.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *configConfigExampleV1Chainer) addCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	AddChild("tenants.tenant.example.com", parentHashName, "configs.config.example.com", obj.Name)
}

func (c *configConfigExampleV1Chainer) deleteCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	RemoveChild("tenants.tenant.example.com", parentHashName, "configs.config.example.com", obj.Name)
}

func (c *configConfigExampleV1Chainer) RegisterEventHandler(addCB func(obj *ConfigConfig), updateCB func(oldObj, newObj *ConfigConfig), deleteCB func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name) {
				AddChild("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigexamplecomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigexamplecomv1.Config),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name) {
				RemoveChild("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterAddCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name) {
				AddChild("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigexamplecomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigexamplecomv1.Config),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name) {
				RemoveChild("tenants.tenant.example.com", parent.Name, "configs.config.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *configConfigExampleV1Chainer) User(name string) *userUserExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["users.user.example.com"] = name
	return &userUserExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUser calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigExampleV1Chainer) GetUser(ctx context.Context, displayName string) (result *UserUser, err error) {
	hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, displayName)
	return c.client.User().GetUserByName(ctx, hashedName)
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigExampleV1Chainer) AddUser(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (result *UserUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.User().CreateUserByName(ctx, objToCreate)
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigExampleV1Chainer) DeleteUser(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, name)
	return c.client.User().DeleteUserByName(ctx, hashedName)
}

func (c *configConfigExampleV1Chainer) Event(name string) *eventEventExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["events.event.example.com"] = name
	return &eventEventExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEvent calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigExampleV1Chainer) GetEvent(ctx context.Context, displayName string) (result *EventEvent, err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, displayName)
	return c.client.Event().GetEventByName(ctx, hashedName)
}

// AddEvent calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigExampleV1Chainer) AddEvent(ctx context.Context,
	objToCreate *baseeventexamplecomv1.Event) (result *EventEvent, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Event().CreateEventByName(ctx, objToCreate)
}

// DeleteEvent calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigExampleV1Chainer) DeleteEvent(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, name)
	return c.client.Event().DeleteEventByName(ctx, hashedName)
}

func (group *EventExampleV1) GetEventChildrenMap() map[string]baseeventexamplecomv1.Child {
	return map[string]baseeventexamplecomv1.Child{}
}

func (group *EventExampleV1) GetEventChild(grp, kind, name string) baseeventexamplecomv1.Child {
	return baseeventexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetEventByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EventExampleV1) GetEventByName(ctx context.Context, hashedName string) (*EventEvent, error) {
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetEventByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseeventexamplecomv1.Event)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetEventByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseeventexamplecomv1.Event).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetEventByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &EventEvent{
					client: group.client,
					Event:  resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &EventEvent{
				client: group.client,
				Event:  resWrCache.(*baseeventexamplecomv1.Event),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EventExampleV1().
			Events().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &EventEvent{
				client: group.client,
				Event:  result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetEventByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Events: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetEventByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetEventByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadEventByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EventExampleV1) ForceReadEventByName(ctx context.Context, hashedName string) (*EventEvent, error) {
	log.Debugf("[ForceReadEventByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EventExampleV1().
			Events().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadEventByName] Failed to Get Events: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Events: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadEventByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadEventByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadEventByName] Executed Successfully :%s", hashedName)
			return &EventEvent{
				client: group.client,
				Event:  result,
			}, nil
		}
	}
}

// DeleteEventByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *EventExampleV1) DeleteEventByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteEventByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseeventexamplecomv1.Event
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EventExampleV1().
			Events().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteEventByName] Failed to get Events: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Events: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEventByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEventByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEventByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			EventExampleV1().
			Events().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteEventByName] failed to delete Events: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Events: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEventByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEventByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEventByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteEventByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
	}
	RemoveChild("configs.config.example.com", parentName, "events.event.example.com", hashedName)

	return nil
}

// CreateEventByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *EventExampleV1) CreateEventByName(ctx context.Context,
	objToCreate *baseeventexamplecomv1.Event) (*EventEvent, error) {
	log.Debugf("[CreateEventByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseeventexamplecomv1.Event
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EventExampleV1().
			Events().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateEventByName] Failed to create Event: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Event: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateEventByName] context canceled while creating Event: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateEventByName] Event: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.EventExampleV1().Events().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateEventByName] Unable to Get Event %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateEventByName] found unexpected error while creating Event: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateEventByName] Event: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
				log.Debugf("[CreateEventByName] Event: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.example.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.example.com", parentHashedName, "events.event.example.com", objToCreate.Name)

	log.Debugf("[CreateEventByName] Executed Successfully: %s", objToCreate.GetName())
	return &EventEvent{
		client: group.client,
		Event:  result,
	}, nil
}

// SetEventStatusByName sets user defined status
func (group *EventExampleV1) SetEventStatusByName(ctx context.Context,
	objToUpdate *baseeventexamplecomv1.Event, status *baseeventexamplecomv1.Status) (*EventEvent, error) {
	log.Debugf("[SetEventStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "event.example.com",
		Version:  "v1",
		Resource: strings.ToLower("Events"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := baseeventexamplecomv1.Event{}
	obj.Kind = strings.ToLower("Events")
	obj.APIVersion = "event.example.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.Status = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.dynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			log.Debugf("[SetEventStatusByName] Updating status for Event node %s successful", hashedName)
			break
		}

		log.Errorf("[SetEventStatusByName] Updating status for Event node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadEventByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			log.Fatalf("[SetEventStatusByName] Max retry exceeded for updating status for Event node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *baseeventexamplecomv1.Event
			if inWrCache {
				objectToWrite = resWrCache.(*baseeventexamplecomv1.Event)
				objectToWrite.Status.Status = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.Status = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &EventEvent{
		client: group.client,
		Event:  objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateEventByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *EventExampleV1) UpdateEventByName(ctx context.Context,
	objToUpdate *baseeventexamplecomv1.Event) (*EventEvent, error) {
	log.Debugf("[UpdateEventByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Event().GetEventByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["events.event.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.MeetingLink)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.MeetingLink).IsNil() {
			patchValueMeetingLink := objToUpdate.Spec.MeetingLink
			patchOpMeetingLink := PatchOp{
				Op:    "replace",
				Path:  "/spec/meetingLink",
				Value: patchValueMeetingLink,
			}
			patch = append(patch, patchOpMeetingLink)
		}
	} else {
		patchValueMeetingLink := objToUpdate.Spec.MeetingLink
		patchOpMeetingLink := PatchOp{
			Op:    "replace",
			Path:  "/spec/meetingLink",
			Value: patchValueMeetingLink,
		}
		patch = append(patch, patchOpMeetingLink)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Time)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Time).IsNil() {
			patchValueTime := objToUpdate.Spec.Time
			patchOpTime := PatchOp{
				Op:    "replace",
				Path:  "/spec/time",
				Value: patchValueTime,
			}
			patch = append(patch, patchOpTime)
		}
	} else {
		patchValueTime := objToUpdate.Spec.Time
		patchOpTime := PatchOp{
			Op:    "replace",
			Path:  "/spec/time",
			Value: patchValueTime,
		}
		patch = append(patch, patchOpTime)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Public)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Public).IsNil() {
			patchValuePublic := objToUpdate.Spec.Public
			patchOpPublic := PatchOp{
				Op:    "replace",
				Path:  "/spec/public",
				Value: patchValuePublic,
			}
			patch = append(patch, patchOpPublic)
		}
	} else {
		patchValuePublic := objToUpdate.Spec.Public
		patchOpPublic := PatchOp{
			Op:    "replace",
			Path:  "/spec/public",
			Value: patchValuePublic,
		}
		patch = append(patch, patchOpPublic)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseeventexamplecomv1.Event
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			EventExampleV1().
			Events().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateEventByName] Failed to patch Event %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Event Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteEventByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Event: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Event deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateEventByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateEventByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Event Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteEventByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Event: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Event Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateEventByName] Patch Event Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
				log.Debugf("[UpdateEventByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateEventByName] Executed Successfully %s", objToUpdate.GetName())
	return &EventEvent{
		client: group.client,
		Event:  result,
	}, nil
}

// ListEvents returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *EventExampleV1) ListEvents(ctx context.Context,
	opts metav1.ListOptions) (result []*EventEvent, err error) {
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*EventEvent, len(items))
		for k, v := range items {
			item, _ := v.(*baseeventexamplecomv1.Event)
			result[k] = &EventEvent{
				client: group.client,
				Event:  item,
			}
		}
	} else {
		list, err := group.client.baseClient.EventExampleV1().
			Events().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*EventEvent, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &EventEvent{
				client: group.client,
				Event:  &item,
			}
		}
	}
	return
}

type EventEvent struct {
	client *Clientset
	*baseeventexamplecomv1.Event
}

// Delete removes obj and all it's children from the database.
func (obj *EventEvent) Delete(ctx context.Context) error {
	err := obj.client.Event().DeleteEventByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Event = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *EventEvent) Update(ctx context.Context) error {
	result, err := obj.client.Event().UpdateEventByName(ctx, obj.Event)
	if err != nil {
		return err
	}
	obj.Event = result.Event
	return nil
}

// SetStatus sets user defined status
func (obj *EventEvent) SetStatus(ctx context.Context, status *baseeventexamplecomv1.Status) error {
	result, err := obj.client.Event().SetEventStatusByName(ctx, obj.Event, status)
	if err != nil {
		return err
	}
	obj.Event = result.Event
	return nil
}

// GetStatus to get user defined status
func (obj *EventEvent) GetStatus(ctx context.Context) (*baseeventexamplecomv1.Status, error) {
	getObj, err := obj.client.Event().GetEventByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *EventEvent) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Event().SetEventStatusByName(ctx, obj.Event, &baseeventexamplecomv1.Status{})
	if err != nil {
		return err
	}
	obj.Event = result.Event
	return nil
}

func (obj *EventEvent) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", obj.Labels, obj.Labels["configs.config.example.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type eventEventExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *eventEventExampleV1Chainer) Subscribe() {
	key := "events.event.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *eventEventExampleV1Chainer) Unsubscribe() {
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *eventEventExampleV1Chainer) IsSubscribed() bool {
	key := "events.event.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *eventEventExampleV1Chainer) addCallback(obj *EventEvent) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.example.com", parentHashName, "events.event.example.com", obj.Name)
}

func (c *eventEventExampleV1Chainer) deleteCallback(obj *EventEvent) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.example.com", parentHashName, "events.event.example.com", obj.Name)
}

func (c *eventEventExampleV1Chainer) RegisterEventHandler(addCB func(obj *EventEvent), updateCB func(oldObj, newObj *EventEvent), deleteCB func(obj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EventEvent")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EventEvent, so creating a new one")
		informer = informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &EventEvent{
				client: c.client,
				Event:  obj.(*baseeventexamplecomv1.Event),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name) {
				AddChild("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &EventEvent{
				client: c.client,
				Event:  oldObj.(*baseeventexamplecomv1.Event),
			}
			newData := &EventEvent{
				client: c.client,
				Event:  newObj.(*baseeventexamplecomv1.Event),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &EventEvent{
				client: c.client,
				Event:  obj.(*baseeventexamplecomv1.Event),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name) {
				RemoveChild("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *eventEventExampleV1Chainer) RegisterAddCallback(cbfn func(obj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EventEvent")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EventEvent, so creating a new one")
		informer = informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &EventEvent{
				client: c.client,
				Event:  obj.(*baseeventexamplecomv1.Event),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name) {
				AddChild("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *eventEventExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EventEvent")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EventEvent, so creating a new one")
		informer = informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &EventEvent{
				client: c.client,
				Event:  oldObj.(*baseeventexamplecomv1.Event),
			}
			newData := &EventEvent{
				client: c.client,
				Event:  newObj.(*baseeventexamplecomv1.Event),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *eventEventExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EventEvent")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EventEvent, so creating a new one")
		informer = informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &EventEvent{
				client: c.client,
				Event:  obj.(*baseeventexamplecomv1.Event),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name) {
				RemoveChild("configs.config.example.com", parent.Name, "events.event.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

// ClearStatus to clear user defined status
func (c *eventEventExampleV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, c.name)
	obj, err := c.client.Event().GetEventByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Event().SetEventStatusByName(ctx, obj.Event, nil)
	return err
}

// GetStatus to get user defined status
func (c *eventEventExampleV1Chainer) GetStatus(ctx context.Context) (result *baseeventexamplecomv1.Status, err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, c.name)
	obj, err := c.client.Event().GetEventByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *eventEventExampleV1Chainer) SetStatus(ctx context.Context, status *baseeventexamplecomv1.Status) (err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, c.name)
	obj, err := c.client.Event().GetEventByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Event().SetEventStatusByName(ctx, obj.Event, status)
	return err
}

func (group *UserExampleV1) GetUserChildrenMap() map[string]baseuserexamplecomv1.Child {
	return map[string]baseuserexamplecomv1.Child{}
}

func (group *UserExampleV1) GetUserChild(grp, kind, name string) baseuserexamplecomv1.Child {
	return baseuserexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetUserByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) GetUserByName(ctx context.Context, hashedName string) (*UserUser, error) {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetUserByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseuserexamplecomv1.User)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetUserByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseuserexamplecomv1.User).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetUserByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &UserUser{
					client: group.client,
					User:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &UserUser{
				client: group.client,
				User:   resWrCache.(*baseuserexamplecomv1.User),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &UserUser{
				client: group.client,
				User:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetUserByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Users: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetUserByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadUserByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) ForceReadUserByName(ctx context.Context, hashedName string) (*UserUser, error) {
	log.Debugf("[ForceReadUserByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadUserByName] Failed to Get Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Users: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadUserByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadUserByName] Executed Successfully :%s", hashedName)
			return &UserUser{
				client: group.client,
				User:   result,
			}, nil
		}
	}
}

// DeleteUserByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) DeleteUserByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteUserByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseuserexamplecomv1.User
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteUserByName] Failed to get Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Users: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteUserByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("users.user.example.com", hashedName, "wannas.wanna.example.com") {
		err := group.client.Wanna().DeleteWannaByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("users.user.example.com", hashedName, "wannas.wanna.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			UserExampleV1().
			Users().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteUserByName] failed to delete Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Users: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteUserByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteUserByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
	}
	RemoveChild("configs.config.example.com", parentName, "users.user.example.com", hashedName)

	return nil
}

// CreateUserByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *UserExampleV1) CreateUserByName(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (*UserUser, error) {
	log.Debugf("[CreateUserByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.WannaGvk = nil

	var (
		retryCount int
		result     *baseuserexamplecomv1.User
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateUserByName] Failed to create User: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create User: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateUserByName] context canceled while creating User: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateUserByName] User: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.UserExampleV1().Users().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateUserByName] Unable to Get User %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateUserByName] found unexpected error while creating User: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateUserByName] User: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				log.Debugf("[CreateUserByName] User: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.example.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.example.com", parentHashedName, "users.user.example.com", objToCreate.Name)

	log.Debugf("[CreateUserByName] Executed Successfully: %s", objToCreate.GetName())
	return &UserUser{
		client: group.client,
		User:   result,
	}, nil
}

// UpdateUserByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *UserExampleV1) UpdateUserByName(ctx context.Context,
	objToUpdate *baseuserexamplecomv1.User) (*UserUser, error) {
	log.Debugf("[UpdateUserByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.User().GetUserByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["users.user.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Username)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Username).IsNil() {
			patchValueUsername := objToUpdate.Spec.Username
			patchOpUsername := PatchOp{
				Op:    "replace",
				Path:  "/spec/username",
				Value: patchValueUsername,
			}
			patch = append(patch, patchOpUsername)
		}
	} else {
		patchValueUsername := objToUpdate.Spec.Username
		patchOpUsername := PatchOp{
			Op:    "replace",
			Path:  "/spec/username",
			Value: patchValueUsername,
		}
		patch = append(patch, patchOpUsername)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Mail)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Mail).IsNil() {
			patchValueMail := objToUpdate.Spec.Mail
			patchOpMail := PatchOp{
				Op:    "replace",
				Path:  "/spec/email",
				Value: patchValueMail,
			}
			patch = append(patch, patchOpMail)
		}
	} else {
		patchValueMail := objToUpdate.Spec.Mail
		patchOpMail := PatchOp{
			Op:    "replace",
			Path:  "/spec/email",
			Value: patchValueMail,
		}
		patch = append(patch, patchOpMail)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FirstName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FirstName).IsNil() {
			patchValueFirstName := objToUpdate.Spec.FirstName
			patchOpFirstName := PatchOp{
				Op:    "replace",
				Path:  "/spec/firstName",
				Value: patchValueFirstName,
			}
			patch = append(patch, patchOpFirstName)
		}
	} else {
		patchValueFirstName := objToUpdate.Spec.FirstName
		patchOpFirstName := PatchOp{
			Op:    "replace",
			Path:  "/spec/firstName",
			Value: patchValueFirstName,
		}
		patch = append(patch, patchOpFirstName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.LastName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.LastName).IsNil() {
			patchValueLastName := objToUpdate.Spec.LastName
			patchOpLastName := PatchOp{
				Op:    "replace",
				Path:  "/spec/lastName",
				Value: patchValueLastName,
			}
			patch = append(patch, patchOpLastName)
		}
	} else {
		patchValueLastName := objToUpdate.Spec.LastName
		patchOpLastName := PatchOp{
			Op:    "replace",
			Path:  "/spec/lastName",
			Value: patchValueLastName,
		}
		patch = append(patch, patchOpLastName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Password)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Password).IsNil() {
			patchValuePassword := objToUpdate.Spec.Password
			patchOpPassword := PatchOp{
				Op:    "replace",
				Path:  "/spec/password",
				Value: patchValuePassword,
			}
			patch = append(patch, patchOpPassword)
		}
	} else {
		patchValuePassword := objToUpdate.Spec.Password
		patchOpPassword := PatchOp{
			Op:    "replace",
			Path:  "/spec/password",
			Value: patchValuePassword,
		}
		patch = append(patch, patchOpPassword)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Realm)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Realm).IsNil() {
			patchValueRealm := objToUpdate.Spec.Realm
			patchOpRealm := PatchOp{
				Op:    "replace",
				Path:  "/spec/realm",
				Value: patchValueRealm,
			}
			patch = append(patch, patchOpRealm)
		}
	} else {
		patchValueRealm := objToUpdate.Spec.Realm
		patchOpRealm := PatchOp{
			Op:    "replace",
			Path:  "/spec/realm",
			Value: patchValueRealm,
		}
		patch = append(patch, patchOpRealm)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseuserexamplecomv1.User
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateUserByName] Failed to patch User %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger User Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteUserByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting User: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("User deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateUserByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateUserByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger User Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteUserByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting User: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("User Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateUserByName] Patch User Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				log.Debugf("[UpdateUserByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateUserByName] Executed Successfully %s", objToUpdate.GetName())
	return &UserUser{
		client: group.client,
		User:   result,
	}, nil
}

// ListUsers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *UserExampleV1) ListUsers(ctx context.Context,
	opts metav1.ListOptions) (result []*UserUser, err error) {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*UserUser, len(items))
		for k, v := range items {
			item, _ := v.(*baseuserexamplecomv1.User)
			result[k] = &UserUser{
				client: group.client,
				User:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.UserExampleV1().
			Users().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*UserUser, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &UserUser{
				client: group.client,
				User:   &item,
			}
		}
	}
	return
}

type UserUser struct {
	client *Clientset
	*baseuserexamplecomv1.User
}

// Delete removes obj and all it's children from the database.
func (obj *UserUser) Delete(ctx context.Context) error {
	err := obj.client.User().DeleteUserByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.User = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *UserUser) Update(ctx context.Context) error {
	result, err := obj.client.User().UpdateUserByName(ctx, obj.User)
	if err != nil {
		return err
	}
	obj.User = result.User
	return nil
}

func (obj *UserUser) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", obj.Labels, obj.Labels["configs.config.example.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type UserUserWanna struct {
	client *Clientset
	Wanna  []baseuserexamplecomv1.Child
}

func (n *UserUserWanna) Next(ctx context.Context) (*WannaWanna, error) {
	for index, child := range n.Wanna {
		obj, err := n.client.Wanna().GetWannaByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Wanna)-1 {
				n.Wanna = nil
			} else {
				n.Wanna = n.Wanna[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllWannaIter returns an iterator for all children of given type
func (obj *UserUser) GetAllWannaIter(ctx context.Context) (
	result UserUserWanna) {
	result.client = obj.client
	for _, v := range GetChildren("users.user.example.com", obj.Name, "wannas.wanna.example.com") {
		result.Wanna = append(result.Wanna, baseuserexamplecomv1.Child{
			Group: "wanna.example.com",
			Kind:  "Wanna",
			Name:  v,
		})
	}
	return
}

// GetAllWanna returns all children of a given type
func (obj *UserUser) GetAllWanna(ctx context.Context) (
	result []*WannaWanna, err error) {
	for _, v := range GetChildren("users.user.example.com", obj.Name, "wannas.wanna.example.com") {
		l, err := obj.client.Wanna().GetWannaByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetWanna returns child which has given displayName
func (obj *UserUser) GetWanna(ctx context.Context,
	displayName string) (result *WannaWanna, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["users.user.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("wannas.wanna.example.com", parentLabels, displayName)
	if IsChildExists("users.user.example.com", obj.Name, "wannas.wanna.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "User.User", "Wanna", displayName)
	}

	result, err = obj.client.Wanna().GetWannaByName(ctx, childHashName)
	return
}

// AddWanna calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *UserUser) AddWanna(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (result *WannaWanna, err error) {
	log.Debugf("[AddWanna] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["users.user.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["users.user.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Wanna().CreateWannaByName(ctx, objToCreate)
	log.Debugf("[AddWanna] Wanna created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.User().GetUserByName(ctx, obj.GetName())
	if getErr == nil {
		obj.User = updatedObj.User
	}
	log.Debugf("[AddWanna] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteWanna calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *UserUser) DeleteWanna(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteWanna] Received for Wanna object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["users.user.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("wannas.wanna.example.com", parentLabels, displayName)
	if IsChildExists("users.user.example.com", obj.Name, "wannas.wanna.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "User.User", "Wanna", displayName)
	}

	err = obj.client.Wanna().DeleteWannaByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteWanna] Wanna object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.User().GetUserByName(ctx, obj.GetName())
	if err == nil {
		obj.User = updatedObj.User
	}
	return
}

type userUserExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userUserExampleV1Chainer) Subscribe() {
	key := "users.user.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *userUserExampleV1Chainer) Unsubscribe() {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userUserExampleV1Chainer) IsSubscribed() bool {
	key := "users.user.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *userUserExampleV1Chainer) addCallback(obj *UserUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.example.com", parentHashName, "users.user.example.com", obj.Name)
}

func (c *userUserExampleV1Chainer) deleteCallback(obj *UserUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.example.com", parentHashName, "users.user.example.com", obj.Name)
}

func (c *userUserExampleV1Chainer) RegisterEventHandler(addCB func(obj *UserUser), updateCB func(oldObj, newObj *UserUser), deleteCB func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for UserUser")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for UserUser, so creating a new one")
		informer = informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name) {
				AddChild("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &UserUser{
				client: c.client,
				User:   oldObj.(*baseuserexamplecomv1.User),
			}
			newData := &UserUser{
				client: c.client,
				User:   newObj.(*baseuserexamplecomv1.User),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name) {
				RemoveChild("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterAddCallback(cbfn func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for UserUser")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for UserUser, so creating a new one")
		informer = informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name) {
				AddChild("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for UserUser")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for UserUser, so creating a new one")
		informer = informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &UserUser{
				client: c.client,
				User:   oldObj.(*baseuserexamplecomv1.User),
			}
			newData := &UserUser{
				client: c.client,
				User:   newObj.(*baseuserexamplecomv1.User),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for UserUser")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for UserUser, so creating a new one")
		informer = informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name) {
				RemoveChild("configs.config.example.com", parent.Name, "users.user.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *userUserExampleV1Chainer) Wanna(name string) *wannaWannaExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["wannas.wanna.example.com"] = name
	return &wannaWannaExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetWanna calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *userUserExampleV1Chainer) GetWanna(ctx context.Context, displayName string) (result *WannaWanna, err error) {
	hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, displayName)
	return c.client.Wanna().GetWannaByName(ctx, hashedName)
}

// AddWanna calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *userUserExampleV1Chainer) AddWanna(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (result *WannaWanna, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Wanna().CreateWannaByName(ctx, objToCreate)
}

// DeleteWanna calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *userUserExampleV1Chainer) DeleteWanna(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, name)
	return c.client.Wanna().DeleteWannaByName(ctx, hashedName)
}

func (group *WannaExampleV1) GetWannaChildrenMap() map[string]basewannaexamplecomv1.Child {
	return map[string]basewannaexamplecomv1.Child{}
}

func (group *WannaExampleV1) GetWannaChild(grp, kind, name string) basewannaexamplecomv1.Child {
	return basewannaexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetWannaByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) GetWannaByName(ctx context.Context, hashedName string) (*WannaWanna, error) {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetWannaByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basewannaexamplecomv1.Wanna)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetWannaByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basewannaexamplecomv1.Wanna).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetWannaByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &WannaWanna{
					client: group.client,
					Wanna:  resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &WannaWanna{
				client: group.client,
				Wanna:  resWrCache.(*basewannaexamplecomv1.Wanna),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &WannaWanna{
				client: group.client,
				Wanna:  result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetWannaByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Wannas: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetWannaByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetWannaByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadWannaByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) ForceReadWannaByName(ctx context.Context, hashedName string) (*WannaWanna, error) {
	log.Debugf("[ForceReadWannaByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadWannaByName] Failed to Get Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Wannas: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadWannaByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadWannaByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadWannaByName] Executed Successfully :%s", hashedName)
			return &WannaWanna{
				client: group.client,
				Wanna:  result,
			}, nil
		}
	}
}

// DeleteWannaByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) DeleteWannaByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteWannaByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basewannaexamplecomv1.Wanna
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteWannaByName] Failed to get Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Wannas: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteWannaByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteWannaByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteWannaByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteWannaByName] failed to delete Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Wannas: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteWannaByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteWannaByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteWannaByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteWannaByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["users.user.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("users.user.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("users.user.example.com", parents, parentName)
	}
	RemoveChild("users.user.example.com", parentName, "wannas.wanna.example.com", hashedName)

	return nil
}

// CreateWannaByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *WannaExampleV1) CreateWannaByName(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (*WannaWanna, error) {
	log.Debugf("[CreateWannaByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.InterestGvk = nil

	var (
		retryCount int
		result     *basewannaexamplecomv1.Wanna
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateWannaByName] Failed to create Wanna: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Wanna: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateWannaByName] context canceled while creating Wanna: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateWannaByName] Wanna: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.WannaExampleV1().Wannas().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateWannaByName] Unable to Get Wanna %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateWannaByName] found unexpected error while creating Wanna: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateWannaByName] Wanna: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				log.Debugf("[CreateWannaByName] Wanna: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["users.user.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("users.user.example.com", objToCreate.GetLabels(), parentName)

	AddChild("users.user.example.com", parentHashedName, "wannas.wanna.example.com", objToCreate.Name)

	log.Debugf("[CreateWannaByName] Executed Successfully: %s", objToCreate.GetName())
	return &WannaWanna{
		client: group.client,
		Wanna:  result,
	}, nil
}

// UpdateWannaByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *WannaExampleV1) UpdateWannaByName(ctx context.Context,
	objToUpdate *basewannaexamplecomv1.Wanna) (*WannaWanna, error) {
	log.Debugf("[UpdateWannaByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Wanna().GetWannaByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["wannas.wanna.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basewannaexamplecomv1.Wanna
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateWannaByName] Failed to patch Wanna %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Wanna Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteWannaByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Wanna: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Wanna deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateWannaByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateWannaByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Wanna Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteWannaByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Wanna: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Wanna Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateWannaByName] Patch Wanna Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				log.Debugf("[UpdateWannaByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateWannaByName] Executed Successfully %s", objToUpdate.GetName())
	return &WannaWanna{
		client: group.client,
		Wanna:  result,
	}, nil
}

// ListWannas returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *WannaExampleV1) ListWannas(ctx context.Context,
	opts metav1.ListOptions) (result []*WannaWanna, err error) {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*WannaWanna, len(items))
		for k, v := range items {
			item, _ := v.(*basewannaexamplecomv1.Wanna)
			result[k] = &WannaWanna{
				client: group.client,
				Wanna:  item,
			}
		}
	} else {
		list, err := group.client.baseClient.WannaExampleV1().
			Wannas().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*WannaWanna, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &WannaWanna{
				client: group.client,
				Wanna:  &item,
			}
		}
	}
	return
}

type WannaWanna struct {
	client *Clientset
	*basewannaexamplecomv1.Wanna
}

// Delete removes obj and all it's children from the database.
func (obj *WannaWanna) Delete(ctx context.Context) error {
	err := obj.client.Wanna().DeleteWannaByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Wanna = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *WannaWanna) Update(ctx context.Context) error {
	result, err := obj.client.Wanna().UpdateWannaByName(ctx, obj.Wanna)
	if err != nil {
		return err
	}
	obj.Wanna = result.Wanna
	return nil
}

func (obj *WannaWanna) GetParent(ctx context.Context) (result *UserUser, err error) {
	hashedName := helper.GetHashedName("users.user.example.com", obj.Labels, obj.Labels["users.user.example.com"])
	return obj.client.User().GetUserByName(ctx, hashedName)
}

// GetInterest returns link of given type
func (obj *WannaWanna) GetInterest(ctx context.Context) (
	result *InterestInterest, err error) {
	if obj.Spec.InterestGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Wanna.Wanna", "Interest")
	}
	return obj.client.Interest().GetInterestByName(ctx, obj.Spec.InterestGvk.Name)
}

// LinkInterest links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *WannaWanna) LinkInterest(ctx context.Context,
	linkToAdd *InterestInterest) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/interestGvk",
		Value: basewannaexamplecomv1.Child{
			Group: "interest.example.com",
			Kind:  "Interest",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.WannaExampleV1().Wannas().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Wanna = result
	return nil
}

// UnlinkInterest unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *WannaWanna) UnlinkInterest(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/interestGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.WannaExampleV1().Wannas().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Wanna = result
	return nil

}

type wannaWannaExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *wannaWannaExampleV1Chainer) Subscribe() {
	key := "wannas.wanna.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *wannaWannaExampleV1Chainer) Unsubscribe() {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *wannaWannaExampleV1Chainer) IsSubscribed() bool {
	key := "wannas.wanna.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *wannaWannaExampleV1Chainer) addCallback(obj *WannaWanna) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["users.user.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("users.user.example.com", obj.Labels, parentDisplayName)

	AddChild("users.user.example.com", parentHashName, "wannas.wanna.example.com", obj.Name)
}

func (c *wannaWannaExampleV1Chainer) deleteCallback(obj *WannaWanna) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["users.user.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("users.user.example.com", obj.Labels, parentDisplayName)

	RemoveChild("users.user.example.com", parentHashName, "wannas.wanna.example.com", obj.Name)
}

func (c *wannaWannaExampleV1Chainer) RegisterEventHandler(addCB func(obj *WannaWanna), updateCB func(oldObj, newObj *WannaWanna), deleteCB func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for WannaWanna")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for WannaWanna, so creating a new one")
		informer = informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name) {
				AddChild("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &WannaWanna{
				client: c.client,
				Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
			}
			newData := &WannaWanna{
				client: c.client,
				Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name) {
				RemoveChild("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterAddCallback(cbfn func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for WannaWanna")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for WannaWanna, so creating a new one")
		informer = informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name) {
				AddChild("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for WannaWanna")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for WannaWanna, so creating a new one")
		informer = informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &WannaWanna{
				client: c.client,
				Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
			}
			newData := &WannaWanna{
				client: c.client,
				Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for WannaWanna")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for WannaWanna, so creating a new one")
		informer = informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name) {
				RemoveChild("users.user.example.com", parent.Name, "wannas.wanna.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (group *InterestExampleV1) GetInterestChildrenMap() map[string]baseinterestexamplecomv1.Child {
	return map[string]baseinterestexamplecomv1.Child{}
}

func (group *InterestExampleV1) GetInterestChild(grp, kind, name string) baseinterestexamplecomv1.Child {
	return baseinterestexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetInterestByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) GetInterestByName(ctx context.Context, hashedName string) (*InterestInterest, error) {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetInterestByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseinterestexamplecomv1.Interest)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetInterestByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseinterestexamplecomv1.Interest).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetInterestByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &InterestInterest{
					client:   group.client,
					Interest: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &InterestInterest{
				client:   group.client,
				Interest: resWrCache.(*baseinterestexamplecomv1.Interest),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &InterestInterest{
				client:   group.client,
				Interest: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetInterestByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Interests: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetInterestByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetInterestByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadInterestByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) ForceReadInterestByName(ctx context.Context, hashedName string) (*InterestInterest, error) {
	log.Debugf("[ForceReadInterestByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadInterestByName] Failed to Get Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Interests: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadInterestByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadInterestByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadInterestByName] Executed Successfully :%s", hashedName)
			return &InterestInterest{
				client:   group.client,
				Interest: result,
			}, nil
		}
	}
}

// DeleteInterestByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) DeleteInterestByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteInterestByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseinterestexamplecomv1.Interest
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteInterestByName] Failed to get Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Interests: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteInterestByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteInterestByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteInterestByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			InterestExampleV1().
			Interests().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteInterestByName] failed to delete Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Interests: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteInterestByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteInterestByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteInterestByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteInterestByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
	}
	RemoveChild("tenants.tenant.example.com", parentName, "interests.interest.example.com", hashedName)

	return nil
}

// CreateInterestByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *InterestExampleV1) CreateInterestByName(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (*InterestInterest, error) {
	log.Debugf("[CreateInterestByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseinterestexamplecomv1.Interest
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateInterestByName] Failed to create Interest: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Interest: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateInterestByName] context canceled while creating Interest: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateInterestByName] Interest: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.InterestExampleV1().Interests().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateInterestByName] Unable to Get Interest %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateInterestByName] found unexpected error while creating Interest: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateInterestByName] Interest: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				log.Debugf("[CreateInterestByName] Interest: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("tenants.tenant.example.com", objToCreate.GetLabels(), parentName)

	AddChild("tenants.tenant.example.com", parentHashedName, "interests.interest.example.com", objToCreate.Name)

	log.Debugf("[CreateInterestByName] Executed Successfully: %s", objToCreate.GetName())
	return &InterestInterest{
		client:   group.client,
		Interest: result,
	}, nil
}

// UpdateInterestByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *InterestExampleV1) UpdateInterestByName(ctx context.Context,
	objToUpdate *baseinterestexamplecomv1.Interest) (*InterestInterest, error) {
	log.Debugf("[UpdateInterestByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Interest().GetInterestByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["interests.interest.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseinterestexamplecomv1.Interest
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateInterestByName] Failed to patch Interest %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Interest Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteInterestByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Interest: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Interest deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateInterestByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateInterestByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Interest Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteInterestByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Interest: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Interest Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateInterestByName] Patch Interest Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				log.Debugf("[UpdateInterestByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateInterestByName] Executed Successfully %s", objToUpdate.GetName())
	return &InterestInterest{
		client:   group.client,
		Interest: result,
	}, nil
}

// ListInterests returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *InterestExampleV1) ListInterests(ctx context.Context,
	opts metav1.ListOptions) (result []*InterestInterest, err error) {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*InterestInterest, len(items))
		for k, v := range items {
			item, _ := v.(*baseinterestexamplecomv1.Interest)
			result[k] = &InterestInterest{
				client:   group.client,
				Interest: item,
			}
		}
	} else {
		list, err := group.client.baseClient.InterestExampleV1().
			Interests().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*InterestInterest, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &InterestInterest{
				client:   group.client,
				Interest: &item,
			}
		}
	}
	return
}

type InterestInterest struct {
	client *Clientset
	*baseinterestexamplecomv1.Interest
}

// Delete removes obj and all it's children from the database.
func (obj *InterestInterest) Delete(ctx context.Context) error {
	err := obj.client.Interest().DeleteInterestByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Interest = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *InterestInterest) Update(ctx context.Context) error {
	result, err := obj.client.Interest().UpdateInterestByName(ctx, obj.Interest)
	if err != nil {
		return err
	}
	obj.Interest = result.Interest
	return nil
}

func (obj *InterestInterest) GetParent(ctx context.Context) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, obj.Labels["tenants.tenant.example.com"])
	return obj.client.Tenant().GetTenantByName(ctx, hashedName)
}

type interestInterestExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *interestInterestExampleV1Chainer) Subscribe() {
	key := "interests.interest.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *interestInterestExampleV1Chainer) Unsubscribe() {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *interestInterestExampleV1Chainer) IsSubscribed() bool {
	key := "interests.interest.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *interestInterestExampleV1Chainer) addCallback(obj *InterestInterest) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	AddChild("tenants.tenant.example.com", parentHashName, "interests.interest.example.com", obj.Name)
}

func (c *interestInterestExampleV1Chainer) deleteCallback(obj *InterestInterest) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	RemoveChild("tenants.tenant.example.com", parentHashName, "interests.interest.example.com", obj.Name)
}

func (c *interestInterestExampleV1Chainer) RegisterEventHandler(addCB func(obj *InterestInterest), updateCB func(oldObj, newObj *InterestInterest), deleteCB func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for InterestInterest")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for InterestInterest, so creating a new one")
		informer = informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if !IsChildExists("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name) {
				AddChild("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name)
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &InterestInterest{
				client:   c.client,
				Interest: oldObj.(*baseinterestexamplecomv1.Interest),
			}
			newData := &InterestInterest{
				client:   c.client,
				Interest: newObj.(*baseinterestexamplecomv1.Interest),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if IsChildExists("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name) {
				RemoveChild("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name)
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterAddCallback(cbfn func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for InterestInterest")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for InterestInterest, so creating a new one")
		informer = informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			if !IsChildExists("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name) {
				AddChild("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for InterestInterest")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for InterestInterest, so creating a new one")
		informer = informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &InterestInterest{
				client:   c.client,
				Interest: oldObj.(*baseinterestexamplecomv1.Interest),
			}
			newData := &InterestInterest{
				client:   c.client,
				Interest: newObj.(*baseinterestexamplecomv1.Interest),
			}
			cbfn(oldData, newData)
		},
	})

	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)

	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for InterestInterest")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for InterestInterest, so creating a new one")
		informer = informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}

	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		DeleteFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}

			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}

					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}
			if IsChildExists("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name) {
				RemoveChild("tenants.tenant.example.com", parent.Name, "interests.interest.example.com", nc.Name)
			}

			cbfn(nc)
		},
	})

	return registrationId, err
}
