// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	customerrors "errors"
	"fmt"
	"os"
	"reflect"
	"strconv"
	"strings"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
	"k8s.io/apimachinery/pkg/runtime/schema"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "example/build/client/clientset/versioned"
	fakeBaseClienset "example/build/client/clientset/versioned/fake"
	"example/build/common"
	"example/build/helper"

	baseconfigexamplecomv1 "example/build/apis/config.example.com/v1"
	baseevaluationexamplecomv1 "example/build/apis/evaluation.example.com/v1"
	baseeventexamplecomv1 "example/build/apis/event.example.com/v1"
	baseinterestexamplecomv1 "example/build/apis/interest.example.com/v1"
	basequizexamplecomv1 "example/build/apis/quiz.example.com/v1"
	basequizchoiceexamplecomv1 "example/build/apis/quizchoice.example.com/v1"
	basequizquestionexamplecomv1 "example/build/apis/quizquestion.example.com/v1"
	baserootexamplecomv1 "example/build/apis/root.example.com/v1"
	baseruntimeexamplecomv1 "example/build/apis/runtime.example.com/v1"
	baseruntimeanswerexamplecomv1 "example/build/apis/runtimeanswer.example.com/v1"
	baseruntimeevaluationexamplecomv1 "example/build/apis/runtimeevaluation.example.com/v1"
	baseruntimequizexamplecomv1 "example/build/apis/runtimequiz.example.com/v1"
	baseruntimeuserexamplecomv1 "example/build/apis/runtimeuser.example.com/v1"
	basetenantexamplecomv1 "example/build/apis/tenant.example.com/v1"
	baseuserexamplecomv1 "example/build/apis/user.example.com/v1"
	basewannaexamplecomv1 "example/build/apis/wanna.example.com/v1"

	informerconfigexamplecomv1 "example/build/client/informers/externalversions/config.example.com/v1"
	informerevaluationexamplecomv1 "example/build/client/informers/externalversions/evaluation.example.com/v1"
	informereventexamplecomv1 "example/build/client/informers/externalversions/event.example.com/v1"
	informerinterestexamplecomv1 "example/build/client/informers/externalversions/interest.example.com/v1"
	informerquizexamplecomv1 "example/build/client/informers/externalversions/quiz.example.com/v1"
	informerquizchoiceexamplecomv1 "example/build/client/informers/externalversions/quizchoice.example.com/v1"
	informerquizquestionexamplecomv1 "example/build/client/informers/externalversions/quizquestion.example.com/v1"
	informerrootexamplecomv1 "example/build/client/informers/externalversions/root.example.com/v1"
	informerruntimeexamplecomv1 "example/build/client/informers/externalversions/runtime.example.com/v1"
	informerruntimeanswerexamplecomv1 "example/build/client/informers/externalversions/runtimeanswer.example.com/v1"
	informerruntimeevaluationexamplecomv1 "example/build/client/informers/externalversions/runtimeevaluation.example.com/v1"
	informerruntimequizexamplecomv1 "example/build/client/informers/externalversions/runtimequiz.example.com/v1"
	informerruntimeuserexamplecomv1 "example/build/client/informers/externalversions/runtimeuser.example.com/v1"
	informertenantexamplecomv1 "example/build/client/informers/externalversions/tenant.example.com/v1"
	informeruserexamplecomv1 "example/build/client/informers/externalversions/user.example.com/v1"
	informerwannaexamplecomv1 "example/build/client/informers/externalversions/wanna.example.com/v1"
)

var log = logrus.New()

const maxRetryCount = 60
const sleepTime = 5
const maxRetryCount1SecSleep = 300

const ownershipAnnotation string = "Ownership"

// informerResyncPeriod is in second, default value is 10 Hrs(36000 Sec). INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
var informerResyncPeriod time.Duration = 36000

type Clientset struct {
	baseClient                 baseClientset.Interface
	dynamicClient              *dynamic.DynamicClient
	rootExampleV1              *RootExampleV1
	evaluationExampleV1        *EvaluationExampleV1
	quizExampleV1              *QuizExampleV1
	quizquestionExampleV1      *QuizquestionExampleV1
	quizchoiceExampleV1        *QuizchoiceExampleV1
	tenantExampleV1            *TenantExampleV1
	configExampleV1            *ConfigExampleV1
	eventExampleV1             *EventExampleV1
	userExampleV1              *UserExampleV1
	wannaExampleV1             *WannaExampleV1
	interestExampleV1          *InterestExampleV1
	runtimeExampleV1           *RuntimeExampleV1
	runtimeuserExampleV1       *RuntimeuserExampleV1
	runtimeevaluationExampleV1 *RuntimeevaluationExampleV1
	runtimequizExampleV1       *RuntimequizExampleV1
	runtimeanswerExampleV1     *RuntimeanswerExampleV1
}

type subscription struct {
	informer          cache.SharedIndexInformer
	stop              chan struct{}
	WriteCacheObjects *sync.Map
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer:          informer,
		stop:              make(chan struct{}),
		WriteCacheObjects: &sync.Map{},
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "roots.root.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootexamplecomv1.NewRootInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "evaluations.evaluation.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerevaluationexamplecomv1.NewEvaluationInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "quizes.quiz.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizexamplecomv1.NewQuizInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "quizquestions.quizquestion.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "quizchoices.quizchoice.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "tenants.tenant.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenantexamplecomv1.NewTenantInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "configs.config.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigexamplecomv1.NewConfigInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "events.event.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informereventexamplecomv1.NewEventInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "users.user.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informeruserexamplecomv1.NewUserInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "wannas.wanna.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerwannaexamplecomv1.NewWannaInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "interests.interest.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerinterestexamplecomv1.NewInterestInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "runtimes.runtime.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeexamplecomv1.NewRuntimeInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "runtimeusers.runtimeuser.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeuserexamplecomv1.NewRuntimeUserInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "runtimeevaluations.runtimeevaluation.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeevaluationexamplecomv1.NewRuntimeEvaluationInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "runtimequizes.runtimequiz.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimequizexamplecomv1.NewRuntimeQuizInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "runtimeanswers.runtimeanswer.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeanswerexamplecomv1.NewRuntimeAnswerInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	customFormatter := new(logrus.TextFormatter)
	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
	log.SetFormatter(customFormatter)
	customFormatter.FullTimestamp = true
	if os.Getenv("NEXUS_LOG_LEVEL") == "debug" {
		log.SetLevel(logrus.DebugLevel)
		log.Debug("Nexus debug log enabled")
	}

	// INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
	stringResyncPeriod := os.Getenv("INFORMER_RESYNC_PERIOD")
	if stringResyncPeriod != "" {
		intResyncPeriod, err := strconv.Atoi(stringResyncPeriod)
		if err != nil {
			log.Errorf("env INFORMER_RESYNC_PERIOD is not set with correct value")
		} else {
			informerResyncPeriod = time.Duration(intResyncPeriod)
			log.Debugf("Resync Period for informers is set to %+v second", informerResyncPeriod)
		}
	}

	client := &Clientset{}
	client.baseClient = baseClient
	client.dynamicClient, _ = dynamic.NewForConfig(config) // TBD: check and react for error
	client.rootExampleV1 = newRootExampleV1(client)
	client.evaluationExampleV1 = newEvaluationExampleV1(client)
	client.quizExampleV1 = newQuizExampleV1(client)
	client.quizquestionExampleV1 = newQuizquestionExampleV1(client)
	client.quizchoiceExampleV1 = newQuizchoiceExampleV1(client)
	client.tenantExampleV1 = newTenantExampleV1(client)
	client.configExampleV1 = newConfigExampleV1(client)
	client.eventExampleV1 = newEventExampleV1(client)
	client.userExampleV1 = newUserExampleV1(client)
	client.wannaExampleV1 = newWannaExampleV1(client)
	client.interestExampleV1 = newInterestExampleV1(client)
	client.runtimeExampleV1 = newRuntimeExampleV1(client)
	client.runtimeuserExampleV1 = newRuntimeuserExampleV1(client)
	client.runtimeevaluationExampleV1 = newRuntimeevaluationExampleV1(client)
	client.runtimequizExampleV1 = newRuntimequizExampleV1(client)
	client.runtimeanswerExampleV1 = newRuntimeanswerExampleV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.rootExampleV1 = newRootExampleV1(client)
	client.evaluationExampleV1 = newEvaluationExampleV1(client)
	client.quizExampleV1 = newQuizExampleV1(client)
	client.quizquestionExampleV1 = newQuizquestionExampleV1(client)
	client.quizchoiceExampleV1 = newQuizchoiceExampleV1(client)
	client.tenantExampleV1 = newTenantExampleV1(client)
	client.configExampleV1 = newConfigExampleV1(client)
	client.eventExampleV1 = newEventExampleV1(client)
	client.userExampleV1 = newUserExampleV1(client)
	client.wannaExampleV1 = newWannaExampleV1(client)
	client.interestExampleV1 = newInterestExampleV1(client)
	client.runtimeExampleV1 = newRuntimeExampleV1(client)
	client.runtimeuserExampleV1 = newRuntimeuserExampleV1(client)
	client.runtimeevaluationExampleV1 = newRuntimeevaluationExampleV1(client)
	client.runtimequizExampleV1 = newRuntimequizExampleV1(client)
	client.runtimeanswerExampleV1 = newRuntimeanswerExampleV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootExampleV1 {
	return c.rootExampleV1
}
func (c *Clientset) Evaluation() *EvaluationExampleV1 {
	return c.evaluationExampleV1
}
func (c *Clientset) Quiz() *QuizExampleV1 {
	return c.quizExampleV1
}
func (c *Clientset) Quizquestion() *QuizquestionExampleV1 {
	return c.quizquestionExampleV1
}
func (c *Clientset) Quizchoice() *QuizchoiceExampleV1 {
	return c.quizchoiceExampleV1
}
func (c *Clientset) Tenant() *TenantExampleV1 {
	return c.tenantExampleV1
}
func (c *Clientset) Config() *ConfigExampleV1 {
	return c.configExampleV1
}
func (c *Clientset) Event() *EventExampleV1 {
	return c.eventExampleV1
}
func (c *Clientset) User() *UserExampleV1 {
	return c.userExampleV1
}
func (c *Clientset) Wanna() *WannaExampleV1 {
	return c.wannaExampleV1
}
func (c *Clientset) Interest() *InterestExampleV1 {
	return c.interestExampleV1
}
func (c *Clientset) Runtime() *RuntimeExampleV1 {
	return c.runtimeExampleV1
}
func (c *Clientset) Runtimeuser() *RuntimeuserExampleV1 {
	return c.runtimeuserExampleV1
}
func (c *Clientset) Runtimeevaluation() *RuntimeevaluationExampleV1 {
	return c.runtimeevaluationExampleV1
}
func (c *Clientset) Runtimequiz() *RuntimequizExampleV1 {
	return c.runtimequizExampleV1
}
func (c *Clientset) Runtimeanswer() *RuntimeanswerExampleV1 {
	return c.runtimeanswerExampleV1
}

type RootExampleV1 struct {
	client *Clientset
}

func newRootExampleV1(client *Clientset) *RootExampleV1 {
	return &RootExampleV1{
		client: client,
	}
}

type EvaluationExampleV1 struct {
	client *Clientset
}

func newEvaluationExampleV1(client *Clientset) *EvaluationExampleV1 {
	return &EvaluationExampleV1{
		client: client,
	}
}

type QuizExampleV1 struct {
	client *Clientset
}

func newQuizExampleV1(client *Clientset) *QuizExampleV1 {
	return &QuizExampleV1{
		client: client,
	}
}

type QuizquestionExampleV1 struct {
	client *Clientset
}

func newQuizquestionExampleV1(client *Clientset) *QuizquestionExampleV1 {
	return &QuizquestionExampleV1{
		client: client,
	}
}

type QuizchoiceExampleV1 struct {
	client *Clientset
}

func newQuizchoiceExampleV1(client *Clientset) *QuizchoiceExampleV1 {
	return &QuizchoiceExampleV1{
		client: client,
	}
}

type TenantExampleV1 struct {
	client *Clientset
}

func newTenantExampleV1(client *Clientset) *TenantExampleV1 {
	return &TenantExampleV1{
		client: client,
	}
}

type ConfigExampleV1 struct {
	client *Clientset
}

func newConfigExampleV1(client *Clientset) *ConfigExampleV1 {
	return &ConfigExampleV1{
		client: client,
	}
}

type EventExampleV1 struct {
	client *Clientset
}

func newEventExampleV1(client *Clientset) *EventExampleV1 {
	return &EventExampleV1{
		client: client,
	}
}

type UserExampleV1 struct {
	client *Clientset
}

func newUserExampleV1(client *Clientset) *UserExampleV1 {
	return &UserExampleV1{
		client: client,
	}
}

type WannaExampleV1 struct {
	client *Clientset
}

func newWannaExampleV1(client *Clientset) *WannaExampleV1 {
	return &WannaExampleV1{
		client: client,
	}
}

type InterestExampleV1 struct {
	client *Clientset
}

func newInterestExampleV1(client *Clientset) *InterestExampleV1 {
	return &InterestExampleV1{
		client: client,
	}
}

type RuntimeExampleV1 struct {
	client *Clientset
}

func newRuntimeExampleV1(client *Clientset) *RuntimeExampleV1 {
	return &RuntimeExampleV1{
		client: client,
	}
}

type RuntimeuserExampleV1 struct {
	client *Clientset
}

func newRuntimeuserExampleV1(client *Clientset) *RuntimeuserExampleV1 {
	return &RuntimeuserExampleV1{
		client: client,
	}
}

type RuntimeevaluationExampleV1 struct {
	client *Clientset
}

func newRuntimeevaluationExampleV1(client *Clientset) *RuntimeevaluationExampleV1 {
	return &RuntimeevaluationExampleV1{
		client: client,
	}
}

type RuntimequizExampleV1 struct {
	client *Clientset
}

func newRuntimequizExampleV1(client *Clientset) *RuntimequizExampleV1 {
	return &RuntimequizExampleV1{
		client: client,
	}
}

type RuntimeanswerExampleV1 struct {
	client *Clientset
}

func newRuntimeanswerExampleV1(client *Clientset) *RuntimeanswerExampleV1 {
	return &RuntimeanswerExampleV1{
		client: client,
	}
}

func (group *RootExampleV1) GetRootChildrenMap() map[string]baserootexamplecomv1.Child {
	return map[string]baserootexamplecomv1.Child{}
}

func (group *RootExampleV1) GetRootChild(grp, kind, name string) baserootexamplecomv1.Child {
	return baserootexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) GetRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRootByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baserootexamplecomv1.Root)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRootByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baserootexamplecomv1.Root).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRootByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootRoot{
					client: group.client,
					Root:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootRoot{
				client: group.client,
				Root:   resWrCache.(*baserootexamplecomv1.Root),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRootByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRootByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) ForceReadRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	log.Debugf("[ForceReadRootByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRootByName] Failed to Get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRootByName] Executed Successfully :%s", hashedName)
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		}
	}
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRootByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baserootexamplecomv1.Root
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] Failed to get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("roots.root.example.com", hashedName, "tenants.tenant.example.com") {
		err := group.client.Tenant().DeleteTenantByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("roots.root.example.com", hashedName, "tenants.tenant.example.com", child)
	}

	for _, child := range GetChildren("roots.root.example.com", hashedName, "evaluations.evaluation.example.com") {
		err := group.client.Evaluation().DeleteEvaluationByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("roots.root.example.com", hashedName, "evaluations.evaluation.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootExampleV1().
			Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] failed to delete Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	return nil
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootExampleV1) CreateRootByName(ctx context.Context,
	objToCreate *baserootexamplecomv1.Root) (*RootRoot, error) {
	log.Debugf("[CreateRootByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.TenantGvk = nil
	objToCreate.Spec.EvaluationGvk = nil

	var (
		retryCount int
		result     *baserootexamplecomv1.Root
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRootByName] Failed to create Root: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Root: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRootByName] context canceled while creating Root: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateRootByName] found unexpected error while creating Root: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRootByName] Root: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				log.Debugf("[CreateRootByName] Root: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	log.Debugf("[CreateRootByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootExampleV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baserootexamplecomv1.Root) (*RootRoot, error) {
	log.Debugf("[UpdateRootByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetRootByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["roots.root.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baserootexamplecomv1.Root
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRootByName] Failed to patch Root %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Root: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Root deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRootByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRootByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Root: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Root Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRootByName] Patch Root Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				log.Debugf("[UpdateRootByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRootByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootExampleV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*RootRoot, err error) {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootRoot, len(items))
		for k, v := range items {
			item, _ := v.(*baserootexamplecomv1.Root)
			result[k] = &RootRoot{
				client: group.client,
				Root:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootExampleV1().
			Roots().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootRoot, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootRoot{
				client: group.client,
				Root:   &item,
			}
		}
	}
	return
}

type RootRoot struct {
	client *Clientset
	*baserootexamplecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *RootRoot) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootRoot) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetRootRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetRootRoot(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", nil, helper.DEFAULT_KEY)
	return c.Root().GetRootByName(ctx, hashedName)
}

func (c *Clientset) RootRoot() *rootRootExampleV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.root.example.com"] = helper.DEFAULT_KEY
	return &rootRootExampleV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddRootRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootRoot(ctx context.Context,
	objToCreate *baserootexamplecomv1.Root) (result *RootRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateRootByName(ctx, objToCreate)
}

// DeleteRootRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteRootRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", nil, helper.DEFAULT_KEY)
	return c.Root().DeleteRootByName(ctx, hashedName)
}

type RootRootTenant struct {
	client *Clientset
	Tenant []baserootexamplecomv1.Child
}

func (n *RootRootTenant) Next(ctx context.Context) (*TenantTenant, error) {
	for index, child := range n.Tenant {
		obj, err := n.client.Tenant().GetTenantByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Tenant)-1 {
				n.Tenant = nil
			} else {
				n.Tenant = n.Tenant[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllTenantIter returns an iterator for all children of given type
func (obj *RootRoot) GetAllTenantIter(ctx context.Context) (
	result RootRootTenant) {
	result.client = obj.client
	for _, v := range GetChildren("roots.root.example.com", obj.Name, "tenants.tenant.example.com") {
		result.Tenant = append(result.Tenant, baserootexamplecomv1.Child{
			Group: "tenant.example.com",
			Kind:  "Tenant",
			Name:  v,
		})
	}
	return
}

// GetAllTenant returns all children of a given type
func (obj *RootRoot) GetAllTenant(ctx context.Context) (
	result []*TenantTenant, err error) {
	for _, v := range GetChildren("roots.root.example.com", obj.Name, "tenants.tenant.example.com") {
		l, err := obj.client.Tenant().GetTenantByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTenant returns child which has given displayName
func (obj *RootRoot) GetTenant(ctx context.Context,
	displayName string) (result *TenantTenant, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["roots.root.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("tenants.tenant.example.com", parentLabels, displayName)
	if IsChildExists("roots.root.example.com", obj.Name, "tenants.tenant.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Tenant", displayName)
	}

	result, err = obj.client.Tenant().GetTenantByName(ctx, childHashName)
	return
}

// AddTenant calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddTenant(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (result *TenantTenant, err error) {
	log.Debugf("[AddTenant] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Tenant().CreateTenantByName(ctx, objToCreate)
	log.Debugf("[AddTenant] Tenant created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	log.Debugf("[AddTenant] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteTenant calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteTenant(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteTenant] Received for Tenant object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["roots.root.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("tenants.tenant.example.com", parentLabels, displayName)
	if IsChildExists("roots.root.example.com", obj.Name, "tenants.tenant.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Root.Root", "Tenant", displayName)
	}

	err = obj.client.Tenant().DeleteTenantByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteTenant] Tenant object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

// GetEvaluation returns child of given type
func (obj *RootRoot) GetEvaluation(ctx context.Context) (
	result *EvaluationEvaluation, err error) {
	children := GetChildren("roots.root.example.com", obj.Name, "evaluations.evaluation.example.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Evaluation")
	}
	return obj.client.Evaluation().GetEvaluationByName(ctx, children[0])
}

// AddEvaluation calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddEvaluation(ctx context.Context,
	objToCreate *baseevaluationexamplecomv1.Evaluation) (result *EvaluationEvaluation, err error) {
	log.Debugf("[AddEvaluation] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Evaluation().CreateEvaluationByName(ctx, objToCreate)
	log.Debugf("[AddEvaluation] Evaluation created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	log.Debugf("[AddEvaluation] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteEvaluation calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteEvaluation(ctx context.Context) (err error) {
	children := GetChildren("roots.root.example.com", obj.Name, "evaluations.evaluation.example.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteEvaluation] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Evaluation().DeleteEvaluationByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootRootExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootRootExampleV1Chainer) Subscribe() {
	key := "roots.root.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
}

func (c *rootRootExampleV1Chainer) Unsubscribe() {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *rootRootExampleV1Chainer) IsSubscribed() bool {
	key := "roots.root.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *rootRootExampleV1Chainer) RegisterEventHandler(addCB func(obj *RootRoot), updateCB func(oldObj, newObj *RootRoot), deleteCB func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootRoot{
				client: c.client,
				Root:   oldObj.(*baserootexamplecomv1.Root),
			}
			newData := &RootRoot{
				client: c.client,
				Root:   newObj.(*baserootexamplecomv1.Root),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "roots.root.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RootRoot Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RootRoot Create New Informer")
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "roots.root.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RootRoot Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootRoot{
					client: c.client,
					Root:   oldObj.(*baserootexamplecomv1.Root),
				}
				newData := &RootRoot{
					client: c.client,
					Root:   newObj.(*baserootexamplecomv1.Root),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RootRoot Create New Informer")
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootRoot{
					client: c.client,
					Root:   oldObj.(*baserootexamplecomv1.Root),
				}
				newData := &RootRoot{
					client: c.client,
					Root:   newObj.(*baserootexamplecomv1.Root),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "roots.root.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RootRoot Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RootRoot Create New Informer")
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) Tenant(name string) *tenantTenantExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["tenants.tenant.example.com"] = name
	return &tenantTenantExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTenant calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootRootExampleV1Chainer) GetTenant(ctx context.Context, displayName string) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, displayName)
	return c.client.Tenant().GetTenantByName(ctx, hashedName)
}

// AddTenant calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootExampleV1Chainer) AddTenant(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (result *TenantTenant, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Tenant().CreateTenantByName(ctx, objToCreate)
}

// DeleteTenant calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootExampleV1Chainer) DeleteTenant(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, name)
	return c.client.Tenant().DeleteTenantByName(ctx, hashedName)
}

func (c *rootRootExampleV1Chainer) Evaluation() *evaluationEvaluationExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["evaluations.evaluation.example.com"] = helper.DEFAULT_KEY
	return &evaluationEvaluationExampleV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetEvaluation calculates hashed name of the object based on it's parents and returns the object
func (c *rootRootExampleV1Chainer) GetEvaluation(ctx context.Context) (result *EvaluationEvaluation, err error) {
	hashedName := helper.GetHashedName("evaluations.evaluation.example.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Evaluation().GetEvaluationByName(ctx, hashedName)
}

// AddEvaluation calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootExampleV1Chainer) AddEvaluation(ctx context.Context,
	objToCreate *baseevaluationexamplecomv1.Evaluation) (result *EvaluationEvaluation, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("evaluations.evaluation.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Evaluation().CreateEvaluationByName(ctx, objToCreate)
}

// DeleteEvaluation calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootExampleV1Chainer) DeleteEvaluation(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("evaluations.evaluation.example.com", c.parentLabels, name)
	return c.client.Evaluation().DeleteEvaluationByName(ctx, hashedName)
}

func (group *EvaluationExampleV1) GetEvaluationChildrenMap() map[string]baseevaluationexamplecomv1.Child {
	return map[string]baseevaluationexamplecomv1.Child{}
}

func (group *EvaluationExampleV1) GetEvaluationChild(grp, kind, name string) baseevaluationexamplecomv1.Child {
	return baseevaluationexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetEvaluationByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EvaluationExampleV1) GetEvaluationByName(ctx context.Context, hashedName string) (*EvaluationEvaluation, error) {
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetEvaluationByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseevaluationexamplecomv1.Evaluation)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetEvaluationByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseevaluationexamplecomv1.Evaluation).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetEvaluationByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &EvaluationEvaluation{
					client:     group.client,
					Evaluation: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &EvaluationEvaluation{
				client:     group.client,
				Evaluation: resWrCache.(*baseevaluationexamplecomv1.Evaluation),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &EvaluationEvaluation{
				client:     group.client,
				Evaluation: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetEvaluationByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Evaluations: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetEvaluationByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetEvaluationByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadEvaluationByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EvaluationExampleV1) ForceReadEvaluationByName(ctx context.Context, hashedName string) (*EvaluationEvaluation, error) {
	log.Debugf("[ForceReadEvaluationByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadEvaluationByName] Failed to Get Evaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Evaluations: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadEvaluationByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadEvaluationByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadEvaluationByName] Executed Successfully :%s", hashedName)
			return &EvaluationEvaluation{
				client:     group.client,
				Evaluation: result,
			}, nil
		}
	}
}

// DeleteEvaluationByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *EvaluationExampleV1) DeleteEvaluationByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteEvaluationByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseevaluationexamplecomv1.Evaluation
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteEvaluationByName] Failed to get Evaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Evaluations: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEvaluationByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEvaluationByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEvaluationByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("evaluations.evaluation.example.com", hashedName, "quizes.quiz.example.com") {
		err := group.client.Quiz().DeleteQuizByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("evaluations.evaluation.example.com", hashedName, "quizes.quiz.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteEvaluationByName] failed to delete Evaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Evaluations: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEvaluationByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEvaluationByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEvaluationByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("evaluations.evaluation.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteEvaluationByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
	}
	RemoveChild("roots.root.example.com", parentName, "evaluations.evaluation.example.com", hashedName)

	return nil
}

// CreateEvaluationByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *EvaluationExampleV1) CreateEvaluationByName(ctx context.Context,
	objToCreate *baseevaluationexamplecomv1.Evaluation) (*EvaluationEvaluation, error) {
	log.Debugf("[CreateEvaluationByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.QuizGvk = nil

	var (
		retryCount int
		result     *baseevaluationexamplecomv1.Evaluation
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateEvaluationByName] Failed to create Evaluation: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Evaluation: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateEvaluationByName] context canceled while creating Evaluation: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateEvaluationByName] Evaluation: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.EvaluationExampleV1().Evaluations().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateEvaluationByName] Unable to Get Evaluation %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateEvaluationByName] found unexpected error while creating Evaluation: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateEvaluationByName] Evaluation: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("evaluations.evaluation.example.com"); ok {
				log.Debugf("[CreateEvaluationByName] Evaluation: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("roots.root.example.com", objToCreate.GetLabels(), parentName)

	AddChild("roots.root.example.com", parentHashedName, "evaluations.evaluation.example.com", objToCreate.Name)

	log.Debugf("[CreateEvaluationByName] Executed Successfully: %s", objToCreate.GetName())
	return &EvaluationEvaluation{
		client:     group.client,
		Evaluation: result,
	}, nil
}

// UpdateEvaluationByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *EvaluationExampleV1) UpdateEvaluationByName(ctx context.Context,
	objToUpdate *baseevaluationexamplecomv1.Evaluation) (*EvaluationEvaluation, error) {
	log.Debugf("[UpdateEvaluationByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Evaluation().GetEvaluationByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["evaluations.evaluation.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseevaluationexamplecomv1.Evaluation
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			EvaluationExampleV1().
			Evaluations().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateEvaluationByName] Failed to patch Evaluation %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Evaluation Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteEvaluationByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Evaluation: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Evaluation deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateEvaluationByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateEvaluationByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Evaluation Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteEvaluationByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Evaluation: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Evaluation Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateEvaluationByName] Patch Evaluation Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("evaluations.evaluation.example.com"); ok {
				log.Debugf("[UpdateEvaluationByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateEvaluationByName] Executed Successfully %s", objToUpdate.GetName())
	return &EvaluationEvaluation{
		client:     group.client,
		Evaluation: result,
	}, nil
}

// ListEvaluations returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *EvaluationExampleV1) ListEvaluations(ctx context.Context,
	opts metav1.ListOptions) (result []*EvaluationEvaluation, err error) {
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*EvaluationEvaluation, len(items))
		for k, v := range items {
			item, _ := v.(*baseevaluationexamplecomv1.Evaluation)
			result[k] = &EvaluationEvaluation{
				client:     group.client,
				Evaluation: item,
			}
		}
	} else {
		list, err := group.client.baseClient.EvaluationExampleV1().
			Evaluations().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*EvaluationEvaluation, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &EvaluationEvaluation{
				client:     group.client,
				Evaluation: &item,
			}
		}
	}
	return
}

type EvaluationEvaluation struct {
	client *Clientset
	*baseevaluationexamplecomv1.Evaluation
}

// Delete removes obj and all it's children from the database.
func (obj *EvaluationEvaluation) Delete(ctx context.Context) error {
	err := obj.client.Evaluation().DeleteEvaluationByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Evaluation = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *EvaluationEvaluation) Update(ctx context.Context) error {
	result, err := obj.client.Evaluation().UpdateEvaluationByName(ctx, obj.Evaluation)
	if err != nil {
		return err
	}
	obj.Evaluation = result.Evaluation
	return nil
}

func (obj *EvaluationEvaluation) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", obj.Labels, obj.Labels["roots.root.example.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

type EvaluationEvaluationQuiz struct {
	client *Clientset
	Quiz   []baseevaluationexamplecomv1.Child
}

func (n *EvaluationEvaluationQuiz) Next(ctx context.Context) (*QuizQuiz, error) {
	for index, child := range n.Quiz {
		obj, err := n.client.Quiz().GetQuizByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Quiz)-1 {
				n.Quiz = nil
			} else {
				n.Quiz = n.Quiz[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllQuizIter returns an iterator for all children of given type
func (obj *EvaluationEvaluation) GetAllQuizIter(ctx context.Context) (
	result EvaluationEvaluationQuiz) {
	result.client = obj.client
	for _, v := range GetChildren("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com") {
		result.Quiz = append(result.Quiz, baseevaluationexamplecomv1.Child{
			Group: "quiz.example.com",
			Kind:  "Quiz",
			Name:  v,
		})
	}
	return
}

// GetAllQuiz returns all children of a given type
func (obj *EvaluationEvaluation) GetAllQuiz(ctx context.Context) (
	result []*QuizQuiz, err error) {
	for _, v := range GetChildren("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com") {
		l, err := obj.client.Quiz().GetQuizByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetQuiz returns child which has given displayName
func (obj *EvaluationEvaluation) GetQuiz(ctx context.Context,
	displayName string) (result *QuizQuiz, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["evaluations.evaluation.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizes.quiz.example.com", parentLabels, displayName)
	if IsChildExists("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Evaluation.Evaluation", "Quiz", displayName)
	}

	result, err = obj.client.Quiz().GetQuizByName(ctx, childHashName)
	return
}

// AddQuiz calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *EvaluationEvaluation) AddQuiz(ctx context.Context,
	objToCreate *basequizexamplecomv1.Quiz) (result *QuizQuiz, err error) {
	log.Debugf("[AddQuiz] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["evaluations.evaluation.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["evaluations.evaluation.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Quiz().CreateQuizByName(ctx, objToCreate)
	log.Debugf("[AddQuiz] Quiz created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Evaluation().GetEvaluationByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Evaluation = updatedObj.Evaluation
	}
	log.Debugf("[AddQuiz] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteQuiz calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *EvaluationEvaluation) DeleteQuiz(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteQuiz] Received for Quiz object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["evaluations.evaluation.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizes.quiz.example.com", parentLabels, displayName)
	if IsChildExists("evaluations.evaluation.example.com", obj.Name, "quizes.quiz.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Evaluation.Evaluation", "Quiz", displayName)
	}

	err = obj.client.Quiz().DeleteQuizByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteQuiz] Quiz object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Evaluation().GetEvaluationByName(ctx, obj.GetName())
	if err == nil {
		obj.Evaluation = updatedObj.Evaluation
	}
	return
}

type evaluationEvaluationExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *evaluationEvaluationExampleV1Chainer) Subscribe() {
	key := "evaluations.evaluation.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *evaluationEvaluationExampleV1Chainer) Unsubscribe() {
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *evaluationEvaluationExampleV1Chainer) IsSubscribed() bool {
	key := "evaluations.evaluation.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *evaluationEvaluationExampleV1Chainer) addCallback(obj *EvaluationEvaluation) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	AddChild("roots.root.example.com", parentHashName, "evaluations.evaluation.example.com", obj.Name)
}

func (c *evaluationEvaluationExampleV1Chainer) deleteCallback(obj *EvaluationEvaluation) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	RemoveChild("roots.root.example.com", parentHashName, "evaluations.evaluation.example.com", obj.Name)
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterEventHandler(addCB func(obj *EvaluationEvaluation), updateCB func(oldObj, newObj *EvaluationEvaluation), deleteCB func(obj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "evaluations.evaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EvaluationEvaluation")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EvaluationEvaluation, so creating a new one")
		informer = informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: oldObj.(*baseevaluationexamplecomv1.Evaluation),
			}
			newData := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: newObj.(*baseevaluationexamplecomv1.Evaluation),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &EvaluationEvaluation{
				client:     c.client,
				Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterAddCallback(cbfn func(obj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "evaluations.evaluation.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] EvaluationEvaluation Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] EvaluationEvaluation Create New Informer")
		informer := informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "evaluations.evaluation.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] EvaluationEvaluation Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: oldObj.(*baseevaluationexamplecomv1.Evaluation),
				}
				newData := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: newObj.(*baseevaluationexamplecomv1.Evaluation),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] EvaluationEvaluation Create New Informer")
		informer := informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: oldObj.(*baseevaluationexamplecomv1.Evaluation),
				}
				newData := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: newObj.(*baseevaluationexamplecomv1.Evaluation),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *EvaluationEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for EvaluationEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "evaluations.evaluation.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] EvaluationEvaluation Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] EvaluationEvaluation Create New Informer")
		informer := informerevaluationexamplecomv1.NewEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &EvaluationEvaluation{
					client:     c.client,
					Evaluation: obj.(*baseevaluationexamplecomv1.Evaluation),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *evaluationEvaluationExampleV1Chainer) Quiz(name string) *quizQuizExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["quizes.quiz.example.com"] = name
	return &quizQuizExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetQuiz calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *evaluationEvaluationExampleV1Chainer) GetQuiz(ctx context.Context, displayName string) (result *QuizQuiz, err error) {
	hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, displayName)
	return c.client.Quiz().GetQuizByName(ctx, hashedName)
}

// AddQuiz calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *evaluationEvaluationExampleV1Chainer) AddQuiz(ctx context.Context,
	objToCreate *basequizexamplecomv1.Quiz) (result *QuizQuiz, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Quiz().CreateQuizByName(ctx, objToCreate)
}

// DeleteQuiz calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *evaluationEvaluationExampleV1Chainer) DeleteQuiz(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, name)
	return c.client.Quiz().DeleteQuizByName(ctx, hashedName)
}

func (group *QuizExampleV1) GetQuizChildrenMap() map[string]basequizexamplecomv1.Child {
	return map[string]basequizexamplecomv1.Child{}
}

func (group *QuizExampleV1) GetQuizChild(grp, kind, name string) basequizexamplecomv1.Child {
	return basequizexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetQuizByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizExampleV1) GetQuizByName(ctx context.Context, hashedName string) (*QuizQuiz, error) {
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetQuizByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basequizexamplecomv1.Quiz)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetQuizByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basequizexamplecomv1.Quiz).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetQuizByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &QuizQuiz{
					client: group.client,
					Quiz:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &QuizQuiz{
				client: group.client,
				Quiz:   resWrCache.(*basequizexamplecomv1.Quiz),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizExampleV1().
			Quizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &QuizQuiz{
				client: group.client,
				Quiz:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetQuizByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Quizes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetQuizByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetQuizByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadQuizByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizExampleV1) ForceReadQuizByName(ctx context.Context, hashedName string) (*QuizQuiz, error) {
	log.Debugf("[ForceReadQuizByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizExampleV1().
			Quizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadQuizByName] Failed to Get Quizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Quizes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadQuizByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadQuizByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadQuizByName] Executed Successfully :%s", hashedName)
			return &QuizQuiz{
				client: group.client,
				Quiz:   result,
			}, nil
		}
	}
}

// DeleteQuizByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *QuizExampleV1) DeleteQuizByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteQuizByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basequizexamplecomv1.Quiz
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizByName] Failed to get Quizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Quizes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("quizes.quiz.example.com", hashedName, "quizquestions.quizquestion.example.com") {
		err := group.client.Quizquestion().DeleteQuizQuestionByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("quizes.quiz.example.com", hashedName, "quizquestions.quizquestion.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizByName] failed to delete Quizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Quizes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("quizes.quiz.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteQuizByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["evaluations.evaluation.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("evaluations.evaluation.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("evaluations.evaluation.example.com", parents, parentName)
	}
	RemoveChild("evaluations.evaluation.example.com", parentName, "quizes.quiz.example.com", hashedName)

	return nil
}

// CreateQuizByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *QuizExampleV1) CreateQuizByName(ctx context.Context,
	objToCreate *basequizexamplecomv1.Quiz) (*QuizQuiz, error) {
	log.Debugf("[CreateQuizByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.QuestionGvk = nil

	var (
		retryCount int
		result     *basequizexamplecomv1.Quiz
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateQuizByName] Failed to create Quiz: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Quiz: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateQuizByName] context canceled while creating Quiz: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateQuizByName] Quiz: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.QuizExampleV1().Quizes().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateQuizByName] Unable to Get Quiz %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateQuizByName] found unexpected error while creating Quiz: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateQuizByName] Quiz: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("quizes.quiz.example.com"); ok {
				log.Debugf("[CreateQuizByName] Quiz: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["evaluations.evaluation.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("evaluations.evaluation.example.com", objToCreate.GetLabels(), parentName)

	AddChild("evaluations.evaluation.example.com", parentHashedName, "quizes.quiz.example.com", objToCreate.Name)

	log.Debugf("[CreateQuizByName] Executed Successfully: %s", objToCreate.GetName())
	return &QuizQuiz{
		client: group.client,
		Quiz:   result,
	}, nil
}

// SetQuizStatusByName sets user defined status
func (group *QuizExampleV1) SetQuizStatusByName(ctx context.Context,
	objToUpdate *basequizexamplecomv1.Quiz, status *basequizexamplecomv1.QuizStatus) (*QuizQuiz, error) {
	log.Debugf("[SetQuizStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "quiz.example.com",
		Version:  "v1",
		Resource: strings.ToLower("Quizes"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := basequizexamplecomv1.Quiz{}
	obj.Kind = strings.ToLower("Quizes")
	obj.APIVersion = "quiz.example.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.Status = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.dynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			log.Debugf("[SetQuizStatusByName] Updating status for Quiz node %s successful", hashedName)
			break
		}

		log.Errorf("[SetQuizStatusByName] Updating status for Quiz node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadQuizByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			log.Fatalf("[SetQuizStatusByName] Max retry exceeded for updating status for Quiz node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("quizes.quiz.example.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *basequizexamplecomv1.Quiz
			if inWrCache {
				objectToWrite = resWrCache.(*basequizexamplecomv1.Quiz)
				objectToWrite.Status.Status = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.Status = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &QuizQuiz{
		client: group.client,
		Quiz:   objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateQuizByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *QuizExampleV1) UpdateQuizByName(ctx context.Context,
	objToUpdate *basequizexamplecomv1.Quiz) (*QuizQuiz, error) {
	log.Debugf("[UpdateQuizByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Quiz().GetQuizByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["quizes.quiz.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Labels)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Labels).IsNil() {
			patchValueLabels := objToUpdate.Spec.Labels
			patchOpLabels := PatchOp{
				Op:    "replace",
				Path:  "/spec/labels",
				Value: patchValueLabels,
			}
			patch = append(patch, patchOpLabels)
		}
	} else {
		patchValueLabels := objToUpdate.Spec.Labels
		patchOpLabels := PatchOp{
			Op:    "replace",
			Path:  "/spec/labels",
			Value: patchValueLabels,
		}
		patch = append(patch, patchOpLabels)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.DefaultScorePerQuestion)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.DefaultScorePerQuestion).IsNil() {
			patchValueDefaultScorePerQuestion := objToUpdate.Spec.DefaultScorePerQuestion
			patchOpDefaultScorePerQuestion := PatchOp{
				Op:    "replace",
				Path:  "/spec/default_score_per_question",
				Value: patchValueDefaultScorePerQuestion,
			}
			patch = append(patch, patchOpDefaultScorePerQuestion)
		}
	} else {
		patchValueDefaultScorePerQuestion := objToUpdate.Spec.DefaultScorePerQuestion
		patchOpDefaultScorePerQuestion := PatchOp{
			Op:    "replace",
			Path:  "/spec/default_score_per_question",
			Value: patchValueDefaultScorePerQuestion,
		}
		patch = append(patch, patchOpDefaultScorePerQuestion)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basequizexamplecomv1.Quiz
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			QuizExampleV1().
			Quizes().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateQuizByName] Failed to patch Quiz %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Quiz Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteQuizByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Quiz: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Quiz deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateQuizByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateQuizByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Quiz Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteQuizByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Quiz: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Quiz Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateQuizByName] Patch Quiz Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("quizes.quiz.example.com"); ok {
				log.Debugf("[UpdateQuizByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateQuizByName] Executed Successfully %s", objToUpdate.GetName())
	return &QuizQuiz{
		client: group.client,
		Quiz:   result,
	}, nil
}

// ListQuizes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *QuizExampleV1) ListQuizes(ctx context.Context,
	opts metav1.ListOptions) (result []*QuizQuiz, err error) {
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*QuizQuiz, len(items))
		for k, v := range items {
			item, _ := v.(*basequizexamplecomv1.Quiz)
			result[k] = &QuizQuiz{
				client: group.client,
				Quiz:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.QuizExampleV1().
			Quizes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*QuizQuiz, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &QuizQuiz{
				client: group.client,
				Quiz:   &item,
			}
		}
	}
	return
}

type QuizQuiz struct {
	client *Clientset
	*basequizexamplecomv1.Quiz
}

// Delete removes obj and all it's children from the database.
func (obj *QuizQuiz) Delete(ctx context.Context) error {
	err := obj.client.Quiz().DeleteQuizByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Quiz = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *QuizQuiz) Update(ctx context.Context) error {
	result, err := obj.client.Quiz().UpdateQuizByName(ctx, obj.Quiz)
	if err != nil {
		return err
	}
	obj.Quiz = result.Quiz
	return nil
}

// SetStatus sets user defined status
func (obj *QuizQuiz) SetStatus(ctx context.Context, status *basequizexamplecomv1.QuizStatus) error {
	result, err := obj.client.Quiz().SetQuizStatusByName(ctx, obj.Quiz, status)
	if err != nil {
		return err
	}
	obj.Quiz = result.Quiz
	return nil
}

// GetStatus to get user defined status
func (obj *QuizQuiz) GetStatus(ctx context.Context) (*basequizexamplecomv1.QuizStatus, error) {
	getObj, err := obj.client.Quiz().GetQuizByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *QuizQuiz) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Quiz().SetQuizStatusByName(ctx, obj.Quiz, &basequizexamplecomv1.QuizStatus{})
	if err != nil {
		return err
	}
	obj.Quiz = result.Quiz
	return nil
}

func (obj *QuizQuiz) GetParent(ctx context.Context) (result *EvaluationEvaluation, err error) {
	hashedName := helper.GetHashedName("evaluations.evaluation.example.com", obj.Labels, obj.Labels["evaluations.evaluation.example.com"])
	return obj.client.Evaluation().GetEvaluationByName(ctx, hashedName)
}

type QuizQuizQuestion struct {
	client   *Clientset
	Question []basequizexamplecomv1.Child
}

func (n *QuizQuizQuestion) Next(ctx context.Context) (*QuizquestionQuizQuestion, error) {
	for index, child := range n.Question {
		obj, err := n.client.Quizquestion().GetQuizQuestionByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Question)-1 {
				n.Question = nil
			} else {
				n.Question = n.Question[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllQuestionIter returns an iterator for all children of given type
func (obj *QuizQuiz) GetAllQuestionIter(ctx context.Context) (
	result QuizQuizQuestion) {
	result.client = obj.client
	for _, v := range GetChildren("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com") {
		result.Question = append(result.Question, basequizexamplecomv1.Child{
			Group: "quizquestion.example.com",
			Kind:  "QuizQuestion",
			Name:  v,
		})
	}
	return
}

// GetAllQuestion returns all children of a given type
func (obj *QuizQuiz) GetAllQuestion(ctx context.Context) (
	result []*QuizquestionQuizQuestion, err error) {
	for _, v := range GetChildren("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com") {
		l, err := obj.client.Quizquestion().GetQuizQuestionByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetQuestion returns child which has given displayName
func (obj *QuizQuiz) GetQuestion(ctx context.Context,
	displayName string) (result *QuizquestionQuizQuestion, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizes.quiz.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", parentLabels, displayName)
	if IsChildExists("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Quiz.Quiz", "Question", displayName)
	}

	result, err = obj.client.Quizquestion().GetQuizQuestionByName(ctx, childHashName)
	return
}

// AddQuestion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *QuizQuiz) AddQuestion(ctx context.Context,
	objToCreate *basequizquestionexamplecomv1.QuizQuestion) (result *QuizquestionQuizQuestion, err error) {
	log.Debugf("[AddQuestion] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["quizes.quiz.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["quizes.quiz.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Quizquestion().CreateQuizQuestionByName(ctx, objToCreate)
	log.Debugf("[AddQuestion] QuizQuestion created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Quiz().GetQuizByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Quiz = updatedObj.Quiz
	}
	log.Debugf("[AddQuestion] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteQuestion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *QuizQuiz) DeleteQuestion(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteQuestion] Received for QuizQuestion object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizes.quiz.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", parentLabels, displayName)
	if IsChildExists("quizes.quiz.example.com", obj.Name, "quizquestions.quizquestion.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Quiz.Quiz", "Question", displayName)
	}

	err = obj.client.Quizquestion().DeleteQuizQuestionByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteQuestion] QuizQuestion object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Quiz().GetQuizByName(ctx, obj.GetName())
	if err == nil {
		obj.Quiz = updatedObj.Quiz
	}
	return
}

type quizQuizExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *quizQuizExampleV1Chainer) Subscribe() {
	key := "quizes.quiz.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *quizQuizExampleV1Chainer) Unsubscribe() {
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *quizQuizExampleV1Chainer) IsSubscribed() bool {
	key := "quizes.quiz.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *quizQuizExampleV1Chainer) addCallback(obj *QuizQuiz) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["evaluations.evaluation.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("evaluations.evaluation.example.com", obj.Labels, parentDisplayName)

	AddChild("evaluations.evaluation.example.com", parentHashName, "quizes.quiz.example.com", obj.Name)
}

func (c *quizQuizExampleV1Chainer) deleteCallback(obj *QuizQuiz) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["evaluations.evaluation.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("evaluations.evaluation.example.com", obj.Labels, parentDisplayName)

	RemoveChild("evaluations.evaluation.example.com", parentHashName, "quizes.quiz.example.com", obj.Name)
}

func (c *quizQuizExampleV1Chainer) RegisterEventHandler(addCB func(obj *QuizQuiz), updateCB func(oldObj, newObj *QuizQuiz), deleteCB func(obj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "quizes.quiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizQuiz")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizQuiz, so creating a new one")
		informer = informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizQuiz{
				client: c.client,
				Quiz:   obj.(*basequizexamplecomv1.Quiz),
			}

			var parent *EvaluationEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
				parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizQuiz{
				client: c.client,
				Quiz:   oldObj.(*basequizexamplecomv1.Quiz),
			}
			newData := &QuizQuiz{
				client: c.client,
				Quiz:   newObj.(*basequizexamplecomv1.Quiz),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &QuizQuiz{
				client: c.client,
				Quiz:   obj.(*basequizexamplecomv1.Quiz),
			}

			var parent *EvaluationEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
				parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *quizQuizExampleV1Chainer) RegisterAddCallback(cbfn func(obj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizes.quiz.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] QuizQuiz Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &QuizQuiz{
					client: c.client,
					Quiz:   obj.(*basequizexamplecomv1.Quiz),
				}

				var parent *EvaluationEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
					parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] QuizQuiz Create New Informer")
		informer := informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &QuizQuiz{
					client: c.client,
					Quiz:   obj.(*basequizexamplecomv1.Quiz),
				}

				var parent *EvaluationEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
					parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *quizQuizExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizes.quiz.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] QuizQuiz Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &QuizQuiz{
					client: c.client,
					Quiz:   oldObj.(*basequizexamplecomv1.Quiz),
				}
				newData := &QuizQuiz{
					client: c.client,
					Quiz:   newObj.(*basequizexamplecomv1.Quiz),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] QuizQuiz Create New Informer")
		informer := informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &QuizQuiz{
					client: c.client,
					Quiz:   oldObj.(*basequizexamplecomv1.Quiz),
				}
				newData := &QuizQuiz{
					client: c.client,
					Quiz:   newObj.(*basequizexamplecomv1.Quiz),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *quizQuizExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *QuizQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for QuizQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizes.quiz.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] QuizQuiz Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &QuizQuiz{
					client: c.client,
					Quiz:   obj.(*basequizexamplecomv1.Quiz),
				}

				var parent *EvaluationEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
					parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] QuizQuiz Create New Informer")
		informer := informerquizexamplecomv1.NewQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &QuizQuiz{
					client: c.client,
					Quiz:   obj.(*basequizexamplecomv1.Quiz),
				}

				var parent *EvaluationEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("evaluations.evaluation.example.com", nc.Labels, nc.Labels["evaluations.evaluation.example.com"])
					parent, err = c.client.Evaluation().ForceReadEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

// ClearStatus to clear user defined status
func (c *quizQuizExampleV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, c.name)
	obj, err := c.client.Quiz().GetQuizByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Quiz().SetQuizStatusByName(ctx, obj.Quiz, nil)
	return err
}

// GetStatus to get user defined status
func (c *quizQuizExampleV1Chainer) GetStatus(ctx context.Context) (result *basequizexamplecomv1.QuizStatus, err error) {
	hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, c.name)
	obj, err := c.client.Quiz().GetQuizByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *quizQuizExampleV1Chainer) SetStatus(ctx context.Context, status *basequizexamplecomv1.QuizStatus) (err error) {
	hashedName := helper.GetHashedName("quizes.quiz.example.com", c.parentLabels, c.name)
	obj, err := c.client.Quiz().GetQuizByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Quiz().SetQuizStatusByName(ctx, obj.Quiz, status)
	return err
}

func (c *quizQuizExampleV1Chainer) Question(name string) *quizquestionQuizquestionExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["quizquestions.quizquestion.example.com"] = name
	return &quizquestionQuizquestionExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetQuestion calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *quizQuizExampleV1Chainer) GetQuestion(ctx context.Context, displayName string) (result *QuizquestionQuizQuestion, err error) {
	hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", c.parentLabels, displayName)
	return c.client.Quizquestion().GetQuizQuestionByName(ctx, hashedName)
}

// AddQuestion calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *quizQuizExampleV1Chainer) AddQuestion(ctx context.Context,
	objToCreate *basequizquestionexamplecomv1.QuizQuestion) (result *QuizquestionQuizQuestion, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Quizquestion().CreateQuizQuestionByName(ctx, objToCreate)
}

// DeleteQuestion calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *quizQuizExampleV1Chainer) DeleteQuestion(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", c.parentLabels, name)
	return c.client.Quizquestion().DeleteQuizQuestionByName(ctx, hashedName)
}

func (group *QuizquestionExampleV1) GetQuizQuestionChildrenMap() map[string]basequizquestionexamplecomv1.Child {
	return map[string]basequizquestionexamplecomv1.Child{}
}

func (group *QuizquestionExampleV1) GetQuizQuestionChild(grp, kind, name string) basequizquestionexamplecomv1.Child {
	return basequizquestionexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetQuizQuestionByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizquestionExampleV1) GetQuizQuestionByName(ctx context.Context, hashedName string) (*QuizquestionQuizQuestion, error) {
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetQuizQuestionByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basequizquestionexamplecomv1.QuizQuestion)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetQuizQuestionByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basequizquestionexamplecomv1.QuizQuestion).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetQuizQuestionByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &QuizquestionQuizQuestion{
					client:       group.client,
					QuizQuestion: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: resWrCache.(*basequizquestionexamplecomv1.QuizQuestion),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetQuizQuestionByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get QuizQuestions: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetQuizQuestionByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetQuizQuestionByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadQuizQuestionByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizquestionExampleV1) ForceReadQuizQuestionByName(ctx context.Context, hashedName string) (*QuizquestionQuizQuestion, error) {
	log.Debugf("[ForceReadQuizQuestionByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadQuizQuestionByName] Failed to Get QuizQuestions: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get QuizQuestions: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadQuizQuestionByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadQuizQuestionByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadQuizQuestionByName] Executed Successfully :%s", hashedName)
			return &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: result,
			}, nil
		}
	}
}

// DeleteQuizQuestionByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *QuizquestionExampleV1) DeleteQuizQuestionByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteQuizQuestionByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basequizquestionexamplecomv1.QuizQuestion
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizQuestionByName] Failed to get QuizQuestions: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get QuizQuestions: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizQuestionByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("quizquestions.quizquestion.example.com", hashedName, "quizchoices.quizchoice.example.com") {
		err := group.client.Quizchoice().DeleteQuizChoiceByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("quizquestions.quizquestion.example.com", hashedName, "quizchoices.quizchoice.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizQuestionByName] failed to delete QuizQuestions: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete QuizQuestions: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizQuestionByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizQuestionByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("quizquestions.quizquestion.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteQuizQuestionByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["quizes.quiz.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("quizes.quiz.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("quizes.quiz.example.com", parents, parentName)
	}
	RemoveChild("quizes.quiz.example.com", parentName, "quizquestions.quizquestion.example.com", hashedName)

	return nil
}

// CreateQuizQuestionByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *QuizquestionExampleV1) CreateQuizQuestionByName(ctx context.Context,
	objToCreate *basequizquestionexamplecomv1.QuizQuestion) (*QuizquestionQuizQuestion, error) {
	log.Debugf("[CreateQuizQuestionByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ChoiceGvk = nil

	var (
		retryCount int
		result     *basequizquestionexamplecomv1.QuizQuestion
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateQuizQuestionByName] Failed to create QuizQuestion: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create QuizQuestion: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateQuizQuestionByName] context canceled while creating QuizQuestion: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateQuizQuestionByName] QuizQuestion: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.QuizquestionExampleV1().QuizQuestions().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateQuizQuestionByName] Unable to Get QuizQuestion %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateQuizQuestionByName] found unexpected error while creating QuizQuestion: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateQuizQuestionByName] QuizQuestion: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("quizquestions.quizquestion.example.com"); ok {
				log.Debugf("[CreateQuizQuestionByName] QuizQuestion: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["quizes.quiz.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("quizes.quiz.example.com", objToCreate.GetLabels(), parentName)

	AddChild("quizes.quiz.example.com", parentHashedName, "quizquestions.quizquestion.example.com", objToCreate.Name)

	log.Debugf("[CreateQuizQuestionByName] Executed Successfully: %s", objToCreate.GetName())
	return &QuizquestionQuizQuestion{
		client:       group.client,
		QuizQuestion: result,
	}, nil
}

// UpdateQuizQuestionByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *QuizquestionExampleV1) UpdateQuizQuestionByName(ctx context.Context,
	objToUpdate *basequizquestionexamplecomv1.QuizQuestion) (*QuizquestionQuizQuestion, error) {
	log.Debugf("[UpdateQuizQuestionByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Quizquestion().GetQuizQuestionByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["quizquestions.quizquestion.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Question)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Question).IsNil() {
			patchValueQuestion := objToUpdate.Spec.Question
			patchOpQuestion := PatchOp{
				Op:    "replace",
				Path:  "/spec/question",
				Value: patchValueQuestion,
			}
			patch = append(patch, patchOpQuestion)
		}
	} else {
		patchValueQuestion := objToUpdate.Spec.Question
		patchOpQuestion := PatchOp{
			Op:    "replace",
			Path:  "/spec/question",
			Value: patchValueQuestion,
		}
		patch = append(patch, patchOpQuestion)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Hint)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Hint).IsNil() {
			patchValueHint := objToUpdate.Spec.Hint
			patchOpHint := PatchOp{
				Op:    "replace",
				Path:  "/spec/hint",
				Value: patchValueHint,
			}
			patch = append(patch, patchOpHint)
		}
	} else {
		patchValueHint := objToUpdate.Spec.Hint
		patchOpHint := PatchOp{
			Op:    "replace",
			Path:  "/spec/hint",
			Value: patchValueHint,
		}
		patch = append(patch, patchOpHint)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Format)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Format).IsNil() {
			patchValueFormat := objToUpdate.Spec.Format
			patchOpFormat := PatchOp{
				Op:    "replace",
				Path:  "/spec/format",
				Value: patchValueFormat,
			}
			patch = append(patch, patchOpFormat)
		}
	} else {
		patchValueFormat := objToUpdate.Spec.Format
		patchOpFormat := PatchOp{
			Op:    "replace",
			Path:  "/spec/format",
			Value: patchValueFormat,
		}
		patch = append(patch, patchOpFormat)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Score)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Score).IsNil() {
			patchValueScore := objToUpdate.Spec.Score
			patchOpScore := PatchOp{
				Op:    "replace",
				Path:  "/spec/score",
				Value: patchValueScore,
			}
			patch = append(patch, patchOpScore)
		}
	} else {
		patchValueScore := objToUpdate.Spec.Score
		patchOpScore := PatchOp{
			Op:    "replace",
			Path:  "/spec/score",
			Value: patchValueScore,
		}
		patch = append(patch, patchOpScore)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.AnimationFilePath)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.AnimationFilePath).IsNil() {
			patchValueAnimationFilePath := objToUpdate.Spec.AnimationFilePath
			patchOpAnimationFilePath := PatchOp{
				Op:    "replace",
				Path:  "/spec/animationFilePath",
				Value: patchValueAnimationFilePath,
			}
			patch = append(patch, patchOpAnimationFilePath)
		}
	} else {
		patchValueAnimationFilePath := objToUpdate.Spec.AnimationFilePath
		patchOpAnimationFilePath := PatchOp{
			Op:    "replace",
			Path:  "/spec/animationFilePath",
			Value: patchValueAnimationFilePath,
		}
		patch = append(patch, patchOpAnimationFilePath)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PictureFilePath)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PictureFilePath).IsNil() {
			patchValuePictureFilePath := objToUpdate.Spec.PictureFilePath
			patchOpPictureFilePath := PatchOp{
				Op:    "replace",
				Path:  "/spec/pictureFilePath",
				Value: patchValuePictureFilePath,
			}
			patch = append(patch, patchOpPictureFilePath)
		}
	} else {
		patchValuePictureFilePath := objToUpdate.Spec.PictureFilePath
		patchOpPictureFilePath := PatchOp{
			Op:    "replace",
			Path:  "/spec/pictureFilePath",
			Value: patchValuePictureFilePath,
		}
		patch = append(patch, patchOpPictureFilePath)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basequizquestionexamplecomv1.QuizQuestion
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			QuizquestionExampleV1().
			QuizQuestions().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateQuizQuestionByName] Failed to patch QuizQuestion %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger QuizQuestion Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteQuizQuestionByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting QuizQuestion: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("QuizQuestion deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateQuizQuestionByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateQuizQuestionByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger QuizQuestion Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteQuizQuestionByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting QuizQuestion: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("QuizQuestion Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateQuizQuestionByName] Patch QuizQuestion Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("quizquestions.quizquestion.example.com"); ok {
				log.Debugf("[UpdateQuizQuestionByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateQuizQuestionByName] Executed Successfully %s", objToUpdate.GetName())
	return &QuizquestionQuizQuestion{
		client:       group.client,
		QuizQuestion: result,
	}, nil
}

// ListQuizQuestions returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *QuizquestionExampleV1) ListQuizQuestions(ctx context.Context,
	opts metav1.ListOptions) (result []*QuizquestionQuizQuestion, err error) {
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*QuizquestionQuizQuestion, len(items))
		for k, v := range items {
			item, _ := v.(*basequizquestionexamplecomv1.QuizQuestion)
			result[k] = &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: item,
			}
		}
	} else {
		list, err := group.client.baseClient.QuizquestionExampleV1().
			QuizQuestions().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*QuizquestionQuizQuestion, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &QuizquestionQuizQuestion{
				client:       group.client,
				QuizQuestion: &item,
			}
		}
	}
	return
}

type QuizquestionQuizQuestion struct {
	client *Clientset
	*basequizquestionexamplecomv1.QuizQuestion
}

// Delete removes obj and all it's children from the database.
func (obj *QuizquestionQuizQuestion) Delete(ctx context.Context) error {
	err := obj.client.Quizquestion().DeleteQuizQuestionByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.QuizQuestion = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *QuizquestionQuizQuestion) Update(ctx context.Context) error {
	result, err := obj.client.Quizquestion().UpdateQuizQuestionByName(ctx, obj.QuizQuestion)
	if err != nil {
		return err
	}
	obj.QuizQuestion = result.QuizQuestion
	return nil
}

func (obj *QuizquestionQuizQuestion) GetParent(ctx context.Context) (result *QuizQuiz, err error) {
	hashedName := helper.GetHashedName("quizes.quiz.example.com", obj.Labels, obj.Labels["quizes.quiz.example.com"])
	return obj.client.Quiz().GetQuizByName(ctx, hashedName)
}

type QuizquestionQuizQuestionChoice struct {
	client *Clientset
	Choice []basequizquestionexamplecomv1.Child
}

func (n *QuizquestionQuizQuestionChoice) Next(ctx context.Context) (*QuizchoiceQuizChoice, error) {
	for index, child := range n.Choice {
		obj, err := n.client.Quizchoice().GetQuizChoiceByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Choice)-1 {
				n.Choice = nil
			} else {
				n.Choice = n.Choice[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllChoiceIter returns an iterator for all children of given type
func (obj *QuizquestionQuizQuestion) GetAllChoiceIter(ctx context.Context) (
	result QuizquestionQuizQuestionChoice) {
	result.client = obj.client
	for _, v := range GetChildren("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com") {
		result.Choice = append(result.Choice, basequizquestionexamplecomv1.Child{
			Group: "quizchoice.example.com",
			Kind:  "QuizChoice",
			Name:  v,
		})
	}
	return
}

// GetAllChoice returns all children of a given type
func (obj *QuizquestionQuizQuestion) GetAllChoice(ctx context.Context) (
	result []*QuizchoiceQuizChoice, err error) {
	for _, v := range GetChildren("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com") {
		l, err := obj.client.Quizchoice().GetQuizChoiceByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetChoice returns child which has given displayName
func (obj *QuizquestionQuizQuestion) GetChoice(ctx context.Context,
	displayName string) (result *QuizchoiceQuizChoice, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizquestions.quizquestion.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizchoices.quizchoice.example.com", parentLabels, displayName)
	if IsChildExists("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Quizquestion.QuizQuestion", "Choice", displayName)
	}

	result, err = obj.client.Quizchoice().GetQuizChoiceByName(ctx, childHashName)
	return
}

// AddChoice calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *QuizquestionQuizQuestion) AddChoice(ctx context.Context,
	objToCreate *basequizchoiceexamplecomv1.QuizChoice) (result *QuizchoiceQuizChoice, err error) {
	log.Debugf("[AddChoice] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["quizquestions.quizquestion.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["quizquestions.quizquestion.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Quizchoice().CreateQuizChoiceByName(ctx, objToCreate)
	log.Debugf("[AddChoice] QuizChoice created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Quizquestion().GetQuizQuestionByName(ctx, obj.GetName())
	if getErr == nil {
		obj.QuizQuestion = updatedObj.QuizQuestion
	}
	log.Debugf("[AddChoice] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteChoice calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *QuizquestionQuizQuestion) DeleteChoice(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteChoice] Received for QuizChoice object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["quizquestions.quizquestion.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("quizchoices.quizchoice.example.com", parentLabels, displayName)
	if IsChildExists("quizquestions.quizquestion.example.com", obj.Name, "quizchoices.quizchoice.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Quizquestion.QuizQuestion", "Choice", displayName)
	}

	err = obj.client.Quizchoice().DeleteQuizChoiceByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteChoice] QuizChoice object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Quizquestion().GetQuizQuestionByName(ctx, obj.GetName())
	if err == nil {
		obj.QuizQuestion = updatedObj.QuizQuestion
	}
	return
}

type quizquestionQuizquestionExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *quizquestionQuizquestionExampleV1Chainer) Subscribe() {
	key := "quizquestions.quizquestion.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *quizquestionQuizquestionExampleV1Chainer) Unsubscribe() {
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *quizquestionQuizquestionExampleV1Chainer) IsSubscribed() bool {
	key := "quizquestions.quizquestion.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *quizquestionQuizquestionExampleV1Chainer) addCallback(obj *QuizquestionQuizQuestion) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizes.quiz.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizes.quiz.example.com", obj.Labels, parentDisplayName)

	AddChild("quizes.quiz.example.com", parentHashName, "quizquestions.quizquestion.example.com", obj.Name)
}

func (c *quizquestionQuizquestionExampleV1Chainer) deleteCallback(obj *QuizquestionQuizQuestion) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizes.quiz.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizes.quiz.example.com", obj.Labels, parentDisplayName)

	RemoveChild("quizes.quiz.example.com", parentHashName, "quizquestions.quizquestion.example.com", obj.Name)
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterEventHandler(addCB func(obj *QuizquestionQuizQuestion), updateCB func(oldObj, newObj *QuizquestionQuizQuestion), deleteCB func(obj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "quizquestions.quizquestion.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizquestionQuizQuestion")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizquestionQuizQuestion, so creating a new one")
		informer = informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
			}

			var parent *QuizQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
				parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: oldObj.(*basequizquestionexamplecomv1.QuizQuestion),
			}
			newData := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: newObj.(*basequizquestionexamplecomv1.QuizQuestion),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &QuizquestionQuizQuestion{
				client:       c.client,
				QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
			}

			var parent *QuizQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
				parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterAddCallback(cbfn func(obj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizquestions.quizquestion.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] QuizquestionQuizQuestion Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
				}

				var parent *QuizQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
					parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] QuizquestionQuizQuestion Create New Informer")
		informer := informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
				}

				var parent *QuizQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
					parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizquestions.quizquestion.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] QuizquestionQuizQuestion Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: oldObj.(*basequizquestionexamplecomv1.QuizQuestion),
				}
				newData := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: newObj.(*basequizquestionexamplecomv1.QuizQuestion),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] QuizquestionQuizQuestion Create New Informer")
		informer := informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: oldObj.(*basequizquestionexamplecomv1.QuizQuestion),
				}
				newData := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: newObj.(*basequizquestionexamplecomv1.QuizQuestion),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *QuizquestionQuizQuestion)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for QuizquestionQuizQuestion")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizquestions.quizquestion.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] QuizquestionQuizQuestion Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
				}

				var parent *QuizQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
					parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] QuizquestionQuizQuestion Create New Informer")
		informer := informerquizquestionexamplecomv1.NewQuizQuestionInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &QuizquestionQuizQuestion{
					client:       c.client,
					QuizQuestion: obj.(*basequizquestionexamplecomv1.QuizQuestion),
				}

				var parent *QuizQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizes.quiz.example.com", nc.Labels, nc.Labels["quizes.quiz.example.com"])
					parent, err = c.client.Quiz().ForceReadQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *quizquestionQuizquestionExampleV1Chainer) Choice(name string) *quizchoiceQuizchoiceExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["quizchoices.quizchoice.example.com"] = name
	return &quizchoiceQuizchoiceExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetChoice calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *quizquestionQuizquestionExampleV1Chainer) GetChoice(ctx context.Context, displayName string) (result *QuizchoiceQuizChoice, err error) {
	hashedName := helper.GetHashedName("quizchoices.quizchoice.example.com", c.parentLabels, displayName)
	return c.client.Quizchoice().GetQuizChoiceByName(ctx, hashedName)
}

// AddChoice calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *quizquestionQuizquestionExampleV1Chainer) AddChoice(ctx context.Context,
	objToCreate *basequizchoiceexamplecomv1.QuizChoice) (result *QuizchoiceQuizChoice, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("quizchoices.quizchoice.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Quizchoice().CreateQuizChoiceByName(ctx, objToCreate)
}

// DeleteChoice calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *quizquestionQuizquestionExampleV1Chainer) DeleteChoice(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("quizchoices.quizchoice.example.com", c.parentLabels, name)
	return c.client.Quizchoice().DeleteQuizChoiceByName(ctx, hashedName)
}

func (group *QuizchoiceExampleV1) GetQuizChoiceChildrenMap() map[string]basequizchoiceexamplecomv1.Child {
	return map[string]basequizchoiceexamplecomv1.Child{}
}

func (group *QuizchoiceExampleV1) GetQuizChoiceChild(grp, kind, name string) basequizchoiceexamplecomv1.Child {
	return basequizchoiceexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetQuizChoiceByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizchoiceExampleV1) GetQuizChoiceByName(ctx context.Context, hashedName string) (*QuizchoiceQuizChoice, error) {
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetQuizChoiceByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basequizchoiceexamplecomv1.QuizChoice)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetQuizChoiceByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basequizchoiceexamplecomv1.QuizChoice).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetQuizChoiceByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &QuizchoiceQuizChoice{
					client:     group.client,
					QuizChoice: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: resWrCache.(*basequizchoiceexamplecomv1.QuizChoice),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetQuizChoiceByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get QuizChoices: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetQuizChoiceByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetQuizChoiceByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadQuizChoiceByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *QuizchoiceExampleV1) ForceReadQuizChoiceByName(ctx context.Context, hashedName string) (*QuizchoiceQuizChoice, error) {
	log.Debugf("[ForceReadQuizChoiceByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadQuizChoiceByName] Failed to Get QuizChoices: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get QuizChoices: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadQuizChoiceByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadQuizChoiceByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadQuizChoiceByName] Executed Successfully :%s", hashedName)
			return &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: result,
			}, nil
		}
	}
}

// DeleteQuizChoiceByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *QuizchoiceExampleV1) DeleteQuizChoiceByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteQuizChoiceByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basequizchoiceexamplecomv1.QuizChoice
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizChoiceByName] Failed to get QuizChoices: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get QuizChoices: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizChoiceByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteQuizChoiceByName] failed to delete QuizChoices: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete QuizChoices: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteQuizChoiceByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteQuizChoiceByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("quizchoices.quizchoice.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteQuizChoiceByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["quizquestions.quizquestion.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("quizquestions.quizquestion.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("quizquestions.quizquestion.example.com", parents, parentName)
	}
	RemoveChild("quizquestions.quizquestion.example.com", parentName, "quizchoices.quizchoice.example.com", hashedName)

	return nil
}

// CreateQuizChoiceByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *QuizchoiceExampleV1) CreateQuizChoiceByName(ctx context.Context,
	objToCreate *basequizchoiceexamplecomv1.QuizChoice) (*QuizchoiceQuizChoice, error) {
	log.Debugf("[CreateQuizChoiceByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *basequizchoiceexamplecomv1.QuizChoice
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateQuizChoiceByName] Failed to create QuizChoice: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create QuizChoice: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateQuizChoiceByName] context canceled while creating QuizChoice: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateQuizChoiceByName] QuizChoice: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.QuizchoiceExampleV1().QuizChoices().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateQuizChoiceByName] Unable to Get QuizChoice %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateQuizChoiceByName] found unexpected error while creating QuizChoice: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateQuizChoiceByName] QuizChoice: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("quizchoices.quizchoice.example.com"); ok {
				log.Debugf("[CreateQuizChoiceByName] QuizChoice: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["quizquestions.quizquestion.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", objToCreate.GetLabels(), parentName)

	AddChild("quizquestions.quizquestion.example.com", parentHashedName, "quizchoices.quizchoice.example.com", objToCreate.Name)

	log.Debugf("[CreateQuizChoiceByName] Executed Successfully: %s", objToCreate.GetName())
	return &QuizchoiceQuizChoice{
		client:     group.client,
		QuizChoice: result,
	}, nil
}

// UpdateQuizChoiceByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *QuizchoiceExampleV1) UpdateQuizChoiceByName(ctx context.Context,
	objToUpdate *basequizchoiceexamplecomv1.QuizChoice) (*QuizchoiceQuizChoice, error) {
	log.Debugf("[UpdateQuizChoiceByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Quizchoice().GetQuizChoiceByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["quizchoices.quizchoice.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Choice)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Choice).IsNil() {
			patchValueChoice := objToUpdate.Spec.Choice
			patchOpChoice := PatchOp{
				Op:    "replace",
				Path:  "/spec/choice",
				Value: patchValueChoice,
			}
			patch = append(patch, patchOpChoice)
		}
	} else {
		patchValueChoice := objToUpdate.Spec.Choice
		patchOpChoice := PatchOp{
			Op:    "replace",
			Path:  "/spec/choice",
			Value: patchValueChoice,
		}
		patch = append(patch, patchOpChoice)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Hint)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Hint).IsNil() {
			patchValueHint := objToUpdate.Spec.Hint
			patchOpHint := PatchOp{
				Op:    "replace",
				Path:  "/spec/hint",
				Value: patchValueHint,
			}
			patch = append(patch, patchOpHint)
		}
	} else {
		patchValueHint := objToUpdate.Spec.Hint
		patchOpHint := PatchOp{
			Op:    "replace",
			Path:  "/spec/hint",
			Value: patchValueHint,
		}
		patch = append(patch, patchOpHint)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.PictureName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.PictureName).IsNil() {
			patchValuePictureName := objToUpdate.Spec.PictureName
			patchOpPictureName := PatchOp{
				Op:    "replace",
				Path:  "/spec/pictureName",
				Value: patchValuePictureName,
			}
			patch = append(patch, patchOpPictureName)
		}
	} else {
		patchValuePictureName := objToUpdate.Spec.PictureName
		patchOpPictureName := PatchOp{
			Op:    "replace",
			Path:  "/spec/pictureName",
			Value: patchValuePictureName,
		}
		patch = append(patch, patchOpPictureName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Answer)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Answer).IsNil() {
			patchValueAnswer := objToUpdate.Spec.Answer
			patchOpAnswer := PatchOp{
				Op:    "replace",
				Path:  "/spec/answer",
				Value: patchValueAnswer,
			}
			patch = append(patch, patchOpAnswer)
		}
	} else {
		patchValueAnswer := objToUpdate.Spec.Answer
		patchOpAnswer := PatchOp{
			Op:    "replace",
			Path:  "/spec/answer",
			Value: patchValueAnswer,
		}
		patch = append(patch, patchOpAnswer)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basequizchoiceexamplecomv1.QuizChoice
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			QuizchoiceExampleV1().
			QuizChoices().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateQuizChoiceByName] Failed to patch QuizChoice %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger QuizChoice Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteQuizChoiceByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting QuizChoice: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("QuizChoice deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateQuizChoiceByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateQuizChoiceByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger QuizChoice Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteQuizChoiceByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting QuizChoice: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("QuizChoice Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateQuizChoiceByName] Patch QuizChoice Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("quizchoices.quizchoice.example.com"); ok {
				log.Debugf("[UpdateQuizChoiceByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateQuizChoiceByName] Executed Successfully %s", objToUpdate.GetName())
	return &QuizchoiceQuizChoice{
		client:     group.client,
		QuizChoice: result,
	}, nil
}

// ListQuizChoices returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *QuizchoiceExampleV1) ListQuizChoices(ctx context.Context,
	opts metav1.ListOptions) (result []*QuizchoiceQuizChoice, err error) {
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*QuizchoiceQuizChoice, len(items))
		for k, v := range items {
			item, _ := v.(*basequizchoiceexamplecomv1.QuizChoice)
			result[k] = &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: item,
			}
		}
	} else {
		list, err := group.client.baseClient.QuizchoiceExampleV1().
			QuizChoices().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*QuizchoiceQuizChoice, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &QuizchoiceQuizChoice{
				client:     group.client,
				QuizChoice: &item,
			}
		}
	}
	return
}

type QuizchoiceQuizChoice struct {
	client *Clientset
	*basequizchoiceexamplecomv1.QuizChoice
}

// Delete removes obj and all it's children from the database.
func (obj *QuizchoiceQuizChoice) Delete(ctx context.Context) error {
	err := obj.client.Quizchoice().DeleteQuizChoiceByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.QuizChoice = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *QuizchoiceQuizChoice) Update(ctx context.Context) error {
	result, err := obj.client.Quizchoice().UpdateQuizChoiceByName(ctx, obj.QuizChoice)
	if err != nil {
		return err
	}
	obj.QuizChoice = result.QuizChoice
	return nil
}

func (obj *QuizchoiceQuizChoice) GetParent(ctx context.Context) (result *QuizquestionQuizQuestion, err error) {
	hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", obj.Labels, obj.Labels["quizquestions.quizquestion.example.com"])
	return obj.client.Quizquestion().GetQuizQuestionByName(ctx, hashedName)
}

type quizchoiceQuizchoiceExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) Subscribe() {
	key := "quizchoices.quizchoice.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) Unsubscribe() {
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) IsSubscribed() bool {
	key := "quizchoices.quizchoice.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) addCallback(obj *QuizchoiceQuizChoice) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizquestions.quizquestion.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", obj.Labels, parentDisplayName)

	AddChild("quizquestions.quizquestion.example.com", parentHashName, "quizchoices.quizchoice.example.com", obj.Name)
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) deleteCallback(obj *QuizchoiceQuizChoice) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["quizquestions.quizquestion.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("quizquestions.quizquestion.example.com", obj.Labels, parentDisplayName)

	RemoveChild("quizquestions.quizquestion.example.com", parentHashName, "quizchoices.quizchoice.example.com", obj.Name)
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterEventHandler(addCB func(obj *QuizchoiceQuizChoice), updateCB func(oldObj, newObj *QuizchoiceQuizChoice), deleteCB func(obj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "quizchoices.quizchoice.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for QuizchoiceQuizChoice")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for QuizchoiceQuizChoice, so creating a new one")
		informer = informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
			}

			var parent *QuizquestionQuizQuestion
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
				parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: oldObj.(*basequizchoiceexamplecomv1.QuizChoice),
			}
			newData := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: newObj.(*basequizchoiceexamplecomv1.QuizChoice),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &QuizchoiceQuizChoice{
				client:     c.client,
				QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
			}

			var parent *QuizquestionQuizQuestion
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
				parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterAddCallback(cbfn func(obj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizchoices.quizchoice.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] QuizchoiceQuizChoice Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
				}

				var parent *QuizquestionQuizQuestion
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
					parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] QuizchoiceQuizChoice Create New Informer")
		informer := informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
				}

				var parent *QuizquestionQuizQuestion
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
					parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizchoices.quizchoice.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] QuizchoiceQuizChoice Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: oldObj.(*basequizchoiceexamplecomv1.QuizChoice),
				}
				newData := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: newObj.(*basequizchoiceexamplecomv1.QuizChoice),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] QuizchoiceQuizChoice Create New Informer")
		informer := informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: oldObj.(*basequizchoiceexamplecomv1.QuizChoice),
				}
				newData := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: newObj.(*basequizchoiceexamplecomv1.QuizChoice),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *quizchoiceQuizchoiceExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *QuizchoiceQuizChoice)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for QuizchoiceQuizChoice")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "quizchoices.quizchoice.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] QuizchoiceQuizChoice Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
				}

				var parent *QuizquestionQuizQuestion
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
					parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] QuizchoiceQuizChoice Create New Informer")
		informer := informerquizchoiceexamplecomv1.NewQuizChoiceInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &QuizchoiceQuizChoice{
					client:     c.client,
					QuizChoice: obj.(*basequizchoiceexamplecomv1.QuizChoice),
				}

				var parent *QuizquestionQuizQuestion
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("quizquestions.quizquestion.example.com", nc.Labels, nc.Labels["quizquestions.quizquestion.example.com"])
					parent, err = c.client.Quizquestion().ForceReadQuizQuestionByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (group *TenantExampleV1) GetTenantChildrenMap() map[string]basetenantexamplecomv1.Child {
	return map[string]basetenantexamplecomv1.Child{}
}

func (group *TenantExampleV1) GetTenantChild(grp, kind, name string) basetenantexamplecomv1.Child {
	return basetenantexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetTenantByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) GetTenantByName(ctx context.Context, hashedName string) (*TenantTenant, error) {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetTenantByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basetenantexamplecomv1.Tenant)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetTenantByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basetenantexamplecomv1.Tenant).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetTenantByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &TenantTenant{
					client: group.client,
					Tenant: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &TenantTenant{
				client: group.client,
				Tenant: resWrCache.(*basetenantexamplecomv1.Tenant),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &TenantTenant{
				client: group.client,
				Tenant: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetTenantByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Tenants: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetTenantByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetTenantByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadTenantByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) ForceReadTenantByName(ctx context.Context, hashedName string) (*TenantTenant, error) {
	log.Debugf("[ForceReadTenantByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadTenantByName] Failed to Get Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Tenants: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadTenantByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadTenantByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadTenantByName] Executed Successfully :%s", hashedName)
			return &TenantTenant{
				client: group.client,
				Tenant: result,
			}, nil
		}
	}
}

// DeleteTenantByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) DeleteTenantByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteTenantByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basetenantexamplecomv1.Tenant
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteTenantByName] Failed to get Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Tenants: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteTenantByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteTenantByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteTenantByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("tenants.tenant.example.com", hashedName, "configs.config.example.com") {
		err := group.client.Config().DeleteConfigByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("tenants.tenant.example.com", hashedName, "configs.config.example.com", child)
	}

	for _, child := range GetChildren("tenants.tenant.example.com", hashedName, "interests.interest.example.com") {
		err := group.client.Interest().DeleteInterestByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("tenants.tenant.example.com", hashedName, "interests.interest.example.com", child)
	}

	for _, child := range GetChildren("tenants.tenant.example.com", hashedName, "runtimes.runtime.example.com") {
		err := group.client.Runtime().DeleteRuntimeByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("tenants.tenant.example.com", hashedName, "runtimes.runtime.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteTenantByName] failed to delete Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Tenants: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteTenantByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteTenantByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteTenantByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteTenantByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
	}
	RemoveChild("roots.root.example.com", parentName, "tenants.tenant.example.com", hashedName)

	return nil
}

// CreateTenantByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *TenantExampleV1) CreateTenantByName(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (*TenantTenant, error) {
	log.Debugf("[CreateTenantByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConfigGvk = nil
	objToCreate.Spec.InterestGvk = nil
	objToCreate.Spec.RuntimeGvk = nil

	var (
		retryCount int
		result     *basetenantexamplecomv1.Tenant
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateTenantByName] Failed to create Tenant: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Tenant: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateTenantByName] context canceled while creating Tenant: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateTenantByName] Tenant: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.TenantExampleV1().Tenants().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateTenantByName] Unable to Get Tenant %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateTenantByName] found unexpected error while creating Tenant: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateTenantByName] Tenant: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				log.Debugf("[CreateTenantByName] Tenant: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("roots.root.example.com", objToCreate.GetLabels(), parentName)

	AddChild("roots.root.example.com", parentHashedName, "tenants.tenant.example.com", objToCreate.Name)

	log.Debugf("[CreateTenantByName] Executed Successfully: %s", objToCreate.GetName())
	return &TenantTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// UpdateTenantByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *TenantExampleV1) UpdateTenantByName(ctx context.Context,
	objToUpdate *basetenantexamplecomv1.Tenant) (*TenantTenant, error) {
	log.Debugf("[UpdateTenantByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Tenant().GetTenantByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["tenants.tenant.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basetenantexamplecomv1.Tenant
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateTenantByName] Failed to patch Tenant %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Tenant Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteTenantByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Tenant: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Tenant deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateTenantByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateTenantByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Tenant Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteTenantByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Tenant: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Tenant Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateTenantByName] Patch Tenant Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				log.Debugf("[UpdateTenantByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateTenantByName] Executed Successfully %s", objToUpdate.GetName())
	return &TenantTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// ListTenants returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *TenantExampleV1) ListTenants(ctx context.Context,
	opts metav1.ListOptions) (result []*TenantTenant, err error) {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*TenantTenant, len(items))
		for k, v := range items {
			item, _ := v.(*basetenantexamplecomv1.Tenant)
			result[k] = &TenantTenant{
				client: group.client,
				Tenant: item,
			}
		}
	} else {
		list, err := group.client.baseClient.TenantExampleV1().
			Tenants().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*TenantTenant, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &TenantTenant{
				client: group.client,
				Tenant: &item,
			}
		}
	}
	return
}

type TenantTenant struct {
	client *Clientset
	*basetenantexamplecomv1.Tenant
}

// Delete removes obj and all it's children from the database.
func (obj *TenantTenant) Delete(ctx context.Context) error {
	err := obj.client.Tenant().DeleteTenantByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Tenant = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *TenantTenant) Update(ctx context.Context) error {
	result, err := obj.client.Tenant().UpdateTenantByName(ctx, obj.Tenant)
	if err != nil {
		return err
	}
	obj.Tenant = result.Tenant
	return nil
}

func (obj *TenantTenant) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", obj.Labels, obj.Labels["roots.root.example.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *TenantTenant) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "configs.config.example.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Config")
	}
	return obj.client.Config().GetConfigByName(ctx, children[0])
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenantTenant) AddConfig(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (result *ConfigConfig, err error) {
	log.Debugf("[AddConfig] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.tenant.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.tenant.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	log.Debugf("[AddConfig] Config created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	log.Debugf("[AddConfig] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenantTenant) DeleteConfig(ctx context.Context) (err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "configs.config.example.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteConfig] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Config().DeleteConfigByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Tenant().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

type TenantTenantInterest struct {
	client   *Clientset
	Interest []basetenantexamplecomv1.Child
}

func (n *TenantTenantInterest) Next(ctx context.Context) (*InterestInterest, error) {
	for index, child := range n.Interest {
		obj, err := n.client.Interest().GetInterestByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Interest)-1 {
				n.Interest = nil
			} else {
				n.Interest = n.Interest[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllInterestIter returns an iterator for all children of given type
func (obj *TenantTenant) GetAllInterestIter(ctx context.Context) (
	result TenantTenantInterest) {
	result.client = obj.client
	for _, v := range GetChildren("tenants.tenant.example.com", obj.Name, "interests.interest.example.com") {
		result.Interest = append(result.Interest, basetenantexamplecomv1.Child{
			Group: "interest.example.com",
			Kind:  "Interest",
			Name:  v,
		})
	}
	return
}

// GetAllInterest returns all children of a given type
func (obj *TenantTenant) GetAllInterest(ctx context.Context) (
	result []*InterestInterest, err error) {
	for _, v := range GetChildren("tenants.tenant.example.com", obj.Name, "interests.interest.example.com") {
		l, err := obj.client.Interest().GetInterestByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetInterest returns child which has given displayName
func (obj *TenantTenant) GetInterest(ctx context.Context,
	displayName string) (result *InterestInterest, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["tenants.tenant.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("interests.interest.example.com", parentLabels, displayName)
	if IsChildExists("tenants.tenant.example.com", obj.Name, "interests.interest.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Interest", displayName)
	}

	result, err = obj.client.Interest().GetInterestByName(ctx, childHashName)
	return
}

// AddInterest calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenantTenant) AddInterest(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (result *InterestInterest, err error) {
	log.Debugf("[AddInterest] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.tenant.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.tenant.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Interest().CreateInterestByName(ctx, objToCreate)
	log.Debugf("[AddInterest] Interest created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	log.Debugf("[AddInterest] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteInterest calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenantTenant) DeleteInterest(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteInterest] Received for Interest object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["tenants.tenant.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("interests.interest.example.com", parentLabels, displayName)
	if IsChildExists("tenants.tenant.example.com", obj.Name, "interests.interest.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Interest", displayName)
	}

	err = obj.client.Interest().DeleteInterestByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteInterest] Interest object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

// GetRuntime returns child of given type
func (obj *TenantTenant) GetRuntime(ctx context.Context) (
	result *RuntimeRuntime, err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "runtimes.runtime.example.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Runtime")
	}
	return obj.client.Runtime().GetRuntimeByName(ctx, children[0])
}

// AddRuntime calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenantTenant) AddRuntime(ctx context.Context,
	objToCreate *baseruntimeexamplecomv1.Runtime) (result *RuntimeRuntime, err error) {
	log.Debugf("[AddRuntime] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.tenant.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.tenant.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtime().CreateRuntimeByName(ctx, objToCreate)
	log.Debugf("[AddRuntime] Runtime created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	log.Debugf("[AddRuntime] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteRuntime calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenantTenant) DeleteRuntime(ctx context.Context) (err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "runtimes.runtime.example.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteRuntime] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Runtime().DeleteRuntimeByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Tenant().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

type tenantTenantExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *tenantTenantExampleV1Chainer) Subscribe() {
	key := "tenants.tenant.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *tenantTenantExampleV1Chainer) Unsubscribe() {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *tenantTenantExampleV1Chainer) IsSubscribed() bool {
	key := "tenants.tenant.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *tenantTenantExampleV1Chainer) addCallback(obj *TenantTenant) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	AddChild("roots.root.example.com", parentHashName, "tenants.tenant.example.com", obj.Name)
}

func (c *tenantTenantExampleV1Chainer) deleteCallback(obj *TenantTenant) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	RemoveChild("roots.root.example.com", parentHashName, "tenants.tenant.example.com", obj.Name)
}

func (c *tenantTenantExampleV1Chainer) RegisterEventHandler(addCB func(obj *TenantTenant), updateCB func(oldObj, newObj *TenantTenant), deleteCB func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenantTenant")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenantTenant, so creating a new one")
		informer = informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &TenantTenant{
				client: c.client,
				Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
			}
			newData := &TenantTenant{
				client: c.client,
				Tenant: newObj.(*basetenantexamplecomv1.Tenant),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterAddCallback(cbfn func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "tenants.tenant.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] TenantTenant Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] TenantTenant Create New Informer")
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "tenants.tenant.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] TenantTenant Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &TenantTenant{
					client: c.client,
					Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
				}
				newData := &TenantTenant{
					client: c.client,
					Tenant: newObj.(*basetenantexamplecomv1.Tenant),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] TenantTenant Create New Informer")
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &TenantTenant{
					client: c.client,
					Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
				}
				newData := &TenantTenant{
					client: c.client,
					Tenant: newObj.(*basetenantexamplecomv1.Tenant),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "tenants.tenant.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] TenantTenant Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] TenantTenant Create New Informer")
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) Config() *configConfigExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.example.com"] = helper.DEFAULT_KEY
	return &configConfigExampleV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on it's parents and returns the object
func (c *tenantTenantExampleV1Chainer) GetConfig(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantTenantExampleV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantTenantExampleV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

func (c *tenantTenantExampleV1Chainer) Interest(name string) *interestInterestExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["interests.interest.example.com"] = name
	return &interestInterestExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetInterest calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *tenantTenantExampleV1Chainer) GetInterest(ctx context.Context, displayName string) (result *InterestInterest, err error) {
	hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, displayName)
	return c.client.Interest().GetInterestByName(ctx, hashedName)
}

// AddInterest calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantTenantExampleV1Chainer) AddInterest(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (result *InterestInterest, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Interest().CreateInterestByName(ctx, objToCreate)
}

// DeleteInterest calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantTenantExampleV1Chainer) DeleteInterest(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, name)
	return c.client.Interest().DeleteInterestByName(ctx, hashedName)
}

func (c *tenantTenantExampleV1Chainer) Runtime() *runtimeRuntimeExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimes.runtime.example.com"] = helper.DEFAULT_KEY
	return &runtimeRuntimeExampleV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetRuntime calculates hashed name of the object based on it's parents and returns the object
func (c *tenantTenantExampleV1Chainer) GetRuntime(ctx context.Context) (result *RuntimeRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.runtime.example.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Runtime().GetRuntimeByName(ctx, hashedName)
}

// AddRuntime calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantTenantExampleV1Chainer) AddRuntime(ctx context.Context,
	objToCreate *baseruntimeexamplecomv1.Runtime) (result *RuntimeRuntime, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("runtimes.runtime.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtime().CreateRuntimeByName(ctx, objToCreate)
}

// DeleteRuntime calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantTenantExampleV1Chainer) DeleteRuntime(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("runtimes.runtime.example.com", c.parentLabels, name)
	return c.client.Runtime().DeleteRuntimeByName(ctx, hashedName)
}

func (group *ConfigExampleV1) GetConfigChildrenMap() map[string]baseconfigexamplecomv1.Child {
	return map[string]baseconfigexamplecomv1.Child{}
}

func (group *ConfigExampleV1) GetConfigChild(grp, kind, name string) baseconfigexamplecomv1.Child {
	return baseconfigexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetConfigByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseconfigexamplecomv1.Config)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetConfigByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseconfigexamplecomv1.Config).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetConfigByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ConfigConfig{
					client: group.client,
					Config: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ConfigConfig{
				client: group.client,
				Config: resWrCache.(*baseconfigexamplecomv1.Config),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetConfigByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadConfigByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) ForceReadConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	log.Debugf("[ForceReadConfigByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadConfigByName] Failed to Get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadConfigByName] Executed Successfully :%s", hashedName)
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		}
	}
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteConfigByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseconfigexamplecomv1.Config
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] Failed to get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("configs.config.example.com", hashedName, "users.user.example.com") {
		err := group.client.User().DeleteUserByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.example.com", hashedName, "users.user.example.com", child)
	}

	for _, child := range GetChildren("configs.config.example.com", hashedName, "events.event.example.com") {
		err := group.client.Event().DeleteEventByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.example.com", hashedName, "events.event.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] failed to delete Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteConfigByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
	}
	RemoveChild("tenants.tenant.example.com", parentName, "configs.config.example.com", hashedName)

	return nil
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigExampleV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[CreateConfigByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.UserGvk = nil
	objToCreate.Spec.EventGvk = nil

	var (
		retryCount int
		result     *baseconfigexamplecomv1.Config
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateConfigByName] Failed to create Config: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Config: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateConfigByName] context canceled while creating Config: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateConfigByName] Config: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ConfigExampleV1().Configs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateConfigByName] Unable to Get Config %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateConfigByName] found unexpected error while creating Config: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateConfigByName] Config: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				log.Debugf("[CreateConfigByName] Config: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("tenants.tenant.example.com", objToCreate.GetLabels(), parentName)

	AddChild("tenants.tenant.example.com", parentHashedName, "configs.config.example.com", objToCreate.Name)

	log.Debugf("[CreateConfigByName] Executed Successfully: %s", objToCreate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigExampleV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigexamplecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[UpdateConfigByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Config().GetConfigByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["configs.config.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseconfigexamplecomv1.Config
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateConfigByName] Failed to patch Config %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Config: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Config deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateConfigByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateConfigByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Config: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Config Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateConfigByName] Patch Config Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				log.Debugf("[UpdateConfigByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateConfigByName] Executed Successfully %s", objToUpdate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigExampleV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigexamplecomv1.Config)
			result[k] = &ConfigConfig{
				client: group.client,
				Config: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigExampleV1().
			Configs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigConfig{
				client: group.client,
				Config: &item,
			}
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigexamplecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, obj.Labels["tenants.tenant.example.com"])
	return obj.client.Tenant().GetTenantByName(ctx, hashedName)
}

type ConfigConfigUser struct {
	client *Clientset
	User   []baseconfigexamplecomv1.Child
}

func (n *ConfigConfigUser) Next(ctx context.Context) (*UserUser, error) {
	for index, child := range n.User {
		obj, err := n.client.User().GetUserByName(ctx, child.Name)
		if err == nil {
			if index == len(n.User)-1 {
				n.User = nil
			} else {
				n.User = n.User[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllUserIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllUserIter(ctx context.Context) (
	result ConfigConfigUser) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "users.user.example.com") {
		result.User = append(result.User, baseconfigexamplecomv1.Child{
			Group: "user.example.com",
			Kind:  "User",
			Name:  v,
		})
	}
	return
}

// GetAllUser returns all children of a given type
func (obj *ConfigConfig) GetAllUser(ctx context.Context) (
	result []*UserUser, err error) {
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "users.user.example.com") {
		l, err := obj.client.User().GetUserByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUser returns child which has given displayName
func (obj *ConfigConfig) GetUser(ctx context.Context,
	displayName string) (result *UserUser, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("users.user.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "users.user.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "User", displayName)
	}

	result, err = obj.client.User().GetUserByName(ctx, childHashName)
	return
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddUser(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (result *UserUser, err error) {
	log.Debugf("[AddUser] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.User().CreateUserByName(ctx, objToCreate)
	log.Debugf("[AddUser] User created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddUser] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteUser(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteUser] Received for User object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("users.user.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "users.user.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "User", displayName)
	}

	err = obj.client.User().DeleteUserByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteUser] User object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type ConfigConfigEvent struct {
	client *Clientset
	Event  []baseconfigexamplecomv1.Child
}

func (n *ConfigConfigEvent) Next(ctx context.Context) (*EventEvent, error) {
	for index, child := range n.Event {
		obj, err := n.client.Event().GetEventByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Event)-1 {
				n.Event = nil
			} else {
				n.Event = n.Event[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllEventIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllEventIter(ctx context.Context) (
	result ConfigConfigEvent) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "events.event.example.com") {
		result.Event = append(result.Event, baseconfigexamplecomv1.Child{
			Group: "event.example.com",
			Kind:  "Event",
			Name:  v,
		})
	}
	return
}

// GetAllEvent returns all children of a given type
func (obj *ConfigConfig) GetAllEvent(ctx context.Context) (
	result []*EventEvent, err error) {
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "events.event.example.com") {
		l, err := obj.client.Event().GetEventByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetEvent returns child which has given displayName
func (obj *ConfigConfig) GetEvent(ctx context.Context,
	displayName string) (result *EventEvent, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("events.event.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "events.event.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "Event", displayName)
	}

	result, err = obj.client.Event().GetEventByName(ctx, childHashName)
	return
}

// AddEvent calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddEvent(ctx context.Context,
	objToCreate *baseeventexamplecomv1.Event) (result *EventEvent, err error) {
	log.Debugf("[AddEvent] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Event().CreateEventByName(ctx, objToCreate)
	log.Debugf("[AddEvent] Event created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddEvent] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteEvent calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteEvent(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteEvent] Received for Event object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("events.event.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "events.event.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "Event", displayName)
	}

	err = obj.client.Event().DeleteEventByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteEvent] Event object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigExampleV1Chainer) Subscribe() {
	key := "configs.config.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *configConfigExampleV1Chainer) Unsubscribe() {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configConfigExampleV1Chainer) IsSubscribed() bool {
	key := "configs.config.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *configConfigExampleV1Chainer) addCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	AddChild("tenants.tenant.example.com", parentHashName, "configs.config.example.com", obj.Name)
}

func (c *configConfigExampleV1Chainer) deleteCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	RemoveChild("tenants.tenant.example.com", parentHashName, "configs.config.example.com", obj.Name)
}

func (c *configConfigExampleV1Chainer) RegisterEventHandler(addCB func(obj *ConfigConfig), updateCB func(oldObj, newObj *ConfigConfig), deleteCB func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigexamplecomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigexamplecomv1.Config),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterAddCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "configs.config.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] ConfigConfig Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] ConfigConfig Create New Informer")
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "configs.config.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] ConfigConfig Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &ConfigConfig{
					client: c.client,
					Config: oldObj.(*baseconfigexamplecomv1.Config),
				}
				newData := &ConfigConfig{
					client: c.client,
					Config: newObj.(*baseconfigexamplecomv1.Config),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] ConfigConfig Create New Informer")
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &ConfigConfig{
					client: c.client,
					Config: oldObj.(*baseconfigexamplecomv1.Config),
				}
				newData := &ConfigConfig{
					client: c.client,
					Config: newObj.(*baseconfigexamplecomv1.Config),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "configs.config.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] ConfigConfig Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] ConfigConfig Create New Informer")
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) User(name string) *userUserExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["users.user.example.com"] = name
	return &userUserExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUser calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigExampleV1Chainer) GetUser(ctx context.Context, displayName string) (result *UserUser, err error) {
	hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, displayName)
	return c.client.User().GetUserByName(ctx, hashedName)
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigExampleV1Chainer) AddUser(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (result *UserUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.User().CreateUserByName(ctx, objToCreate)
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigExampleV1Chainer) DeleteUser(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, name)
	return c.client.User().DeleteUserByName(ctx, hashedName)
}

func (c *configConfigExampleV1Chainer) Event(name string) *eventEventExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["events.event.example.com"] = name
	return &eventEventExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetEvent calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigExampleV1Chainer) GetEvent(ctx context.Context, displayName string) (result *EventEvent, err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, displayName)
	return c.client.Event().GetEventByName(ctx, hashedName)
}

// AddEvent calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigExampleV1Chainer) AddEvent(ctx context.Context,
	objToCreate *baseeventexamplecomv1.Event) (result *EventEvent, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Event().CreateEventByName(ctx, objToCreate)
}

// DeleteEvent calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigExampleV1Chainer) DeleteEvent(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, name)
	return c.client.Event().DeleteEventByName(ctx, hashedName)
}

func (group *EventExampleV1) GetEventChildrenMap() map[string]baseeventexamplecomv1.Child {
	return map[string]baseeventexamplecomv1.Child{}
}

func (group *EventExampleV1) GetEventChild(grp, kind, name string) baseeventexamplecomv1.Child {
	return baseeventexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetEventByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EventExampleV1) GetEventByName(ctx context.Context, hashedName string) (*EventEvent, error) {
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetEventByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseeventexamplecomv1.Event)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetEventByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseeventexamplecomv1.Event).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetEventByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &EventEvent{
					client: group.client,
					Event:  resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &EventEvent{
				client: group.client,
				Event:  resWrCache.(*baseeventexamplecomv1.Event),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EventExampleV1().
			Events().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &EventEvent{
				client: group.client,
				Event:  result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetEventByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Events: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetEventByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetEventByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadEventByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *EventExampleV1) ForceReadEventByName(ctx context.Context, hashedName string) (*EventEvent, error) {
	log.Debugf("[ForceReadEventByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			EventExampleV1().
			Events().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadEventByName] Failed to Get Events: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Events: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadEventByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadEventByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadEventByName] Executed Successfully :%s", hashedName)
			return &EventEvent{
				client: group.client,
				Event:  result,
			}, nil
		}
	}
}

// DeleteEventByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *EventExampleV1) DeleteEventByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteEventByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseeventexamplecomv1.Event
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EventExampleV1().
			Events().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteEventByName] Failed to get Events: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Events: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEventByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEventByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEventByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			EventExampleV1().
			Events().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteEventByName] failed to delete Events: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Events: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteEventByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteEventByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteEventByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteEventByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
	}
	RemoveChild("configs.config.example.com", parentName, "events.event.example.com", hashedName)

	return nil
}

// CreateEventByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *EventExampleV1) CreateEventByName(ctx context.Context,
	objToCreate *baseeventexamplecomv1.Event) (*EventEvent, error) {
	log.Debugf("[CreateEventByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseeventexamplecomv1.Event
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			EventExampleV1().
			Events().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateEventByName] Failed to create Event: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Event: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateEventByName] context canceled while creating Event: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateEventByName] Event: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.EventExampleV1().Events().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateEventByName] Unable to Get Event %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateEventByName] found unexpected error while creating Event: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateEventByName] Event: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
				log.Debugf("[CreateEventByName] Event: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.example.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.example.com", parentHashedName, "events.event.example.com", objToCreate.Name)

	log.Debugf("[CreateEventByName] Executed Successfully: %s", objToCreate.GetName())
	return &EventEvent{
		client: group.client,
		Event:  result,
	}, nil
}

// SetEventStatusByName sets user defined status
func (group *EventExampleV1) SetEventStatusByName(ctx context.Context,
	objToUpdate *baseeventexamplecomv1.Event, status *baseeventexamplecomv1.Status) (*EventEvent, error) {
	log.Debugf("[SetEventStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "event.example.com",
		Version:  "v1",
		Resource: strings.ToLower("Events"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := baseeventexamplecomv1.Event{}
	obj.Kind = strings.ToLower("Events")
	obj.APIVersion = "event.example.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.Status = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.dynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			log.Debugf("[SetEventStatusByName] Updating status for Event node %s successful", hashedName)
			break
		}

		log.Errorf("[SetEventStatusByName] Updating status for Event node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadEventByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			log.Fatalf("[SetEventStatusByName] Max retry exceeded for updating status for Event node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *baseeventexamplecomv1.Event
			if inWrCache {
				objectToWrite = resWrCache.(*baseeventexamplecomv1.Event)
				objectToWrite.Status.Status = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.Status = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &EventEvent{
		client: group.client,
		Event:  objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateEventByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *EventExampleV1) UpdateEventByName(ctx context.Context,
	objToUpdate *baseeventexamplecomv1.Event) (*EventEvent, error) {
	log.Debugf("[UpdateEventByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Event().GetEventByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["events.event.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Description)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Description).IsNil() {
			patchValueDescription := objToUpdate.Spec.Description
			patchOpDescription := PatchOp{
				Op:    "replace",
				Path:  "/spec/description",
				Value: patchValueDescription,
			}
			patch = append(patch, patchOpDescription)
		}
	} else {
		patchValueDescription := objToUpdate.Spec.Description
		patchOpDescription := PatchOp{
			Op:    "replace",
			Path:  "/spec/description",
			Value: patchValueDescription,
		}
		patch = append(patch, patchOpDescription)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.MeetingLink)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.MeetingLink).IsNil() {
			patchValueMeetingLink := objToUpdate.Spec.MeetingLink
			patchOpMeetingLink := PatchOp{
				Op:    "replace",
				Path:  "/spec/meetingLink",
				Value: patchValueMeetingLink,
			}
			patch = append(patch, patchOpMeetingLink)
		}
	} else {
		patchValueMeetingLink := objToUpdate.Spec.MeetingLink
		patchOpMeetingLink := PatchOp{
			Op:    "replace",
			Path:  "/spec/meetingLink",
			Value: patchValueMeetingLink,
		}
		patch = append(patch, patchOpMeetingLink)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Time)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Time).IsNil() {
			patchValueTime := objToUpdate.Spec.Time
			patchOpTime := PatchOp{
				Op:    "replace",
				Path:  "/spec/time",
				Value: patchValueTime,
			}
			patch = append(patch, patchOpTime)
		}
	} else {
		patchValueTime := objToUpdate.Spec.Time
		patchOpTime := PatchOp{
			Op:    "replace",
			Path:  "/spec/time",
			Value: patchValueTime,
		}
		patch = append(patch, patchOpTime)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Public)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Public).IsNil() {
			patchValuePublic := objToUpdate.Spec.Public
			patchOpPublic := PatchOp{
				Op:    "replace",
				Path:  "/spec/public",
				Value: patchValuePublic,
			}
			patch = append(patch, patchOpPublic)
		}
	} else {
		patchValuePublic := objToUpdate.Spec.Public
		patchOpPublic := PatchOp{
			Op:    "replace",
			Path:  "/spec/public",
			Value: patchValuePublic,
		}
		patch = append(patch, patchOpPublic)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseeventexamplecomv1.Event
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			EventExampleV1().
			Events().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateEventByName] Failed to patch Event %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Event Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteEventByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Event: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Event deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateEventByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateEventByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Event Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteEventByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Event: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Event Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateEventByName] Patch Event Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("events.event.example.com"); ok {
				log.Debugf("[UpdateEventByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateEventByName] Executed Successfully %s", objToUpdate.GetName())
	return &EventEvent{
		client: group.client,
		Event:  result,
	}, nil
}

// ListEvents returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *EventExampleV1) ListEvents(ctx context.Context,
	opts metav1.ListOptions) (result []*EventEvent, err error) {
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*EventEvent, len(items))
		for k, v := range items {
			item, _ := v.(*baseeventexamplecomv1.Event)
			result[k] = &EventEvent{
				client: group.client,
				Event:  item,
			}
		}
	} else {
		list, err := group.client.baseClient.EventExampleV1().
			Events().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*EventEvent, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &EventEvent{
				client: group.client,
				Event:  &item,
			}
		}
	}
	return
}

type EventEvent struct {
	client *Clientset
	*baseeventexamplecomv1.Event
}

// Delete removes obj and all it's children from the database.
func (obj *EventEvent) Delete(ctx context.Context) error {
	err := obj.client.Event().DeleteEventByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Event = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *EventEvent) Update(ctx context.Context) error {
	result, err := obj.client.Event().UpdateEventByName(ctx, obj.Event)
	if err != nil {
		return err
	}
	obj.Event = result.Event
	return nil
}

// SetStatus sets user defined status
func (obj *EventEvent) SetStatus(ctx context.Context, status *baseeventexamplecomv1.Status) error {
	result, err := obj.client.Event().SetEventStatusByName(ctx, obj.Event, status)
	if err != nil {
		return err
	}
	obj.Event = result.Event
	return nil
}

// GetStatus to get user defined status
func (obj *EventEvent) GetStatus(ctx context.Context) (*baseeventexamplecomv1.Status, error) {
	getObj, err := obj.client.Event().GetEventByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *EventEvent) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Event().SetEventStatusByName(ctx, obj.Event, &baseeventexamplecomv1.Status{})
	if err != nil {
		return err
	}
	obj.Event = result.Event
	return nil
}

func (obj *EventEvent) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", obj.Labels, obj.Labels["configs.config.example.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type eventEventExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *eventEventExampleV1Chainer) Subscribe() {
	key := "events.event.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *eventEventExampleV1Chainer) Unsubscribe() {
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *eventEventExampleV1Chainer) IsSubscribed() bool {
	key := "events.event.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *eventEventExampleV1Chainer) addCallback(obj *EventEvent) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.example.com", parentHashName, "events.event.example.com", obj.Name)
}

func (c *eventEventExampleV1Chainer) deleteCallback(obj *EventEvent) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.example.com", parentHashName, "events.event.example.com", obj.Name)
}

func (c *eventEventExampleV1Chainer) RegisterEventHandler(addCB func(obj *EventEvent), updateCB func(oldObj, newObj *EventEvent), deleteCB func(obj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "events.event.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for EventEvent")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for EventEvent, so creating a new one")
		informer = informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &EventEvent{
				client: c.client,
				Event:  obj.(*baseeventexamplecomv1.Event),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &EventEvent{
				client: c.client,
				Event:  oldObj.(*baseeventexamplecomv1.Event),
			}
			newData := &EventEvent{
				client: c.client,
				Event:  newObj.(*baseeventexamplecomv1.Event),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &EventEvent{
				client: c.client,
				Event:  obj.(*baseeventexamplecomv1.Event),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *eventEventExampleV1Chainer) RegisterAddCallback(cbfn func(obj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "events.event.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] EventEvent Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &EventEvent{
					client: c.client,
					Event:  obj.(*baseeventexamplecomv1.Event),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] EventEvent Create New Informer")
		informer := informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &EventEvent{
					client: c.client,
					Event:  obj.(*baseeventexamplecomv1.Event),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *eventEventExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "events.event.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] EventEvent Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &EventEvent{
					client: c.client,
					Event:  oldObj.(*baseeventexamplecomv1.Event),
				}
				newData := &EventEvent{
					client: c.client,
					Event:  newObj.(*baseeventexamplecomv1.Event),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] EventEvent Create New Informer")
		informer := informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &EventEvent{
					client: c.client,
					Event:  oldObj.(*baseeventexamplecomv1.Event),
				}
				newData := &EventEvent{
					client: c.client,
					Event:  newObj.(*baseeventexamplecomv1.Event),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *eventEventExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *EventEvent)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for EventEvent")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "events.event.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] EventEvent Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &EventEvent{
					client: c.client,
					Event:  obj.(*baseeventexamplecomv1.Event),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] EventEvent Create New Informer")
		informer := informereventexamplecomv1.NewEventInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &EventEvent{
					client: c.client,
					Event:  obj.(*baseeventexamplecomv1.Event),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

// ClearStatus to clear user defined status
func (c *eventEventExampleV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, c.name)
	obj, err := c.client.Event().GetEventByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Event().SetEventStatusByName(ctx, obj.Event, nil)
	return err
}

// GetStatus to get user defined status
func (c *eventEventExampleV1Chainer) GetStatus(ctx context.Context) (result *baseeventexamplecomv1.Status, err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, c.name)
	obj, err := c.client.Event().GetEventByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *eventEventExampleV1Chainer) SetStatus(ctx context.Context, status *baseeventexamplecomv1.Status) (err error) {
	hashedName := helper.GetHashedName("events.event.example.com", c.parentLabels, c.name)
	obj, err := c.client.Event().GetEventByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Event().SetEventStatusByName(ctx, obj.Event, status)
	return err
}

func (group *UserExampleV1) GetUserChildrenMap() map[string]baseuserexamplecomv1.Child {
	return map[string]baseuserexamplecomv1.Child{}
}

func (group *UserExampleV1) GetUserChild(grp, kind, name string) baseuserexamplecomv1.Child {
	return baseuserexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetUserByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) GetUserByName(ctx context.Context, hashedName string) (*UserUser, error) {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetUserByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseuserexamplecomv1.User)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetUserByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseuserexamplecomv1.User).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetUserByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &UserUser{
					client: group.client,
					User:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &UserUser{
				client: group.client,
				User:   resWrCache.(*baseuserexamplecomv1.User),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &UserUser{
				client: group.client,
				User:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetUserByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Users: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetUserByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadUserByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) ForceReadUserByName(ctx context.Context, hashedName string) (*UserUser, error) {
	log.Debugf("[ForceReadUserByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadUserByName] Failed to Get Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Users: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadUserByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadUserByName] Executed Successfully :%s", hashedName)
			return &UserUser{
				client: group.client,
				User:   result,
			}, nil
		}
	}
}

// DeleteUserByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) DeleteUserByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteUserByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseuserexamplecomv1.User
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteUserByName] Failed to get Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Users: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteUserByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("users.user.example.com", hashedName, "wannas.wanna.example.com") {
		err := group.client.Wanna().DeleteWannaByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("users.user.example.com", hashedName, "wannas.wanna.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			UserExampleV1().
			Users().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteUserByName] failed to delete Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Users: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteUserByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteUserByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
	}
	RemoveChild("configs.config.example.com", parentName, "users.user.example.com", hashedName)

	return nil
}

// CreateUserByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *UserExampleV1) CreateUserByName(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (*UserUser, error) {
	log.Debugf("[CreateUserByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.WannaGvk = nil

	var (
		retryCount int
		result     *baseuserexamplecomv1.User
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateUserByName] Failed to create User: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create User: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateUserByName] context canceled while creating User: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateUserByName] User: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.UserExampleV1().Users().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateUserByName] Unable to Get User %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateUserByName] found unexpected error while creating User: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateUserByName] User: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				log.Debugf("[CreateUserByName] User: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.example.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.example.com", parentHashedName, "users.user.example.com", objToCreate.Name)

	log.Debugf("[CreateUserByName] Executed Successfully: %s", objToCreate.GetName())
	return &UserUser{
		client: group.client,
		User:   result,
	}, nil
}

// UpdateUserByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *UserExampleV1) UpdateUserByName(ctx context.Context,
	objToUpdate *baseuserexamplecomv1.User) (*UserUser, error) {
	log.Debugf("[UpdateUserByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.User().GetUserByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["users.user.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Username)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Username).IsNil() {
			patchValueUsername := objToUpdate.Spec.Username
			patchOpUsername := PatchOp{
				Op:    "replace",
				Path:  "/spec/username",
				Value: patchValueUsername,
			}
			patch = append(patch, patchOpUsername)
		}
	} else {
		patchValueUsername := objToUpdate.Spec.Username
		patchOpUsername := PatchOp{
			Op:    "replace",
			Path:  "/spec/username",
			Value: patchValueUsername,
		}
		patch = append(patch, patchOpUsername)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Mail)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Mail).IsNil() {
			patchValueMail := objToUpdate.Spec.Mail
			patchOpMail := PatchOp{
				Op:    "replace",
				Path:  "/spec/email",
				Value: patchValueMail,
			}
			patch = append(patch, patchOpMail)
		}
	} else {
		patchValueMail := objToUpdate.Spec.Mail
		patchOpMail := PatchOp{
			Op:    "replace",
			Path:  "/spec/email",
			Value: patchValueMail,
		}
		patch = append(patch, patchOpMail)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FirstName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FirstName).IsNil() {
			patchValueFirstName := objToUpdate.Spec.FirstName
			patchOpFirstName := PatchOp{
				Op:    "replace",
				Path:  "/spec/firstName",
				Value: patchValueFirstName,
			}
			patch = append(patch, patchOpFirstName)
		}
	} else {
		patchValueFirstName := objToUpdate.Spec.FirstName
		patchOpFirstName := PatchOp{
			Op:    "replace",
			Path:  "/spec/firstName",
			Value: patchValueFirstName,
		}
		patch = append(patch, patchOpFirstName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.LastName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.LastName).IsNil() {
			patchValueLastName := objToUpdate.Spec.LastName
			patchOpLastName := PatchOp{
				Op:    "replace",
				Path:  "/spec/lastName",
				Value: patchValueLastName,
			}
			patch = append(patch, patchOpLastName)
		}
	} else {
		patchValueLastName := objToUpdate.Spec.LastName
		patchOpLastName := PatchOp{
			Op:    "replace",
			Path:  "/spec/lastName",
			Value: patchValueLastName,
		}
		patch = append(patch, patchOpLastName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Password)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Password).IsNil() {
			patchValuePassword := objToUpdate.Spec.Password
			patchOpPassword := PatchOp{
				Op:    "replace",
				Path:  "/spec/password",
				Value: patchValuePassword,
			}
			patch = append(patch, patchOpPassword)
		}
	} else {
		patchValuePassword := objToUpdate.Spec.Password
		patchOpPassword := PatchOp{
			Op:    "replace",
			Path:  "/spec/password",
			Value: patchValuePassword,
		}
		patch = append(patch, patchOpPassword)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Realm)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Realm).IsNil() {
			patchValueRealm := objToUpdate.Spec.Realm
			patchOpRealm := PatchOp{
				Op:    "replace",
				Path:  "/spec/realm",
				Value: patchValueRealm,
			}
			patch = append(patch, patchOpRealm)
		}
	} else {
		patchValueRealm := objToUpdate.Spec.Realm
		patchOpRealm := PatchOp{
			Op:    "replace",
			Path:  "/spec/realm",
			Value: patchValueRealm,
		}
		patch = append(patch, patchOpRealm)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseuserexamplecomv1.User
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateUserByName] Failed to patch User %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger User Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteUserByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting User: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("User deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateUserByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateUserByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger User Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteUserByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting User: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("User Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateUserByName] Patch User Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				log.Debugf("[UpdateUserByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateUserByName] Executed Successfully %s", objToUpdate.GetName())
	return &UserUser{
		client: group.client,
		User:   result,
	}, nil
}

// ListUsers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *UserExampleV1) ListUsers(ctx context.Context,
	opts metav1.ListOptions) (result []*UserUser, err error) {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*UserUser, len(items))
		for k, v := range items {
			item, _ := v.(*baseuserexamplecomv1.User)
			result[k] = &UserUser{
				client: group.client,
				User:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.UserExampleV1().
			Users().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*UserUser, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &UserUser{
				client: group.client,
				User:   &item,
			}
		}
	}
	return
}

type UserUser struct {
	client *Clientset
	*baseuserexamplecomv1.User
}

// Delete removes obj and all it's children from the database.
func (obj *UserUser) Delete(ctx context.Context) error {
	err := obj.client.User().DeleteUserByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.User = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *UserUser) Update(ctx context.Context) error {
	result, err := obj.client.User().UpdateUserByName(ctx, obj.User)
	if err != nil {
		return err
	}
	obj.User = result.User
	return nil
}

func (obj *UserUser) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", obj.Labels, obj.Labels["configs.config.example.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type UserUserWanna struct {
	client *Clientset
	Wanna  []baseuserexamplecomv1.Child
}

func (n *UserUserWanna) Next(ctx context.Context) (*WannaWanna, error) {
	for index, child := range n.Wanna {
		obj, err := n.client.Wanna().GetWannaByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Wanna)-1 {
				n.Wanna = nil
			} else {
				n.Wanna = n.Wanna[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllWannaIter returns an iterator for all children of given type
func (obj *UserUser) GetAllWannaIter(ctx context.Context) (
	result UserUserWanna) {
	result.client = obj.client
	for _, v := range GetChildren("users.user.example.com", obj.Name, "wannas.wanna.example.com") {
		result.Wanna = append(result.Wanna, baseuserexamplecomv1.Child{
			Group: "wanna.example.com",
			Kind:  "Wanna",
			Name:  v,
		})
	}
	return
}

// GetAllWanna returns all children of a given type
func (obj *UserUser) GetAllWanna(ctx context.Context) (
	result []*WannaWanna, err error) {
	for _, v := range GetChildren("users.user.example.com", obj.Name, "wannas.wanna.example.com") {
		l, err := obj.client.Wanna().GetWannaByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetWanna returns child which has given displayName
func (obj *UserUser) GetWanna(ctx context.Context,
	displayName string) (result *WannaWanna, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["users.user.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("wannas.wanna.example.com", parentLabels, displayName)
	if IsChildExists("users.user.example.com", obj.Name, "wannas.wanna.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "User.User", "Wanna", displayName)
	}

	result, err = obj.client.Wanna().GetWannaByName(ctx, childHashName)
	return
}

// AddWanna calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *UserUser) AddWanna(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (result *WannaWanna, err error) {
	log.Debugf("[AddWanna] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["users.user.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["users.user.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Wanna().CreateWannaByName(ctx, objToCreate)
	log.Debugf("[AddWanna] Wanna created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.User().GetUserByName(ctx, obj.GetName())
	if getErr == nil {
		obj.User = updatedObj.User
	}
	log.Debugf("[AddWanna] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteWanna calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *UserUser) DeleteWanna(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteWanna] Received for Wanna object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["users.user.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("wannas.wanna.example.com", parentLabels, displayName)
	if IsChildExists("users.user.example.com", obj.Name, "wannas.wanna.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "User.User", "Wanna", displayName)
	}

	err = obj.client.Wanna().DeleteWannaByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteWanna] Wanna object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.User().GetUserByName(ctx, obj.GetName())
	if err == nil {
		obj.User = updatedObj.User
	}
	return
}

type userUserExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userUserExampleV1Chainer) Subscribe() {
	key := "users.user.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *userUserExampleV1Chainer) Unsubscribe() {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userUserExampleV1Chainer) IsSubscribed() bool {
	key := "users.user.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *userUserExampleV1Chainer) addCallback(obj *UserUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.example.com", parentHashName, "users.user.example.com", obj.Name)
}

func (c *userUserExampleV1Chainer) deleteCallback(obj *UserUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.example.com", parentHashName, "users.user.example.com", obj.Name)
}

func (c *userUserExampleV1Chainer) RegisterEventHandler(addCB func(obj *UserUser), updateCB func(oldObj, newObj *UserUser), deleteCB func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for UserUser")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for UserUser, so creating a new one")
		informer = informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &UserUser{
				client: c.client,
				User:   oldObj.(*baseuserexamplecomv1.User),
			}
			newData := &UserUser{
				client: c.client,
				User:   newObj.(*baseuserexamplecomv1.User),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterAddCallback(cbfn func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "users.user.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] UserUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] UserUser Create New Informer")
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "users.user.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] UserUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &UserUser{
					client: c.client,
					User:   oldObj.(*baseuserexamplecomv1.User),
				}
				newData := &UserUser{
					client: c.client,
					User:   newObj.(*baseuserexamplecomv1.User),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] UserUser Create New Informer")
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &UserUser{
					client: c.client,
					User:   oldObj.(*baseuserexamplecomv1.User),
				}
				newData := &UserUser{
					client: c.client,
					User:   newObj.(*baseuserexamplecomv1.User),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "users.user.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] UserUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] UserUser Create New Informer")
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *userUserExampleV1Chainer) Wanna(name string) *wannaWannaExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["wannas.wanna.example.com"] = name
	return &wannaWannaExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetWanna calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *userUserExampleV1Chainer) GetWanna(ctx context.Context, displayName string) (result *WannaWanna, err error) {
	hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, displayName)
	return c.client.Wanna().GetWannaByName(ctx, hashedName)
}

// AddWanna calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *userUserExampleV1Chainer) AddWanna(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (result *WannaWanna, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Wanna().CreateWannaByName(ctx, objToCreate)
}

// DeleteWanna calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *userUserExampleV1Chainer) DeleteWanna(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, name)
	return c.client.Wanna().DeleteWannaByName(ctx, hashedName)
}

func (group *WannaExampleV1) GetWannaChildrenMap() map[string]basewannaexamplecomv1.Child {
	return map[string]basewannaexamplecomv1.Child{}
}

func (group *WannaExampleV1) GetWannaChild(grp, kind, name string) basewannaexamplecomv1.Child {
	return basewannaexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetWannaByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) GetWannaByName(ctx context.Context, hashedName string) (*WannaWanna, error) {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetWannaByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basewannaexamplecomv1.Wanna)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetWannaByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basewannaexamplecomv1.Wanna).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetWannaByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &WannaWanna{
					client: group.client,
					Wanna:  resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &WannaWanna{
				client: group.client,
				Wanna:  resWrCache.(*basewannaexamplecomv1.Wanna),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &WannaWanna{
				client: group.client,
				Wanna:  result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetWannaByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Wannas: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetWannaByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetWannaByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadWannaByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) ForceReadWannaByName(ctx context.Context, hashedName string) (*WannaWanna, error) {
	log.Debugf("[ForceReadWannaByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadWannaByName] Failed to Get Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Wannas: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadWannaByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadWannaByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadWannaByName] Executed Successfully :%s", hashedName)
			return &WannaWanna{
				client: group.client,
				Wanna:  result,
			}, nil
		}
	}
}

// DeleteWannaByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) DeleteWannaByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteWannaByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basewannaexamplecomv1.Wanna
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteWannaByName] Failed to get Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Wannas: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteWannaByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteWannaByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteWannaByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteWannaByName] failed to delete Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Wannas: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteWannaByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteWannaByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteWannaByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteWannaByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["users.user.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("users.user.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("users.user.example.com", parents, parentName)
	}
	RemoveChild("users.user.example.com", parentName, "wannas.wanna.example.com", hashedName)

	return nil
}

// CreateWannaByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *WannaExampleV1) CreateWannaByName(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (*WannaWanna, error) {
	log.Debugf("[CreateWannaByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.InterestGvk = nil

	var (
		retryCount int
		result     *basewannaexamplecomv1.Wanna
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateWannaByName] Failed to create Wanna: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Wanna: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateWannaByName] context canceled while creating Wanna: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateWannaByName] Wanna: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.WannaExampleV1().Wannas().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateWannaByName] Unable to Get Wanna %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateWannaByName] found unexpected error while creating Wanna: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateWannaByName] Wanna: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				log.Debugf("[CreateWannaByName] Wanna: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["users.user.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("users.user.example.com", objToCreate.GetLabels(), parentName)

	AddChild("users.user.example.com", parentHashedName, "wannas.wanna.example.com", objToCreate.Name)

	log.Debugf("[CreateWannaByName] Executed Successfully: %s", objToCreate.GetName())
	return &WannaWanna{
		client: group.client,
		Wanna:  result,
	}, nil
}

// UpdateWannaByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *WannaExampleV1) UpdateWannaByName(ctx context.Context,
	objToUpdate *basewannaexamplecomv1.Wanna) (*WannaWanna, error) {
	log.Debugf("[UpdateWannaByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Wanna().GetWannaByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["wannas.wanna.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basewannaexamplecomv1.Wanna
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateWannaByName] Failed to patch Wanna %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Wanna Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteWannaByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Wanna: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Wanna deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateWannaByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateWannaByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Wanna Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteWannaByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Wanna: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Wanna Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateWannaByName] Patch Wanna Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				log.Debugf("[UpdateWannaByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateWannaByName] Executed Successfully %s", objToUpdate.GetName())
	return &WannaWanna{
		client: group.client,
		Wanna:  result,
	}, nil
}

// ListWannas returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *WannaExampleV1) ListWannas(ctx context.Context,
	opts metav1.ListOptions) (result []*WannaWanna, err error) {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*WannaWanna, len(items))
		for k, v := range items {
			item, _ := v.(*basewannaexamplecomv1.Wanna)
			result[k] = &WannaWanna{
				client: group.client,
				Wanna:  item,
			}
		}
	} else {
		list, err := group.client.baseClient.WannaExampleV1().
			Wannas().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*WannaWanna, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &WannaWanna{
				client: group.client,
				Wanna:  &item,
			}
		}
	}
	return
}

type WannaWanna struct {
	client *Clientset
	*basewannaexamplecomv1.Wanna
}

// Delete removes obj and all it's children from the database.
func (obj *WannaWanna) Delete(ctx context.Context) error {
	err := obj.client.Wanna().DeleteWannaByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Wanna = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *WannaWanna) Update(ctx context.Context) error {
	result, err := obj.client.Wanna().UpdateWannaByName(ctx, obj.Wanna)
	if err != nil {
		return err
	}
	obj.Wanna = result.Wanna
	return nil
}

func (obj *WannaWanna) GetParent(ctx context.Context) (result *UserUser, err error) {
	hashedName := helper.GetHashedName("users.user.example.com", obj.Labels, obj.Labels["users.user.example.com"])
	return obj.client.User().GetUserByName(ctx, hashedName)
}

// GetInterest returns link of given type
func (obj *WannaWanna) GetInterest(ctx context.Context) (
	result *InterestInterest, err error) {
	if obj.Spec.InterestGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Wanna.Wanna", "Interest")
	}
	return obj.client.Interest().GetInterestByName(ctx, obj.Spec.InterestGvk.Name)
}

// LinkInterest links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *WannaWanna) LinkInterest(ctx context.Context,
	linkToAdd *InterestInterest) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/interestGvk",
		Value: basewannaexamplecomv1.Child{
			Group: "interest.example.com",
			Kind:  "Interest",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.WannaExampleV1().Wannas().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Wanna = result
	return nil
}

// UnlinkInterest unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *WannaWanna) UnlinkInterest(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/interestGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.WannaExampleV1().Wannas().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Wanna = result
	return nil

}

type wannaWannaExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *wannaWannaExampleV1Chainer) Subscribe() {
	key := "wannas.wanna.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *wannaWannaExampleV1Chainer) Unsubscribe() {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *wannaWannaExampleV1Chainer) IsSubscribed() bool {
	key := "wannas.wanna.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *wannaWannaExampleV1Chainer) addCallback(obj *WannaWanna) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["users.user.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("users.user.example.com", obj.Labels, parentDisplayName)

	AddChild("users.user.example.com", parentHashName, "wannas.wanna.example.com", obj.Name)
}

func (c *wannaWannaExampleV1Chainer) deleteCallback(obj *WannaWanna) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["users.user.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("users.user.example.com", obj.Labels, parentDisplayName)

	RemoveChild("users.user.example.com", parentHashName, "wannas.wanna.example.com", obj.Name)
}

func (c *wannaWannaExampleV1Chainer) RegisterEventHandler(addCB func(obj *WannaWanna), updateCB func(oldObj, newObj *WannaWanna), deleteCB func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for WannaWanna")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for WannaWanna, so creating a new one")
		informer = informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &WannaWanna{
				client: c.client,
				Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
			}
			newData := &WannaWanna{
				client: c.client,
				Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterAddCallback(cbfn func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "wannas.wanna.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] WannaWanna Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] WannaWanna Create New Informer")
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "wannas.wanna.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] WannaWanna Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &WannaWanna{
					client: c.client,
					Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
				}
				newData := &WannaWanna{
					client: c.client,
					Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] WannaWanna Create New Informer")
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &WannaWanna{
					client: c.client,
					Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
				}
				newData := &WannaWanna{
					client: c.client,
					Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "wannas.wanna.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] WannaWanna Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] WannaWanna Create New Informer")
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (group *InterestExampleV1) GetInterestChildrenMap() map[string]baseinterestexamplecomv1.Child {
	return map[string]baseinterestexamplecomv1.Child{}
}

func (group *InterestExampleV1) GetInterestChild(grp, kind, name string) baseinterestexamplecomv1.Child {
	return baseinterestexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetInterestByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) GetInterestByName(ctx context.Context, hashedName string) (*InterestInterest, error) {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetInterestByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseinterestexamplecomv1.Interest)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetInterestByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseinterestexamplecomv1.Interest).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetInterestByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &InterestInterest{
					client:   group.client,
					Interest: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &InterestInterest{
				client:   group.client,
				Interest: resWrCache.(*baseinterestexamplecomv1.Interest),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &InterestInterest{
				client:   group.client,
				Interest: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetInterestByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Interests: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetInterestByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetInterestByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadInterestByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) ForceReadInterestByName(ctx context.Context, hashedName string) (*InterestInterest, error) {
	log.Debugf("[ForceReadInterestByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadInterestByName] Failed to Get Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Interests: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadInterestByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadInterestByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadInterestByName] Executed Successfully :%s", hashedName)
			return &InterestInterest{
				client:   group.client,
				Interest: result,
			}, nil
		}
	}
}

// DeleteInterestByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) DeleteInterestByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteInterestByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseinterestexamplecomv1.Interest
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteInterestByName] Failed to get Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Interests: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteInterestByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteInterestByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteInterestByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			InterestExampleV1().
			Interests().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteInterestByName] failed to delete Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Interests: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteInterestByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteInterestByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteInterestByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteInterestByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
	}
	RemoveChild("tenants.tenant.example.com", parentName, "interests.interest.example.com", hashedName)

	return nil
}

// CreateInterestByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *InterestExampleV1) CreateInterestByName(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (*InterestInterest, error) {
	log.Debugf("[CreateInterestByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseinterestexamplecomv1.Interest
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateInterestByName] Failed to create Interest: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Interest: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateInterestByName] context canceled while creating Interest: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateInterestByName] Interest: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.InterestExampleV1().Interests().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateInterestByName] Unable to Get Interest %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateInterestByName] found unexpected error while creating Interest: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateInterestByName] Interest: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				log.Debugf("[CreateInterestByName] Interest: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("tenants.tenant.example.com", objToCreate.GetLabels(), parentName)

	AddChild("tenants.tenant.example.com", parentHashedName, "interests.interest.example.com", objToCreate.Name)

	log.Debugf("[CreateInterestByName] Executed Successfully: %s", objToCreate.GetName())
	return &InterestInterest{
		client:   group.client,
		Interest: result,
	}, nil
}

// UpdateInterestByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *InterestExampleV1) UpdateInterestByName(ctx context.Context,
	objToUpdate *baseinterestexamplecomv1.Interest) (*InterestInterest, error) {
	log.Debugf("[UpdateInterestByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Interest().GetInterestByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["interests.interest.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseinterestexamplecomv1.Interest
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateInterestByName] Failed to patch Interest %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Interest Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteInterestByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Interest: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Interest deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateInterestByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateInterestByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Interest Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteInterestByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Interest: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Interest Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateInterestByName] Patch Interest Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				log.Debugf("[UpdateInterestByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateInterestByName] Executed Successfully %s", objToUpdate.GetName())
	return &InterestInterest{
		client:   group.client,
		Interest: result,
	}, nil
}

// ListInterests returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *InterestExampleV1) ListInterests(ctx context.Context,
	opts metav1.ListOptions) (result []*InterestInterest, err error) {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*InterestInterest, len(items))
		for k, v := range items {
			item, _ := v.(*baseinterestexamplecomv1.Interest)
			result[k] = &InterestInterest{
				client:   group.client,
				Interest: item,
			}
		}
	} else {
		list, err := group.client.baseClient.InterestExampleV1().
			Interests().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*InterestInterest, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &InterestInterest{
				client:   group.client,
				Interest: &item,
			}
		}
	}
	return
}

type InterestInterest struct {
	client *Clientset
	*baseinterestexamplecomv1.Interest
}

// Delete removes obj and all it's children from the database.
func (obj *InterestInterest) Delete(ctx context.Context) error {
	err := obj.client.Interest().DeleteInterestByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Interest = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *InterestInterest) Update(ctx context.Context) error {
	result, err := obj.client.Interest().UpdateInterestByName(ctx, obj.Interest)
	if err != nil {
		return err
	}
	obj.Interest = result.Interest
	return nil
}

func (obj *InterestInterest) GetParent(ctx context.Context) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, obj.Labels["tenants.tenant.example.com"])
	return obj.client.Tenant().GetTenantByName(ctx, hashedName)
}

type interestInterestExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *interestInterestExampleV1Chainer) Subscribe() {
	key := "interests.interest.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *interestInterestExampleV1Chainer) Unsubscribe() {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *interestInterestExampleV1Chainer) IsSubscribed() bool {
	key := "interests.interest.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *interestInterestExampleV1Chainer) addCallback(obj *InterestInterest) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	AddChild("tenants.tenant.example.com", parentHashName, "interests.interest.example.com", obj.Name)
}

func (c *interestInterestExampleV1Chainer) deleteCallback(obj *InterestInterest) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	RemoveChild("tenants.tenant.example.com", parentHashName, "interests.interest.example.com", obj.Name)
}

func (c *interestInterestExampleV1Chainer) RegisterEventHandler(addCB func(obj *InterestInterest), updateCB func(oldObj, newObj *InterestInterest), deleteCB func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for InterestInterest")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for InterestInterest, so creating a new one")
		informer = informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &InterestInterest{
				client:   c.client,
				Interest: oldObj.(*baseinterestexamplecomv1.Interest),
			}
			newData := &InterestInterest{
				client:   c.client,
				Interest: newObj.(*baseinterestexamplecomv1.Interest),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterAddCallback(cbfn func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "interests.interest.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] InterestInterest Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] InterestInterest Create New Informer")
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "interests.interest.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] InterestInterest Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &InterestInterest{
					client:   c.client,
					Interest: oldObj.(*baseinterestexamplecomv1.Interest),
				}
				newData := &InterestInterest{
					client:   c.client,
					Interest: newObj.(*baseinterestexamplecomv1.Interest),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] InterestInterest Create New Informer")
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &InterestInterest{
					client:   c.client,
					Interest: oldObj.(*baseinterestexamplecomv1.Interest),
				}
				newData := &InterestInterest{
					client:   c.client,
					Interest: newObj.(*baseinterestexamplecomv1.Interest),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "interests.interest.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] InterestInterest Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] InterestInterest Create New Informer")
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (group *RuntimeExampleV1) GetRuntimeChildrenMap() map[string]baseruntimeexamplecomv1.Child {
	return map[string]baseruntimeexamplecomv1.Child{}
}

func (group *RuntimeExampleV1) GetRuntimeChild(grp, kind, name string) baseruntimeexamplecomv1.Child {
	return baseruntimeexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeExampleV1) GetRuntimeByName(ctx context.Context, hashedName string) (*RuntimeRuntime, error) {
	key := "runtimes.runtime.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRuntimeByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimeexamplecomv1.Runtime)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRuntimeByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimeexamplecomv1.Runtime).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRuntimeByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimeRuntime{
					client:  group.client,
					Runtime: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimeRuntime{
				client:  group.client,
				Runtime: resWrCache.(*baseruntimeexamplecomv1.Runtime),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeExampleV1().
			Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimeRuntime{
				client:  group.client,
				Runtime: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRuntimeByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Runtimes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRuntimeByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRuntimeByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeExampleV1) ForceReadRuntimeByName(ctx context.Context, hashedName string) (*RuntimeRuntime, error) {
	log.Debugf("[ForceReadRuntimeByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeExampleV1().
			Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRuntimeByName] Failed to Get Runtimes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Runtimes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRuntimeByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRuntimeByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRuntimeByName] Executed Successfully :%s", hashedName)
			return &RuntimeRuntime{
				client:  group.client,
				Runtime: result,
			}, nil
		}
	}
}

// DeleteRuntimeByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimeExampleV1) DeleteRuntimeByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRuntimeByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimeexamplecomv1.Runtime
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeExampleV1().
			Runtimes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeByName] Failed to get Runtimes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Runtimes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimes.runtime.example.com", hashedName, "runtimeusers.runtimeuser.example.com") {
		err := group.client.Runtimeuser().DeleteRuntimeUserByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimes.runtime.example.com", hashedName, "runtimeusers.runtimeuser.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimeExampleV1().
			Runtimes().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeByName] failed to delete Runtimes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Runtimes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimes.runtime.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteRuntimeByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
	}
	RemoveChild("tenants.tenant.example.com", parentName, "runtimes.runtime.example.com", hashedName)

	return nil
}

// CreateRuntimeByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimeExampleV1) CreateRuntimeByName(ctx context.Context,
	objToCreate *baseruntimeexamplecomv1.Runtime) (*RuntimeRuntime, error) {
	log.Debugf("[CreateRuntimeByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.UserGvk = nil

	var (
		retryCount int
		result     *baseruntimeexamplecomv1.Runtime
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeExampleV1().
			Runtimes().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRuntimeByName] Failed to create Runtime: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Runtime: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRuntimeByName] context canceled while creating Runtime: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateRuntimeByName] Runtime: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimeExampleV1().Runtimes().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateRuntimeByName] Unable to Get Runtime %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateRuntimeByName] found unexpected error while creating Runtime: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRuntimeByName] Runtime: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimes.runtime.example.com"); ok {
				log.Debugf("[CreateRuntimeByName] Runtime: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("tenants.tenant.example.com", objToCreate.GetLabels(), parentName)

	AddChild("tenants.tenant.example.com", parentHashedName, "runtimes.runtime.example.com", objToCreate.Name)

	log.Debugf("[CreateRuntimeByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimeRuntime{
		client:  group.client,
		Runtime: result,
	}, nil
}

// UpdateRuntimeByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimeExampleV1) UpdateRuntimeByName(ctx context.Context,
	objToUpdate *baseruntimeexamplecomv1.Runtime) (*RuntimeRuntime, error) {
	log.Debugf("[UpdateRuntimeByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtime().GetRuntimeByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimes.runtime.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimeexamplecomv1.Runtime
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimeExampleV1().
			Runtimes().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRuntimeByName] Failed to patch Runtime %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Runtime Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Runtime: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Runtime deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRuntimeByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRuntimeByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Runtime Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Runtime: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Runtime Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRuntimeByName] Patch Runtime Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimes.runtime.example.com"); ok {
				log.Debugf("[UpdateRuntimeByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRuntimeByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimeRuntime{
		client:  group.client,
		Runtime: result,
	}, nil
}

// ListRuntimes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimeExampleV1) ListRuntimes(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimeRuntime, err error) {
	key := "runtimes.runtime.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimeRuntime, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimeexamplecomv1.Runtime)
			result[k] = &RuntimeRuntime{
				client:  group.client,
				Runtime: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimeExampleV1().
			Runtimes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimeRuntime, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimeRuntime{
				client:  group.client,
				Runtime: &item,
			}
		}
	}
	return
}

type RuntimeRuntime struct {
	client *Clientset
	*baseruntimeexamplecomv1.Runtime
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimeRuntime) Delete(ctx context.Context) error {
	err := obj.client.Runtime().DeleteRuntimeByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Runtime = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimeRuntime) Update(ctx context.Context) error {
	result, err := obj.client.Runtime().UpdateRuntimeByName(ctx, obj.Runtime)
	if err != nil {
		return err
	}
	obj.Runtime = result.Runtime
	return nil
}

func (obj *RuntimeRuntime) GetParent(ctx context.Context) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, obj.Labels["tenants.tenant.example.com"])
	return obj.client.Tenant().GetTenantByName(ctx, hashedName)
}

type RuntimeRuntimeUser struct {
	client *Clientset
	User   []baseruntimeexamplecomv1.Child
}

func (n *RuntimeRuntimeUser) Next(ctx context.Context) (*RuntimeuserRuntimeUser, error) {
	for index, child := range n.User {
		obj, err := n.client.Runtimeuser().GetRuntimeUserByName(ctx, child.Name)
		if err == nil {
			if index == len(n.User)-1 {
				n.User = nil
			} else {
				n.User = n.User[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllUserIter returns an iterator for all children of given type
func (obj *RuntimeRuntime) GetAllUserIter(ctx context.Context) (
	result RuntimeRuntimeUser) {
	result.client = obj.client
	for _, v := range GetChildren("runtimes.runtime.example.com", obj.Name, "runtimeusers.runtimeuser.example.com") {
		result.User = append(result.User, baseruntimeexamplecomv1.Child{
			Group: "runtimeuser.example.com",
			Kind:  "RuntimeUser",
			Name:  v,
		})
	}
	return
}

// GetAllUser returns all children of a given type
func (obj *RuntimeRuntime) GetAllUser(ctx context.Context) (
	result []*RuntimeuserRuntimeUser, err error) {
	for _, v := range GetChildren("runtimes.runtime.example.com", obj.Name, "runtimeusers.runtimeuser.example.com") {
		l, err := obj.client.Runtimeuser().GetRuntimeUserByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUser returns child which has given displayName
func (obj *RuntimeRuntime) GetUser(ctx context.Context,
	displayName string) (result *RuntimeuserRuntimeUser, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimes.runtime.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", parentLabels, displayName)
	if IsChildExists("runtimes.runtime.example.com", obj.Name, "runtimeusers.runtimeuser.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Runtime.Runtime", "User", displayName)
	}

	result, err = obj.client.Runtimeuser().GetRuntimeUserByName(ctx, childHashName)
	return
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimeRuntime) AddUser(ctx context.Context,
	objToCreate *baseruntimeuserexamplecomv1.RuntimeUser) (result *RuntimeuserRuntimeUser, err error) {
	log.Debugf("[AddUser] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimes.runtime.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimes.runtime.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtimeuser().CreateRuntimeUserByName(ctx, objToCreate)
	log.Debugf("[AddUser] RuntimeUser created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtime().GetRuntimeByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Runtime = updatedObj.Runtime
	}
	log.Debugf("[AddUser] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimeRuntime) DeleteUser(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteUser] Received for RuntimeUser object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimes.runtime.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", parentLabels, displayName)
	if IsChildExists("runtimes.runtime.example.com", obj.Name, "runtimeusers.runtimeuser.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtime.Runtime", "User", displayName)
	}

	err = obj.client.Runtimeuser().DeleteRuntimeUserByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteUser] RuntimeUser object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtime().GetRuntimeByName(ctx, obj.GetName())
	if err == nil {
		obj.Runtime = updatedObj.Runtime
	}
	return
}

type runtimeRuntimeExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeRuntimeExampleV1Chainer) Subscribe() {
	key := "runtimes.runtime.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeexamplecomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimeRuntimeExampleV1Chainer) Unsubscribe() {
	key := "runtimes.runtime.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeRuntimeExampleV1Chainer) IsSubscribed() bool {
	key := "runtimes.runtime.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeRuntimeExampleV1Chainer) addCallback(obj *RuntimeRuntime) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	AddChild("tenants.tenant.example.com", parentHashName, "runtimes.runtime.example.com", obj.Name)
}

func (c *runtimeRuntimeExampleV1Chainer) deleteCallback(obj *RuntimeRuntime) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	RemoveChild("tenants.tenant.example.com", parentHashName, "runtimes.runtime.example.com", obj.Name)
}

func (c *runtimeRuntimeExampleV1Chainer) RegisterEventHandler(addCB func(obj *RuntimeRuntime), updateCB func(oldObj, newObj *RuntimeRuntime), deleteCB func(obj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimes.runtime.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeRuntime")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeRuntime, so creating a new one")
		informer = informerruntimeexamplecomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeRuntime{
				client:  c.client,
				Runtime: obj.(*baseruntimeexamplecomv1.Runtime),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeRuntime{
				client:  c.client,
				Runtime: oldObj.(*baseruntimeexamplecomv1.Runtime),
			}
			newData := &RuntimeRuntime{
				client:  c.client,
				Runtime: newObj.(*baseruntimeexamplecomv1.Runtime),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeRuntime{
				client:  c.client,
				Runtime: obj.(*baseruntimeexamplecomv1.Runtime),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimeRuntimeExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimes.runtime.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RuntimeRuntime Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeRuntime{
					client:  c.client,
					Runtime: obj.(*baseruntimeexamplecomv1.Runtime),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RuntimeRuntime Create New Informer")
		informer := informerruntimeexamplecomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeRuntime{
					client:  c.client,
					Runtime: obj.(*baseruntimeexamplecomv1.Runtime),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeRuntimeExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimes.runtime.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RuntimeRuntime Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeRuntime{
					client:  c.client,
					Runtime: oldObj.(*baseruntimeexamplecomv1.Runtime),
				}
				newData := &RuntimeRuntime{
					client:  c.client,
					Runtime: newObj.(*baseruntimeexamplecomv1.Runtime),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RuntimeRuntime Create New Informer")
		informer := informerruntimeexamplecomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeRuntime{
					client:  c.client,
					Runtime: oldObj.(*baseruntimeexamplecomv1.Runtime),
				}
				newData := &RuntimeRuntime{
					client:  c.client,
					Runtime: newObj.(*baseruntimeexamplecomv1.Runtime),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeRuntimeExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimeRuntime)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RuntimeRuntime")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimes.runtime.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RuntimeRuntime Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeRuntime{
					client:  c.client,
					Runtime: obj.(*baseruntimeexamplecomv1.Runtime),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RuntimeRuntime Create New Informer")
		informer := informerruntimeexamplecomv1.NewRuntimeInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeRuntime{
					client:  c.client,
					Runtime: obj.(*baseruntimeexamplecomv1.Runtime),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeRuntimeExampleV1Chainer) User(name string) *runtimeuserRuntimeuserExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimeusers.runtimeuser.example.com"] = name
	return &runtimeuserRuntimeuserExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUser calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeRuntimeExampleV1Chainer) GetUser(ctx context.Context, displayName string) (result *RuntimeuserRuntimeUser, err error) {
	hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", c.parentLabels, displayName)
	return c.client.Runtimeuser().GetRuntimeUserByName(ctx, hashedName)
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeRuntimeExampleV1Chainer) AddUser(ctx context.Context,
	objToCreate *baseruntimeuserexamplecomv1.RuntimeUser) (result *RuntimeuserRuntimeUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtimeuser().CreateRuntimeUserByName(ctx, objToCreate)
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeRuntimeExampleV1Chainer) DeleteUser(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", c.parentLabels, name)
	return c.client.Runtimeuser().DeleteRuntimeUserByName(ctx, hashedName)
}

func (group *RuntimeuserExampleV1) GetRuntimeUserChildrenMap() map[string]baseruntimeuserexamplecomv1.Child {
	return map[string]baseruntimeuserexamplecomv1.Child{}
}

func (group *RuntimeuserExampleV1) GetRuntimeUserChild(grp, kind, name string) baseruntimeuserexamplecomv1.Child {
	return baseruntimeuserexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeUserByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeuserExampleV1) GetRuntimeUserByName(ctx context.Context, hashedName string) (*RuntimeuserRuntimeUser, error) {
	key := "runtimeusers.runtimeuser.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRuntimeUserByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimeuserexamplecomv1.RuntimeUser)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRuntimeUserByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimeuserexamplecomv1.RuntimeUser).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRuntimeUserByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimeuserRuntimeUser{
					client:      group.client,
					RuntimeUser: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimeuserRuntimeUser{
				client:      group.client,
				RuntimeUser: resWrCache.(*baseruntimeuserexamplecomv1.RuntimeUser),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeuserExampleV1().
			RuntimeUsers().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimeuserRuntimeUser{
				client:      group.client,
				RuntimeUser: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRuntimeUserByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get RuntimeUsers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRuntimeUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRuntimeUserByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeUserByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeuserExampleV1) ForceReadRuntimeUserByName(ctx context.Context, hashedName string) (*RuntimeuserRuntimeUser, error) {
	log.Debugf("[ForceReadRuntimeUserByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeuserExampleV1().
			RuntimeUsers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRuntimeUserByName] Failed to Get RuntimeUsers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get RuntimeUsers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRuntimeUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRuntimeUserByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRuntimeUserByName] Executed Successfully :%s", hashedName)
			return &RuntimeuserRuntimeUser{
				client:      group.client,
				RuntimeUser: result,
			}, nil
		}
	}
}

// DeleteRuntimeUserByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimeuserExampleV1) DeleteRuntimeUserByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRuntimeUserByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimeuserexamplecomv1.RuntimeUser
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeuserExampleV1().
			RuntimeUsers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeUserByName] Failed to get RuntimeUsers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get RuntimeUsers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeUserByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimeusers.runtimeuser.example.com", hashedName, "runtimeevaluations.runtimeevaluation.example.com") {
		err := group.client.Runtimeevaluation().DeleteRuntimeEvaluationByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimeusers.runtimeuser.example.com", hashedName, "runtimeevaluations.runtimeevaluation.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimeuserExampleV1().
			RuntimeUsers().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeUserByName] failed to delete RuntimeUsers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete RuntimeUsers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeUserByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimeusers.runtimeuser.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteRuntimeUserByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimes.runtime.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("runtimes.runtime.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimes.runtime.example.com", parents, parentName)
	}
	RemoveChild("runtimes.runtime.example.com", parentName, "runtimeusers.runtimeuser.example.com", hashedName)

	return nil
}

// CreateRuntimeUserByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimeuserExampleV1) CreateRuntimeUserByName(ctx context.Context,
	objToCreate *baseruntimeuserexamplecomv1.RuntimeUser) (*RuntimeuserRuntimeUser, error) {
	log.Debugf("[CreateRuntimeUserByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.EvaluationGvk = nil
	objToCreate.Spec.UserGvk = nil

	var (
		retryCount int
		result     *baseruntimeuserexamplecomv1.RuntimeUser
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeuserExampleV1().
			RuntimeUsers().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRuntimeUserByName] Failed to create RuntimeUser: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create RuntimeUser: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRuntimeUserByName] context canceled while creating RuntimeUser: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateRuntimeUserByName] RuntimeUser: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimeuserExampleV1().RuntimeUsers().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateRuntimeUserByName] Unable to Get RuntimeUser %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateRuntimeUserByName] found unexpected error while creating RuntimeUser: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRuntimeUserByName] RuntimeUser: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimeusers.runtimeuser.example.com"); ok {
				log.Debugf("[CreateRuntimeUserByName] RuntimeUser: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimes.runtime.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("runtimes.runtime.example.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimes.runtime.example.com", parentHashedName, "runtimeusers.runtimeuser.example.com", objToCreate.Name)

	log.Debugf("[CreateRuntimeUserByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimeuserRuntimeUser{
		client:      group.client,
		RuntimeUser: result,
	}, nil
}

// UpdateRuntimeUserByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimeuserExampleV1) UpdateRuntimeUserByName(ctx context.Context,
	objToUpdate *baseruntimeuserexamplecomv1.RuntimeUser) (*RuntimeuserRuntimeUser, error) {
	log.Debugf("[UpdateRuntimeUserByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtimeuser().GetRuntimeUserByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimeusers.runtimeuser.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimeuserexamplecomv1.RuntimeUser
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimeuserExampleV1().
			RuntimeUsers().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRuntimeUserByName] Failed to patch RuntimeUser %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger RuntimeUser Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeUserByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting RuntimeUser: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("RuntimeUser deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRuntimeUserByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRuntimeUserByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger RuntimeUser Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeUserByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting RuntimeUser: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("RuntimeUser Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRuntimeUserByName] Patch RuntimeUser Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimeusers.runtimeuser.example.com"); ok {
				log.Debugf("[UpdateRuntimeUserByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRuntimeUserByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimeuserRuntimeUser{
		client:      group.client,
		RuntimeUser: result,
	}, nil
}

// ListRuntimeUsers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimeuserExampleV1) ListRuntimeUsers(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimeuserRuntimeUser, err error) {
	key := "runtimeusers.runtimeuser.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimeuserRuntimeUser, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimeuserexamplecomv1.RuntimeUser)
			result[k] = &RuntimeuserRuntimeUser{
				client:      group.client,
				RuntimeUser: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimeuserExampleV1().
			RuntimeUsers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimeuserRuntimeUser, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimeuserRuntimeUser{
				client:      group.client,
				RuntimeUser: &item,
			}
		}
	}
	return
}

type RuntimeuserRuntimeUser struct {
	client *Clientset
	*baseruntimeuserexamplecomv1.RuntimeUser
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimeuserRuntimeUser) Delete(ctx context.Context) error {
	err := obj.client.Runtimeuser().DeleteRuntimeUserByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RuntimeUser = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimeuserRuntimeUser) Update(ctx context.Context) error {
	result, err := obj.client.Runtimeuser().UpdateRuntimeUserByName(ctx, obj.RuntimeUser)
	if err != nil {
		return err
	}
	obj.RuntimeUser = result.RuntimeUser
	return nil
}

func (obj *RuntimeuserRuntimeUser) GetParent(ctx context.Context) (result *RuntimeRuntime, err error) {
	hashedName := helper.GetHashedName("runtimes.runtime.example.com", obj.Labels, obj.Labels["runtimes.runtime.example.com"])
	return obj.client.Runtime().GetRuntimeByName(ctx, hashedName)
}

// GetEvaluation returns child of given type
func (obj *RuntimeuserRuntimeUser) GetEvaluation(ctx context.Context) (
	result *RuntimeevaluationRuntimeEvaluation, err error) {
	children := GetChildren("runtimeusers.runtimeuser.example.com", obj.Name, "runtimeevaluations.runtimeevaluation.example.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Runtimeuser.RuntimeUser", "Evaluation")
	}
	return obj.client.Runtimeevaluation().GetRuntimeEvaluationByName(ctx, children[0])
}

// AddEvaluation calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimeuserRuntimeUser) AddEvaluation(ctx context.Context,
	objToCreate *baseruntimeevaluationexamplecomv1.RuntimeEvaluation) (result *RuntimeevaluationRuntimeEvaluation, err error) {
	log.Debugf("[AddEvaluation] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimeusers.runtimeuser.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimeusers.runtimeuser.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtimeevaluation().CreateRuntimeEvaluationByName(ctx, objToCreate)
	log.Debugf("[AddEvaluation] RuntimeEvaluation created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtimeuser().GetRuntimeUserByName(ctx, obj.GetName())
	if getErr == nil {
		obj.RuntimeUser = updatedObj.RuntimeUser
	}
	log.Debugf("[AddEvaluation] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteEvaluation calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimeuserRuntimeUser) DeleteEvaluation(ctx context.Context) (err error) {
	children := GetChildren("runtimeusers.runtimeuser.example.com", obj.Name, "runtimeevaluations.runtimeevaluation.example.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteEvaluation] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Runtimeevaluation().DeleteRuntimeEvaluationByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Runtimeuser().GetRuntimeUserByName(ctx, obj.GetName())
	if err == nil {
		obj.RuntimeUser = updatedObj.RuntimeUser
	}
	return
}

// GetUser returns link of given type
func (obj *RuntimeuserRuntimeUser) GetUser(ctx context.Context) (
	result *UserUser, err error) {
	if obj.Spec.UserGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Runtimeuser.RuntimeUser", "User")
	}
	return obj.client.User().GetUserByName(ctx, obj.Spec.UserGvk.Name)
}

// LinkUser links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *RuntimeuserRuntimeUser) LinkUser(ctx context.Context,
	linkToAdd *UserUser) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/userGvk",
		Value: baseruntimeuserexamplecomv1.Child{
			Group: "user.example.com",
			Kind:  "User",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RuntimeuserExampleV1().RuntimeUsers().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.RuntimeUser = result
	return nil
}

// UnlinkUser unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *RuntimeuserRuntimeUser) UnlinkUser(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/userGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RuntimeuserExampleV1().RuntimeUsers().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.RuntimeUser = result
	return nil

}

type runtimeuserRuntimeuserExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) Subscribe() {
	key := "runtimeusers.runtimeuser.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeuserexamplecomv1.NewRuntimeUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) Unsubscribe() {
	key := "runtimeusers.runtimeuser.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) IsSubscribed() bool {
	key := "runtimeusers.runtimeuser.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) addCallback(obj *RuntimeuserRuntimeUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimes.runtime.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimes.runtime.example.com", obj.Labels, parentDisplayName)

	AddChild("runtimes.runtime.example.com", parentHashName, "runtimeusers.runtimeuser.example.com", obj.Name)
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) deleteCallback(obj *RuntimeuserRuntimeUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimes.runtime.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimes.runtime.example.com", obj.Labels, parentDisplayName)

	RemoveChild("runtimes.runtime.example.com", parentHashName, "runtimeusers.runtimeuser.example.com", obj.Name)
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) RegisterEventHandler(addCB func(obj *RuntimeuserRuntimeUser), updateCB func(oldObj, newObj *RuntimeuserRuntimeUser), deleteCB func(obj *RuntimeuserRuntimeUser)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimeuserRuntimeUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimeusers.runtimeuser.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeuserRuntimeUser")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeuserRuntimeUser, so creating a new one")
		informer = informerruntimeuserexamplecomv1.NewRuntimeUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeuserRuntimeUser{
				client:      c.client,
				RuntimeUser: obj.(*baseruntimeuserexamplecomv1.RuntimeUser),
			}

			var parent *RuntimeRuntime
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimes.runtime.example.com", nc.Labels, nc.Labels["runtimes.runtime.example.com"])
				parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeuserRuntimeUser{
				client:      c.client,
				RuntimeUser: oldObj.(*baseruntimeuserexamplecomv1.RuntimeUser),
			}
			newData := &RuntimeuserRuntimeUser{
				client:      c.client,
				RuntimeUser: newObj.(*baseruntimeuserexamplecomv1.RuntimeUser),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeuserRuntimeUser{
				client:      c.client,
				RuntimeUser: obj.(*baseruntimeuserexamplecomv1.RuntimeUser),
			}

			var parent *RuntimeRuntime
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimes.runtime.example.com", nc.Labels, nc.Labels["runtimes.runtime.example.com"])
				parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimeuserRuntimeUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RuntimeuserRuntimeUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeusers.runtimeuser.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RuntimeuserRuntimeUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: obj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}

				var parent *RuntimeRuntime
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimes.runtime.example.com", nc.Labels, nc.Labels["runtimes.runtime.example.com"])
					parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RuntimeuserRuntimeUser Create New Informer")
		informer := informerruntimeuserexamplecomv1.NewRuntimeUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: obj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}

				var parent *RuntimeRuntime
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimes.runtime.example.com", nc.Labels, nc.Labels["runtimes.runtime.example.com"])
					parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimeuserRuntimeUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RuntimeuserRuntimeUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeusers.runtimeuser.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RuntimeuserRuntimeUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: oldObj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}
				newData := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: newObj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RuntimeuserRuntimeUser Create New Informer")
		informer := informerruntimeuserexamplecomv1.NewRuntimeUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: oldObj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}
				newData := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: newObj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimeuserRuntimeUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RuntimeuserRuntimeUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeusers.runtimeuser.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RuntimeuserRuntimeUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: obj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}

				var parent *RuntimeRuntime
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimes.runtime.example.com", nc.Labels, nc.Labels["runtimes.runtime.example.com"])
					parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RuntimeuserRuntimeUser Create New Informer")
		informer := informerruntimeuserexamplecomv1.NewRuntimeUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeuserRuntimeUser{
					client:      c.client,
					RuntimeUser: obj.(*baseruntimeuserexamplecomv1.RuntimeUser),
				}

				var parent *RuntimeRuntime
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimes.runtime.example.com", nc.Labels, nc.Labels["runtimes.runtime.example.com"])
					parent, err = c.client.Runtime().ForceReadRuntimeByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeuserRuntimeuserExampleV1Chainer) Evaluation() *runtimeevaluationRuntimeevaluationExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimeevaluations.runtimeevaluation.example.com"] = helper.DEFAULT_KEY
	return &runtimeevaluationRuntimeevaluationExampleV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetEvaluation calculates hashed name of the object based on it's parents and returns the object
func (c *runtimeuserRuntimeuserExampleV1Chainer) GetEvaluation(ctx context.Context) (result *RuntimeevaluationRuntimeEvaluation, err error) {
	hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Runtimeevaluation().GetRuntimeEvaluationByName(ctx, hashedName)
}

// AddEvaluation calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeuserRuntimeuserExampleV1Chainer) AddEvaluation(ctx context.Context,
	objToCreate *baseruntimeevaluationexamplecomv1.RuntimeEvaluation) (result *RuntimeevaluationRuntimeEvaluation, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtimeevaluation().CreateRuntimeEvaluationByName(ctx, objToCreate)
}

// DeleteEvaluation calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeuserRuntimeuserExampleV1Chainer) DeleteEvaluation(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", c.parentLabels, name)
	return c.client.Runtimeevaluation().DeleteRuntimeEvaluationByName(ctx, hashedName)
}

func (group *RuntimeevaluationExampleV1) GetRuntimeEvaluationChildrenMap() map[string]baseruntimeevaluationexamplecomv1.Child {
	return map[string]baseruntimeevaluationexamplecomv1.Child{}
}

func (group *RuntimeevaluationExampleV1) GetRuntimeEvaluationChild(grp, kind, name string) baseruntimeevaluationexamplecomv1.Child {
	return baseruntimeevaluationexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeEvaluationByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeevaluationExampleV1) GetRuntimeEvaluationByName(ctx context.Context, hashedName string) (*RuntimeevaluationRuntimeEvaluation, error) {
	key := "runtimeevaluations.runtimeevaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRuntimeEvaluationByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRuntimeEvaluationByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRuntimeEvaluationByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimeevaluationRuntimeEvaluation{
					client:            group.client,
					RuntimeEvaluation: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimeevaluationRuntimeEvaluation{
				client:            group.client,
				RuntimeEvaluation: resWrCache.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeevaluationExampleV1().
			RuntimeEvaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimeevaluationRuntimeEvaluation{
				client:            group.client,
				RuntimeEvaluation: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRuntimeEvaluationByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get RuntimeEvaluations: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRuntimeEvaluationByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRuntimeEvaluationByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeEvaluationByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeevaluationExampleV1) ForceReadRuntimeEvaluationByName(ctx context.Context, hashedName string) (*RuntimeevaluationRuntimeEvaluation, error) {
	log.Debugf("[ForceReadRuntimeEvaluationByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeevaluationExampleV1().
			RuntimeEvaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRuntimeEvaluationByName] Failed to Get RuntimeEvaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get RuntimeEvaluations: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRuntimeEvaluationByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRuntimeEvaluationByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRuntimeEvaluationByName] Executed Successfully :%s", hashedName)
			return &RuntimeevaluationRuntimeEvaluation{
				client:            group.client,
				RuntimeEvaluation: result,
			}, nil
		}
	}
}

// DeleteRuntimeEvaluationByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimeevaluationExampleV1) DeleteRuntimeEvaluationByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRuntimeEvaluationByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimeevaluationexamplecomv1.RuntimeEvaluation
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeevaluationExampleV1().
			RuntimeEvaluations().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeEvaluationByName] Failed to get RuntimeEvaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get RuntimeEvaluations: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeEvaluationByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeEvaluationByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeEvaluationByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimeevaluations.runtimeevaluation.example.com", hashedName, "runtimequizes.runtimequiz.example.com") {
		err := group.client.Runtimequiz().DeleteRuntimeQuizByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimeevaluations.runtimeevaluation.example.com", hashedName, "runtimequizes.runtimequiz.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimeevaluationExampleV1().
			RuntimeEvaluations().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeEvaluationByName] failed to delete RuntimeEvaluations: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete RuntimeEvaluations: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeEvaluationByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeEvaluationByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeEvaluationByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimeevaluations.runtimeevaluation.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteRuntimeEvaluationByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimeusers.runtimeuser.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("runtimeusers.runtimeuser.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimeusers.runtimeuser.example.com", parents, parentName)
	}
	RemoveChild("runtimeusers.runtimeuser.example.com", parentName, "runtimeevaluations.runtimeevaluation.example.com", hashedName)

	return nil
}

// CreateRuntimeEvaluationByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimeevaluationExampleV1) CreateRuntimeEvaluationByName(ctx context.Context,
	objToCreate *baseruntimeevaluationexamplecomv1.RuntimeEvaluation) (*RuntimeevaluationRuntimeEvaluation, error) {
	log.Debugf("[CreateRuntimeEvaluationByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.QuizGvk = nil

	var (
		retryCount int
		result     *baseruntimeevaluationexamplecomv1.RuntimeEvaluation
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeevaluationExampleV1().
			RuntimeEvaluations().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRuntimeEvaluationByName] Failed to create RuntimeEvaluation: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create RuntimeEvaluation: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRuntimeEvaluationByName] context canceled while creating RuntimeEvaluation: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateRuntimeEvaluationByName] RuntimeEvaluation: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimeevaluationExampleV1().RuntimeEvaluations().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateRuntimeEvaluationByName] Unable to Get RuntimeEvaluation %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateRuntimeEvaluationByName] found unexpected error while creating RuntimeEvaluation: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRuntimeEvaluationByName] RuntimeEvaluation: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimeevaluations.runtimeevaluation.example.com"); ok {
				log.Debugf("[CreateRuntimeEvaluationByName] RuntimeEvaluation: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimeusers.runtimeuser.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimeusers.runtimeuser.example.com", parentHashedName, "runtimeevaluations.runtimeevaluation.example.com", objToCreate.Name)

	log.Debugf("[CreateRuntimeEvaluationByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimeevaluationRuntimeEvaluation{
		client:            group.client,
		RuntimeEvaluation: result,
	}, nil
}

// UpdateRuntimeEvaluationByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimeevaluationExampleV1) UpdateRuntimeEvaluationByName(ctx context.Context,
	objToUpdate *baseruntimeevaluationexamplecomv1.RuntimeEvaluation) (*RuntimeevaluationRuntimeEvaluation, error) {
	log.Debugf("[UpdateRuntimeEvaluationByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtimeevaluation().GetRuntimeEvaluationByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimeevaluations.runtimeevaluation.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimeevaluationexamplecomv1.RuntimeEvaluation
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimeevaluationExampleV1().
			RuntimeEvaluations().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRuntimeEvaluationByName] Failed to patch RuntimeEvaluation %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger RuntimeEvaluation Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeEvaluationByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting RuntimeEvaluation: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("RuntimeEvaluation deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRuntimeEvaluationByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRuntimeEvaluationByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger RuntimeEvaluation Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeEvaluationByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting RuntimeEvaluation: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("RuntimeEvaluation Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRuntimeEvaluationByName] Patch RuntimeEvaluation Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimeevaluations.runtimeevaluation.example.com"); ok {
				log.Debugf("[UpdateRuntimeEvaluationByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRuntimeEvaluationByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimeevaluationRuntimeEvaluation{
		client:            group.client,
		RuntimeEvaluation: result,
	}, nil
}

// ListRuntimeEvaluations returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimeevaluationExampleV1) ListRuntimeEvaluations(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimeevaluationRuntimeEvaluation, err error) {
	key := "runtimeevaluations.runtimeevaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimeevaluationRuntimeEvaluation, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation)
			result[k] = &RuntimeevaluationRuntimeEvaluation{
				client:            group.client,
				RuntimeEvaluation: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimeevaluationExampleV1().
			RuntimeEvaluations().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimeevaluationRuntimeEvaluation, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimeevaluationRuntimeEvaluation{
				client:            group.client,
				RuntimeEvaluation: &item,
			}
		}
	}
	return
}

type RuntimeevaluationRuntimeEvaluation struct {
	client *Clientset
	*baseruntimeevaluationexamplecomv1.RuntimeEvaluation
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimeevaluationRuntimeEvaluation) Delete(ctx context.Context) error {
	err := obj.client.Runtimeevaluation().DeleteRuntimeEvaluationByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RuntimeEvaluation = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimeevaluationRuntimeEvaluation) Update(ctx context.Context) error {
	result, err := obj.client.Runtimeevaluation().UpdateRuntimeEvaluationByName(ctx, obj.RuntimeEvaluation)
	if err != nil {
		return err
	}
	obj.RuntimeEvaluation = result.RuntimeEvaluation
	return nil
}

func (obj *RuntimeevaluationRuntimeEvaluation) GetParent(ctx context.Context) (result *RuntimeuserRuntimeUser, err error) {
	hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", obj.Labels, obj.Labels["runtimeusers.runtimeuser.example.com"])
	return obj.client.Runtimeuser().GetRuntimeUserByName(ctx, hashedName)
}

type RuntimeevaluationRuntimeEvaluationQuiz struct {
	client *Clientset
	Quiz   []baseruntimeevaluationexamplecomv1.Child
}

func (n *RuntimeevaluationRuntimeEvaluationQuiz) Next(ctx context.Context) (*RuntimequizRuntimeQuiz, error) {
	for index, child := range n.Quiz {
		obj, err := n.client.Runtimequiz().GetRuntimeQuizByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Quiz)-1 {
				n.Quiz = nil
			} else {
				n.Quiz = n.Quiz[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllQuizIter returns an iterator for all children of given type
func (obj *RuntimeevaluationRuntimeEvaluation) GetAllQuizIter(ctx context.Context) (
	result RuntimeevaluationRuntimeEvaluationQuiz) {
	result.client = obj.client
	for _, v := range GetChildren("runtimeevaluations.runtimeevaluation.example.com", obj.Name, "runtimequizes.runtimequiz.example.com") {
		result.Quiz = append(result.Quiz, baseruntimeevaluationexamplecomv1.Child{
			Group: "runtimequiz.example.com",
			Kind:  "RuntimeQuiz",
			Name:  v,
		})
	}
	return
}

// GetAllQuiz returns all children of a given type
func (obj *RuntimeevaluationRuntimeEvaluation) GetAllQuiz(ctx context.Context) (
	result []*RuntimequizRuntimeQuiz, err error) {
	for _, v := range GetChildren("runtimeevaluations.runtimeevaluation.example.com", obj.Name, "runtimequizes.runtimequiz.example.com") {
		l, err := obj.client.Runtimequiz().GetRuntimeQuizByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetQuiz returns child which has given displayName
func (obj *RuntimeevaluationRuntimeEvaluation) GetQuiz(ctx context.Context,
	displayName string) (result *RuntimequizRuntimeQuiz, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeevaluations.runtimeevaluation.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", parentLabels, displayName)
	if IsChildExists("runtimeevaluations.runtimeevaluation.example.com", obj.Name, "runtimequizes.runtimequiz.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Runtimeevaluation.RuntimeEvaluation", "Quiz", displayName)
	}

	result, err = obj.client.Runtimequiz().GetRuntimeQuizByName(ctx, childHashName)
	return
}

// AddQuiz calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimeevaluationRuntimeEvaluation) AddQuiz(ctx context.Context,
	objToCreate *baseruntimequizexamplecomv1.RuntimeQuiz) (result *RuntimequizRuntimeQuiz, err error) {
	log.Debugf("[AddQuiz] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimeevaluations.runtimeevaluation.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimeevaluations.runtimeevaluation.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtimequiz().CreateRuntimeQuizByName(ctx, objToCreate)
	log.Debugf("[AddQuiz] RuntimeQuiz created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtimeevaluation().GetRuntimeEvaluationByName(ctx, obj.GetName())
	if getErr == nil {
		obj.RuntimeEvaluation = updatedObj.RuntimeEvaluation
	}
	log.Debugf("[AddQuiz] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteQuiz calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimeevaluationRuntimeEvaluation) DeleteQuiz(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteQuiz] Received for RuntimeQuiz object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimeevaluations.runtimeevaluation.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", parentLabels, displayName)
	if IsChildExists("runtimeevaluations.runtimeevaluation.example.com", obj.Name, "runtimequizes.runtimequiz.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtimeevaluation.RuntimeEvaluation", "Quiz", displayName)
	}

	err = obj.client.Runtimequiz().DeleteRuntimeQuizByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteQuiz] RuntimeQuiz object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtimeevaluation().GetRuntimeEvaluationByName(ctx, obj.GetName())
	if err == nil {
		obj.RuntimeEvaluation = updatedObj.RuntimeEvaluation
	}
	return
}

type runtimeevaluationRuntimeevaluationExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) Subscribe() {
	key := "runtimeevaluations.runtimeevaluation.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeevaluationexamplecomv1.NewRuntimeEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) Unsubscribe() {
	key := "runtimeevaluations.runtimeevaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) IsSubscribed() bool {
	key := "runtimeevaluations.runtimeevaluation.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) addCallback(obj *RuntimeevaluationRuntimeEvaluation) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimeusers.runtimeuser.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", obj.Labels, parentDisplayName)

	AddChild("runtimeusers.runtimeuser.example.com", parentHashName, "runtimeevaluations.runtimeevaluation.example.com", obj.Name)
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) deleteCallback(obj *RuntimeevaluationRuntimeEvaluation) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimeusers.runtimeuser.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", obj.Labels, parentDisplayName)

	RemoveChild("runtimeusers.runtimeuser.example.com", parentHashName, "runtimeevaluations.runtimeevaluation.example.com", obj.Name)
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) RegisterEventHandler(addCB func(obj *RuntimeevaluationRuntimeEvaluation), updateCB func(oldObj, newObj *RuntimeevaluationRuntimeEvaluation), deleteCB func(obj *RuntimeevaluationRuntimeEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimeevaluationRuntimeEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimeevaluations.runtimeevaluation.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeevaluationRuntimeEvaluation")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeevaluationRuntimeEvaluation, so creating a new one")
		informer = informerruntimeevaluationexamplecomv1.NewRuntimeEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeevaluationRuntimeEvaluation{
				client:            c.client,
				RuntimeEvaluation: obj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
			}

			var parent *RuntimeuserRuntimeUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", nc.Labels, nc.Labels["runtimeusers.runtimeuser.example.com"])
				parent, err = c.client.Runtimeuser().ForceReadRuntimeUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeevaluationRuntimeEvaluation{
				client:            c.client,
				RuntimeEvaluation: oldObj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
			}
			newData := &RuntimeevaluationRuntimeEvaluation{
				client:            c.client,
				RuntimeEvaluation: newObj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeevaluationRuntimeEvaluation{
				client:            c.client,
				RuntimeEvaluation: obj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
			}

			var parent *RuntimeuserRuntimeUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", nc.Labels, nc.Labels["runtimeusers.runtimeuser.example.com"])
				parent, err = c.client.Runtimeuser().ForceReadRuntimeUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimeevaluationRuntimeEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RuntimeevaluationRuntimeEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeevaluations.runtimeevaluation.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RuntimeevaluationRuntimeEvaluation Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: obj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}

				var parent *RuntimeuserRuntimeUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", nc.Labels, nc.Labels["runtimeusers.runtimeuser.example.com"])
					parent, err = c.client.Runtimeuser().ForceReadRuntimeUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RuntimeevaluationRuntimeEvaluation Create New Informer")
		informer := informerruntimeevaluationexamplecomv1.NewRuntimeEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: obj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}

				var parent *RuntimeuserRuntimeUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", nc.Labels, nc.Labels["runtimeusers.runtimeuser.example.com"])
					parent, err = c.client.Runtimeuser().ForceReadRuntimeUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimeevaluationRuntimeEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RuntimeevaluationRuntimeEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeevaluations.runtimeevaluation.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RuntimeevaluationRuntimeEvaluation Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: oldObj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}
				newData := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: newObj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RuntimeevaluationRuntimeEvaluation Create New Informer")
		informer := informerruntimeevaluationexamplecomv1.NewRuntimeEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: oldObj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}
				newData := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: newObj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimeevaluationRuntimeEvaluation)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RuntimeevaluationRuntimeEvaluation")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeevaluations.runtimeevaluation.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RuntimeevaluationRuntimeEvaluation Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: obj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}

				var parent *RuntimeuserRuntimeUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", nc.Labels, nc.Labels["runtimeusers.runtimeuser.example.com"])
					parent, err = c.client.Runtimeuser().ForceReadRuntimeUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RuntimeevaluationRuntimeEvaluation Create New Informer")
		informer := informerruntimeevaluationexamplecomv1.NewRuntimeEvaluationInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeevaluationRuntimeEvaluation{
					client:            c.client,
					RuntimeEvaluation: obj.(*baseruntimeevaluationexamplecomv1.RuntimeEvaluation),
				}

				var parent *RuntimeuserRuntimeUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeusers.runtimeuser.example.com", nc.Labels, nc.Labels["runtimeusers.runtimeuser.example.com"])
					parent, err = c.client.Runtimeuser().ForceReadRuntimeUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) Quiz(name string) *runtimequizRuntimequizExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimequizes.runtimequiz.example.com"] = name
	return &runtimequizRuntimequizExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetQuiz calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) GetQuiz(ctx context.Context, displayName string) (result *RuntimequizRuntimeQuiz, err error) {
	hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", c.parentLabels, displayName)
	return c.client.Runtimequiz().GetRuntimeQuizByName(ctx, hashedName)
}

// AddQuiz calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) AddQuiz(ctx context.Context,
	objToCreate *baseruntimequizexamplecomv1.RuntimeQuiz) (result *RuntimequizRuntimeQuiz, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtimequiz().CreateRuntimeQuizByName(ctx, objToCreate)
}

// DeleteQuiz calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimeevaluationRuntimeevaluationExampleV1Chainer) DeleteQuiz(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", c.parentLabels, name)
	return c.client.Runtimequiz().DeleteRuntimeQuizByName(ctx, hashedName)
}

func (group *RuntimequizExampleV1) GetRuntimeQuizChildrenMap() map[string]baseruntimequizexamplecomv1.Child {
	return map[string]baseruntimequizexamplecomv1.Child{}
}

func (group *RuntimequizExampleV1) GetRuntimeQuizChild(grp, kind, name string) baseruntimequizexamplecomv1.Child {
	return baseruntimequizexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeQuizByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimequizExampleV1) GetRuntimeQuizByName(ctx context.Context, hashedName string) (*RuntimequizRuntimeQuiz, error) {
	key := "runtimequizes.runtimequiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRuntimeQuizByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimequizexamplecomv1.RuntimeQuiz)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRuntimeQuizByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimequizexamplecomv1.RuntimeQuiz).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRuntimeQuizByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimequizRuntimeQuiz{
					client:      group.client,
					RuntimeQuiz: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimequizRuntimeQuiz{
				client:      group.client,
				RuntimeQuiz: resWrCache.(*baseruntimequizexamplecomv1.RuntimeQuiz),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimequizExampleV1().
			RuntimeQuizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimequizRuntimeQuiz{
				client:      group.client,
				RuntimeQuiz: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRuntimeQuizByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get RuntimeQuizes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRuntimeQuizByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRuntimeQuizByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeQuizByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimequizExampleV1) ForceReadRuntimeQuizByName(ctx context.Context, hashedName string) (*RuntimequizRuntimeQuiz, error) {
	log.Debugf("[ForceReadRuntimeQuizByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimequizExampleV1().
			RuntimeQuizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRuntimeQuizByName] Failed to Get RuntimeQuizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get RuntimeQuizes: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRuntimeQuizByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRuntimeQuizByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRuntimeQuizByName] Executed Successfully :%s", hashedName)
			return &RuntimequizRuntimeQuiz{
				client:      group.client,
				RuntimeQuiz: result,
			}, nil
		}
	}
}

// DeleteRuntimeQuizByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimequizExampleV1) DeleteRuntimeQuizByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRuntimeQuizByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimequizexamplecomv1.RuntimeQuiz
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimequizExampleV1().
			RuntimeQuizes().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeQuizByName] Failed to get RuntimeQuizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get RuntimeQuizes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeQuizByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeQuizByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeQuizByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("runtimequizes.runtimequiz.example.com", hashedName, "runtimeanswers.runtimeanswer.example.com") {
		err := group.client.Runtimeanswer().DeleteRuntimeAnswerByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("runtimequizes.runtimequiz.example.com", hashedName, "runtimeanswers.runtimeanswer.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimequizExampleV1().
			RuntimeQuizes().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeQuizByName] failed to delete RuntimeQuizes: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete RuntimeQuizes: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeQuizByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeQuizByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeQuizByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimequizes.runtimequiz.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteRuntimeQuizByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimeevaluations.runtimeevaluation.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", parents, parentName)
	}
	RemoveChild("runtimeevaluations.runtimeevaluation.example.com", parentName, "runtimequizes.runtimequiz.example.com", hashedName)

	return nil
}

// CreateRuntimeQuizByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimequizExampleV1) CreateRuntimeQuizByName(ctx context.Context,
	objToCreate *baseruntimequizexamplecomv1.RuntimeQuiz) (*RuntimequizRuntimeQuiz, error) {
	log.Debugf("[CreateRuntimeQuizByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AnswersGvk = nil
	objToCreate.Spec.QuizGvk = nil

	var (
		retryCount int
		result     *baseruntimequizexamplecomv1.RuntimeQuiz
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimequizExampleV1().
			RuntimeQuizes().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRuntimeQuizByName] Failed to create RuntimeQuiz: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create RuntimeQuiz: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRuntimeQuizByName] context canceled while creating RuntimeQuiz: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateRuntimeQuizByName] RuntimeQuiz: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimequizExampleV1().RuntimeQuizes().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateRuntimeQuizByName] Unable to Get RuntimeQuiz %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateRuntimeQuizByName] found unexpected error while creating RuntimeQuiz: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRuntimeQuizByName] RuntimeQuiz: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimequizes.runtimequiz.example.com"); ok {
				log.Debugf("[CreateRuntimeQuizByName] RuntimeQuiz: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimeevaluations.runtimeevaluation.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimeevaluations.runtimeevaluation.example.com", parentHashedName, "runtimequizes.runtimequiz.example.com", objToCreate.Name)

	log.Debugf("[CreateRuntimeQuizByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimequizRuntimeQuiz{
		client:      group.client,
		RuntimeQuiz: result,
	}, nil
}

// SetRuntimeQuizStatusByName sets user defined status
func (group *RuntimequizExampleV1) SetRuntimeQuizStatusByName(ctx context.Context,
	objToUpdate *baseruntimequizexamplecomv1.RuntimeQuiz, status *baseruntimequizexamplecomv1.RuntimeQuizStatus) (*RuntimequizRuntimeQuiz, error) {
	log.Debugf("[SetRuntimeQuizStatusByName] Received objToUpdate:%s", objToUpdate.GetName())

	gvr := schema.GroupVersionResource{
		Group:    "runtimequiz.example.com",
		Version:  "v1",
		Resource: strings.ToLower("RuntimeQuizes"),
	}

	hashedName := objToUpdate.ObjectMeta.Name
	obj := baseruntimequizexamplecomv1.RuntimeQuiz{}
	obj.Kind = strings.ToLower("RuntimeQuizes")
	obj.APIVersion = "runtimequiz.example.com/v1"
	obj.ObjectMeta = objToUpdate.ObjectMeta
	obj.Status.Status = *status

	var mapInterface map[string]interface{}
	marshalledObj, _ := json.Marshal(&obj)
	json.Unmarshal(marshalledObj, &mapInterface)

	newCtx := context.TODO()
	retryCount := 0
	for {
		_, err := group.client.dynamicClient.Resource(gvr).UpdateStatus(ctx, &unstructured.Unstructured{Object: mapInterface}, metav1.UpdateOptions{})
		if err == nil {
			log.Debugf("[SetRuntimeQuizStatusByName] Updating status for RuntimeQuiz node %s successful", hashedName)
			break
		}

		log.Errorf("[SetRuntimeQuizStatusByName] Updating status for RuntimeQuiz node: %s failed with error %v. Retrying...", hashedName, err)

		updatedObj, err := group.ForceReadRuntimeQuizByName(newCtx, hashedName)
		if err == nil {
			obj.ObjectMeta = updatedObj.ObjectMeta
			marshalledObj, _ := json.Marshal(&obj)
			json.Unmarshal(marshalledObj, &mapInterface)
		}

		retryCount += 1
		if retryCount == maxRetryCount1SecSleep {
			log.Fatalf("[SetRuntimeQuizStatusByName] Max retry exceeded for updating status for RuntimeQuiz node: %s", hashedName)
			return nil, err
		}
		time.Sleep(time.Second)
	}

	/*
		if s, ok := subscriptionMap.Load("runtimequizes.runtimequiz.example.com"); ok {
			resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
			var objectToWrite *baseruntimequizexamplecomv1.RuntimeQuiz
			if inWrCache {
				objectToWrite = resWrCache.(*baseruntimequizexamplecomv1.RuntimeQuiz)
				objectToWrite.Status.Status = *status
			} else {
				// Object is not in write cache. Populate the write cache with last "known" object.
				// TBD: Is this right ???
				//      Can we expect ObjectToUpdate to the latest version of the object ?
				//      What if we received the object spec but only want to update the status ?
				//      Get on the object will return a object form cache if the cache has newer version.
				// 		So proceeding with assumption that if newer version is available, user will get the newer version anyways.
				objectToWrite = objToUpdate
				objToUpdate.Status.Status = *status
			}
			s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), objectToWrite)
		}
	*/
	return &RuntimequizRuntimeQuiz{
		client:      group.client,
		RuntimeQuiz: objToUpdate, // TBD: To be fixed to return back the "result"
	}, nil
}

// UpdateRuntimeQuizByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimequizExampleV1) UpdateRuntimeQuizByName(ctx context.Context,
	objToUpdate *baseruntimequizexamplecomv1.RuntimeQuiz) (*RuntimequizRuntimeQuiz, error) {
	log.Debugf("[UpdateRuntimeQuizByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtimequiz().GetRuntimeQuizByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimequizes.runtimequiz.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimequizexamplecomv1.RuntimeQuiz
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimequizExampleV1().
			RuntimeQuizes().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRuntimeQuizByName] Failed to patch RuntimeQuiz %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger RuntimeQuiz Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeQuizByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting RuntimeQuiz: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("RuntimeQuiz deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRuntimeQuizByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRuntimeQuizByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger RuntimeQuiz Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeQuizByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting RuntimeQuiz: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("RuntimeQuiz Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRuntimeQuizByName] Patch RuntimeQuiz Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimequizes.runtimequiz.example.com"); ok {
				log.Debugf("[UpdateRuntimeQuizByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRuntimeQuizByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimequizRuntimeQuiz{
		client:      group.client,
		RuntimeQuiz: result,
	}, nil
}

// ListRuntimeQuizes returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimequizExampleV1) ListRuntimeQuizes(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimequizRuntimeQuiz, err error) {
	key := "runtimequizes.runtimequiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimequizRuntimeQuiz, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimequizexamplecomv1.RuntimeQuiz)
			result[k] = &RuntimequizRuntimeQuiz{
				client:      group.client,
				RuntimeQuiz: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimequizExampleV1().
			RuntimeQuizes().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimequizRuntimeQuiz, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimequizRuntimeQuiz{
				client:      group.client,
				RuntimeQuiz: &item,
			}
		}
	}
	return
}

type RuntimequizRuntimeQuiz struct {
	client *Clientset
	*baseruntimequizexamplecomv1.RuntimeQuiz
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimequizRuntimeQuiz) Delete(ctx context.Context) error {
	err := obj.client.Runtimequiz().DeleteRuntimeQuizByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RuntimeQuiz = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimequizRuntimeQuiz) Update(ctx context.Context) error {
	result, err := obj.client.Runtimequiz().UpdateRuntimeQuizByName(ctx, obj.RuntimeQuiz)
	if err != nil {
		return err
	}
	obj.RuntimeQuiz = result.RuntimeQuiz
	return nil
}

// SetStatus sets user defined status
func (obj *RuntimequizRuntimeQuiz) SetStatus(ctx context.Context, status *baseruntimequizexamplecomv1.RuntimeQuizStatus) error {
	result, err := obj.client.Runtimequiz().SetRuntimeQuizStatusByName(ctx, obj.RuntimeQuiz, status)
	if err != nil {
		return err
	}
	obj.RuntimeQuiz = result.RuntimeQuiz
	return nil
}

// GetStatus to get user defined status
func (obj *RuntimequizRuntimeQuiz) GetStatus(ctx context.Context) (*baseruntimequizexamplecomv1.RuntimeQuizStatus, error) {
	getObj, err := obj.client.Runtimequiz().GetRuntimeQuizByName(ctx, obj.GetName())
	if err != nil {
		return nil, err
	}
	return &getObj.Status.Status, nil
}

// ClearStatus to clear user defined status
func (obj *RuntimequizRuntimeQuiz) ClearStatus(ctx context.Context) error {
	result, err := obj.client.Runtimequiz().SetRuntimeQuizStatusByName(ctx, obj.RuntimeQuiz, &baseruntimequizexamplecomv1.RuntimeQuizStatus{})
	if err != nil {
		return err
	}
	obj.RuntimeQuiz = result.RuntimeQuiz
	return nil
}

func (obj *RuntimequizRuntimeQuiz) GetParent(ctx context.Context) (result *RuntimeevaluationRuntimeEvaluation, err error) {
	hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", obj.Labels, obj.Labels["runtimeevaluations.runtimeevaluation.example.com"])
	return obj.client.Runtimeevaluation().GetRuntimeEvaluationByName(ctx, hashedName)
}

type RuntimequizRuntimeQuizAnswers struct {
	client  *Clientset
	Answers []baseruntimequizexamplecomv1.Child
}

func (n *RuntimequizRuntimeQuizAnswers) Next(ctx context.Context) (*RuntimeanswerRuntimeAnswer, error) {
	for index, child := range n.Answers {
		obj, err := n.client.Runtimeanswer().GetRuntimeAnswerByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Answers)-1 {
				n.Answers = nil
			} else {
				n.Answers = n.Answers[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllAnswersIter returns an iterator for all children of given type
func (obj *RuntimequizRuntimeQuiz) GetAllAnswersIter(ctx context.Context) (
	result RuntimequizRuntimeQuizAnswers) {
	result.client = obj.client
	for _, v := range GetChildren("runtimequizes.runtimequiz.example.com", obj.Name, "runtimeanswers.runtimeanswer.example.com") {
		result.Answers = append(result.Answers, baseruntimequizexamplecomv1.Child{
			Group: "runtimeanswer.example.com",
			Kind:  "RuntimeAnswer",
			Name:  v,
		})
	}
	return
}

// GetAllAnswers returns all children of a given type
func (obj *RuntimequizRuntimeQuiz) GetAllAnswers(ctx context.Context) (
	result []*RuntimeanswerRuntimeAnswer, err error) {
	for _, v := range GetChildren("runtimequizes.runtimequiz.example.com", obj.Name, "runtimeanswers.runtimeanswer.example.com") {
		l, err := obj.client.Runtimeanswer().GetRuntimeAnswerByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetAnswers returns child which has given displayName
func (obj *RuntimequizRuntimeQuiz) GetAnswers(ctx context.Context,
	displayName string) (result *RuntimeanswerRuntimeAnswer, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimequizes.runtimequiz.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeanswers.runtimeanswer.example.com", parentLabels, displayName)
	if IsChildExists("runtimequizes.runtimequiz.example.com", obj.Name, "runtimeanswers.runtimeanswer.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Runtimequiz.RuntimeQuiz", "Answers", displayName)
	}

	result, err = obj.client.Runtimeanswer().GetRuntimeAnswerByName(ctx, childHashName)
	return
}

// AddAnswers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RuntimequizRuntimeQuiz) AddAnswers(ctx context.Context,
	objToCreate *baseruntimeanswerexamplecomv1.RuntimeAnswer) (result *RuntimeanswerRuntimeAnswer, err error) {
	log.Debugf("[AddAnswers] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["runtimequizes.runtimequiz.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["runtimequizes.runtimequiz.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Runtimeanswer().CreateRuntimeAnswerByName(ctx, objToCreate)
	log.Debugf("[AddAnswers] RuntimeAnswer created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Runtimequiz().GetRuntimeQuizByName(ctx, obj.GetName())
	if getErr == nil {
		obj.RuntimeQuiz = updatedObj.RuntimeQuiz
	}
	log.Debugf("[AddAnswers] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteAnswers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RuntimequizRuntimeQuiz) DeleteAnswers(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteAnswers] Received for RuntimeAnswer object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["runtimequizes.runtimequiz.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("runtimeanswers.runtimeanswer.example.com", parentLabels, displayName)
	if IsChildExists("runtimequizes.runtimequiz.example.com", obj.Name, "runtimeanswers.runtimeanswer.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Runtimequiz.RuntimeQuiz", "Answers", displayName)
	}

	err = obj.client.Runtimeanswer().DeleteRuntimeAnswerByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteAnswers] RuntimeAnswer object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Runtimequiz().GetRuntimeQuizByName(ctx, obj.GetName())
	if err == nil {
		obj.RuntimeQuiz = updatedObj.RuntimeQuiz
	}
	return
}

// GetQuiz returns link of given type
func (obj *RuntimequizRuntimeQuiz) GetQuiz(ctx context.Context) (
	result *QuizQuiz, err error) {
	if obj.Spec.QuizGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Runtimequiz.RuntimeQuiz", "Quiz")
	}
	return obj.client.Quiz().GetQuizByName(ctx, obj.Spec.QuizGvk.Name)
}

// LinkQuiz links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *RuntimequizRuntimeQuiz) LinkQuiz(ctx context.Context,
	linkToAdd *QuizQuiz) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/quizGvk",
		Value: baseruntimequizexamplecomv1.Child{
			Group: "quiz.example.com",
			Kind:  "Quiz",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RuntimequizExampleV1().RuntimeQuizes().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.RuntimeQuiz = result
	return nil
}

// UnlinkQuiz unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *RuntimequizRuntimeQuiz) UnlinkQuiz(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/quizGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RuntimequizExampleV1().RuntimeQuizes().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.RuntimeQuiz = result
	return nil

}

type runtimequizRuntimequizExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimequizRuntimequizExampleV1Chainer) Subscribe() {
	key := "runtimequizes.runtimequiz.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimequizexamplecomv1.NewRuntimeQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimequizRuntimequizExampleV1Chainer) Unsubscribe() {
	key := "runtimequizes.runtimequiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimequizRuntimequizExampleV1Chainer) IsSubscribed() bool {
	key := "runtimequizes.runtimequiz.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimequizRuntimequizExampleV1Chainer) addCallback(obj *RuntimequizRuntimeQuiz) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimeevaluations.runtimeevaluation.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", obj.Labels, parentDisplayName)

	AddChild("runtimeevaluations.runtimeevaluation.example.com", parentHashName, "runtimequizes.runtimequiz.example.com", obj.Name)
}

func (c *runtimequizRuntimequizExampleV1Chainer) deleteCallback(obj *RuntimequizRuntimeQuiz) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimeevaluations.runtimeevaluation.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", obj.Labels, parentDisplayName)

	RemoveChild("runtimeevaluations.runtimeevaluation.example.com", parentHashName, "runtimequizes.runtimequiz.example.com", obj.Name)
}

func (c *runtimequizRuntimequizExampleV1Chainer) RegisterEventHandler(addCB func(obj *RuntimequizRuntimeQuiz), updateCB func(oldObj, newObj *RuntimequizRuntimeQuiz), deleteCB func(obj *RuntimequizRuntimeQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimequizRuntimeQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimequizes.runtimequiz.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimequizRuntimeQuiz")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimequizRuntimeQuiz, so creating a new one")
		informer = informerruntimequizexamplecomv1.NewRuntimeQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimequizRuntimeQuiz{
				client:      c.client,
				RuntimeQuiz: obj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
			}

			var parent *RuntimeevaluationRuntimeEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", nc.Labels, nc.Labels["runtimeevaluations.runtimeevaluation.example.com"])
				parent, err = c.client.Runtimeevaluation().ForceReadRuntimeEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimequizRuntimeQuiz{
				client:      c.client,
				RuntimeQuiz: oldObj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
			}
			newData := &RuntimequizRuntimeQuiz{
				client:      c.client,
				RuntimeQuiz: newObj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimequizRuntimeQuiz{
				client:      c.client,
				RuntimeQuiz: obj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
			}

			var parent *RuntimeevaluationRuntimeEvaluation
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", nc.Labels, nc.Labels["runtimeevaluations.runtimeevaluation.example.com"])
				parent, err = c.client.Runtimeevaluation().ForceReadRuntimeEvaluationByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimequizRuntimequizExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimequizRuntimeQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RuntimequizRuntimeQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimequizes.runtimequiz.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RuntimequizRuntimeQuiz Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: obj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}

				var parent *RuntimeevaluationRuntimeEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", nc.Labels, nc.Labels["runtimeevaluations.runtimeevaluation.example.com"])
					parent, err = c.client.Runtimeevaluation().ForceReadRuntimeEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RuntimequizRuntimeQuiz Create New Informer")
		informer := informerruntimequizexamplecomv1.NewRuntimeQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: obj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}

				var parent *RuntimeevaluationRuntimeEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", nc.Labels, nc.Labels["runtimeevaluations.runtimeevaluation.example.com"])
					parent, err = c.client.Runtimeevaluation().ForceReadRuntimeEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimequizRuntimequizExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimequizRuntimeQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RuntimequizRuntimeQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimequizes.runtimequiz.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RuntimequizRuntimeQuiz Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: oldObj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}
				newData := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: newObj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RuntimequizRuntimeQuiz Create New Informer")
		informer := informerruntimequizexamplecomv1.NewRuntimeQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: oldObj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}
				newData := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: newObj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimequizRuntimequizExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimequizRuntimeQuiz)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RuntimequizRuntimeQuiz")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimequizes.runtimequiz.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RuntimequizRuntimeQuiz Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: obj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}

				var parent *RuntimeevaluationRuntimeEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", nc.Labels, nc.Labels["runtimeevaluations.runtimeevaluation.example.com"])
					parent, err = c.client.Runtimeevaluation().ForceReadRuntimeEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RuntimequizRuntimeQuiz Create New Informer")
		informer := informerruntimequizexamplecomv1.NewRuntimeQuizInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimequizRuntimeQuiz{
					client:      c.client,
					RuntimeQuiz: obj.(*baseruntimequizexamplecomv1.RuntimeQuiz),
				}

				var parent *RuntimeevaluationRuntimeEvaluation
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimeevaluations.runtimeevaluation.example.com", nc.Labels, nc.Labels["runtimeevaluations.runtimeevaluation.example.com"])
					parent, err = c.client.Runtimeevaluation().ForceReadRuntimeEvaluationByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

// ClearStatus to clear user defined status
func (c *runtimequizRuntimequizExampleV1Chainer) ClearStatus(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", c.parentLabels, c.name)
	obj, err := c.client.Runtimequiz().GetRuntimeQuizByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Runtimequiz().SetRuntimeQuizStatusByName(ctx, obj.RuntimeQuiz, nil)
	return err
}

// GetStatus to get user defined status
func (c *runtimequizRuntimequizExampleV1Chainer) GetStatus(ctx context.Context) (result *baseruntimequizexamplecomv1.RuntimeQuizStatus, err error) {
	hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", c.parentLabels, c.name)
	obj, err := c.client.Runtimequiz().GetRuntimeQuizByName(ctx, hashedName)
	if err != nil {
		return nil, err
	}
	return &obj.Status.Status, nil
}

// SetStatus sets user defined status
func (c *runtimequizRuntimequizExampleV1Chainer) SetStatus(ctx context.Context, status *baseruntimequizexamplecomv1.RuntimeQuizStatus) (err error) {
	hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", c.parentLabels, c.name)
	obj, err := c.client.Runtimequiz().GetRuntimeQuizByName(ctx, hashedName)
	if err != nil {
		return err
	}
	_, err = c.client.Runtimequiz().SetRuntimeQuizStatusByName(ctx, obj.RuntimeQuiz, status)
	return err
}

func (c *runtimequizRuntimequizExampleV1Chainer) Answers(name string) *runtimeanswerRuntimeanswerExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["runtimeanswers.runtimeanswer.example.com"] = name
	return &runtimeanswerRuntimeanswerExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetAnswers calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *runtimequizRuntimequizExampleV1Chainer) GetAnswers(ctx context.Context, displayName string) (result *RuntimeanswerRuntimeAnswer, err error) {
	hashedName := helper.GetHashedName("runtimeanswers.runtimeanswer.example.com", c.parentLabels, displayName)
	return c.client.Runtimeanswer().GetRuntimeAnswerByName(ctx, hashedName)
}

// AddAnswers calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *runtimequizRuntimequizExampleV1Chainer) AddAnswers(ctx context.Context,
	objToCreate *baseruntimeanswerexamplecomv1.RuntimeAnswer) (result *RuntimeanswerRuntimeAnswer, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("runtimeanswers.runtimeanswer.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Runtimeanswer().CreateRuntimeAnswerByName(ctx, objToCreate)
}

// DeleteAnswers calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *runtimequizRuntimequizExampleV1Chainer) DeleteAnswers(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("runtimeanswers.runtimeanswer.example.com", c.parentLabels, name)
	return c.client.Runtimeanswer().DeleteRuntimeAnswerByName(ctx, hashedName)
}

func (group *RuntimeanswerExampleV1) GetRuntimeAnswerChildrenMap() map[string]baseruntimeanswerexamplecomv1.Child {
	return map[string]baseruntimeanswerexamplecomv1.Child{}
}

func (group *RuntimeanswerExampleV1) GetRuntimeAnswerChild(grp, kind, name string) baseruntimeanswerexamplecomv1.Child {
	return baseruntimeanswerexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRuntimeAnswerByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeanswerExampleV1) GetRuntimeAnswerByName(ctx context.Context, hashedName string) (*RuntimeanswerRuntimeAnswer, error) {
	key := "runtimeanswers.runtimeanswer.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRuntimeAnswerByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseruntimeanswerexamplecomv1.RuntimeAnswer)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRuntimeAnswerByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseruntimeanswerexamplecomv1.RuntimeAnswer).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRuntimeAnswerByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RuntimeanswerRuntimeAnswer{
					client:        group.client,
					RuntimeAnswer: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RuntimeanswerRuntimeAnswer{
				client:        group.client,
				RuntimeAnswer: resWrCache.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeanswerExampleV1().
			RuntimeAnswers().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RuntimeanswerRuntimeAnswer{
				client:        group.client,
				RuntimeAnswer: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRuntimeAnswerByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get RuntimeAnswers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRuntimeAnswerByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRuntimeAnswerByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRuntimeAnswerByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RuntimeanswerExampleV1) ForceReadRuntimeAnswerByName(ctx context.Context, hashedName string) (*RuntimeanswerRuntimeAnswer, error) {
	log.Debugf("[ForceReadRuntimeAnswerByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RuntimeanswerExampleV1().
			RuntimeAnswers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRuntimeAnswerByName] Failed to Get RuntimeAnswers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get RuntimeAnswers: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRuntimeAnswerByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRuntimeAnswerByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRuntimeAnswerByName] Executed Successfully :%s", hashedName)
			return &RuntimeanswerRuntimeAnswer{
				client:        group.client,
				RuntimeAnswer: result,
			}, nil
		}
	}
}

// DeleteRuntimeAnswerByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RuntimeanswerExampleV1) DeleteRuntimeAnswerByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRuntimeAnswerByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseruntimeanswerexamplecomv1.RuntimeAnswer
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeanswerExampleV1().
			RuntimeAnswers().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeAnswerByName] Failed to get RuntimeAnswers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get RuntimeAnswers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeAnswerByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeAnswerByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeAnswerByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RuntimeanswerExampleV1().
			RuntimeAnswers().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRuntimeAnswerByName] failed to delete RuntimeAnswers: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete RuntimeAnswers: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRuntimeAnswerByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRuntimeAnswerByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRuntimeAnswerByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("runtimeanswers.runtimeanswer.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteRuntimeAnswerByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["runtimequizes.runtimequiz.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("runtimequizes.runtimequiz.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("runtimequizes.runtimequiz.example.com", parents, parentName)
	}
	RemoveChild("runtimequizes.runtimequiz.example.com", parentName, "runtimeanswers.runtimeanswer.example.com", hashedName)

	return nil
}

// CreateRuntimeAnswerByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RuntimeanswerExampleV1) CreateRuntimeAnswerByName(ctx context.Context,
	objToCreate *baseruntimeanswerexamplecomv1.RuntimeAnswer) (*RuntimeanswerRuntimeAnswer, error) {
	log.Debugf("[CreateRuntimeAnswerByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.AnswerGvk = nil

	var (
		retryCount int
		result     *baseruntimeanswerexamplecomv1.RuntimeAnswer
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RuntimeanswerExampleV1().
			RuntimeAnswers().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRuntimeAnswerByName] Failed to create RuntimeAnswer: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create RuntimeAnswer: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRuntimeAnswerByName] context canceled while creating RuntimeAnswer: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateRuntimeAnswerByName] RuntimeAnswer: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.RuntimeanswerExampleV1().RuntimeAnswers().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateRuntimeAnswerByName] Unable to Get RuntimeAnswer %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateRuntimeAnswerByName] found unexpected error while creating RuntimeAnswer: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRuntimeAnswerByName] RuntimeAnswer: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("runtimeanswers.runtimeanswer.example.com"); ok {
				log.Debugf("[CreateRuntimeAnswerByName] RuntimeAnswer: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["runtimequizes.runtimequiz.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", objToCreate.GetLabels(), parentName)

	AddChild("runtimequizes.runtimequiz.example.com", parentHashedName, "runtimeanswers.runtimeanswer.example.com", objToCreate.Name)

	log.Debugf("[CreateRuntimeAnswerByName] Executed Successfully: %s", objToCreate.GetName())
	return &RuntimeanswerRuntimeAnswer{
		client:        group.client,
		RuntimeAnswer: result,
	}, nil
}

// UpdateRuntimeAnswerByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RuntimeanswerExampleV1) UpdateRuntimeAnswerByName(ctx context.Context,
	objToUpdate *baseruntimeanswerexamplecomv1.RuntimeAnswer) (*RuntimeanswerRuntimeAnswer, error) {
	log.Debugf("[UpdateRuntimeAnswerByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Runtimeanswer().GetRuntimeAnswerByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["runtimeanswers.runtimeanswer.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.ProvidedAnswer)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.ProvidedAnswer).IsNil() {
			patchValueProvidedAnswer := objToUpdate.Spec.ProvidedAnswer
			patchOpProvidedAnswer := PatchOp{
				Op:    "replace",
				Path:  "/spec/providedAnswer",
				Value: patchValueProvidedAnswer,
			}
			patch = append(patch, patchOpProvidedAnswer)
		}
	} else {
		patchValueProvidedAnswer := objToUpdate.Spec.ProvidedAnswer
		patchOpProvidedAnswer := PatchOp{
			Op:    "replace",
			Path:  "/spec/providedAnswer",
			Value: patchValueProvidedAnswer,
		}
		patch = append(patch, patchOpProvidedAnswer)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseruntimeanswerexamplecomv1.RuntimeAnswer
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RuntimeanswerExampleV1().
			RuntimeAnswers().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRuntimeAnswerByName] Failed to patch RuntimeAnswer %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger RuntimeAnswer Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRuntimeAnswerByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting RuntimeAnswer: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("RuntimeAnswer deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRuntimeAnswerByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRuntimeAnswerByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger RuntimeAnswer Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRuntimeAnswerByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting RuntimeAnswer: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("RuntimeAnswer Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRuntimeAnswerByName] Patch RuntimeAnswer Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("runtimeanswers.runtimeanswer.example.com"); ok {
				log.Debugf("[UpdateRuntimeAnswerByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRuntimeAnswerByName] Executed Successfully %s", objToUpdate.GetName())
	return &RuntimeanswerRuntimeAnswer{
		client:        group.client,
		RuntimeAnswer: result,
	}, nil
}

// ListRuntimeAnswers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RuntimeanswerExampleV1) ListRuntimeAnswers(ctx context.Context,
	opts metav1.ListOptions) (result []*RuntimeanswerRuntimeAnswer, err error) {
	key := "runtimeanswers.runtimeanswer.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RuntimeanswerRuntimeAnswer, len(items))
		for k, v := range items {
			item, _ := v.(*baseruntimeanswerexamplecomv1.RuntimeAnswer)
			result[k] = &RuntimeanswerRuntimeAnswer{
				client:        group.client,
				RuntimeAnswer: item,
			}
		}
	} else {
		list, err := group.client.baseClient.RuntimeanswerExampleV1().
			RuntimeAnswers().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RuntimeanswerRuntimeAnswer, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RuntimeanswerRuntimeAnswer{
				client:        group.client,
				RuntimeAnswer: &item,
			}
		}
	}
	return
}

type RuntimeanswerRuntimeAnswer struct {
	client *Clientset
	*baseruntimeanswerexamplecomv1.RuntimeAnswer
}

// Delete removes obj and all it's children from the database.
func (obj *RuntimeanswerRuntimeAnswer) Delete(ctx context.Context) error {
	err := obj.client.Runtimeanswer().DeleteRuntimeAnswerByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.RuntimeAnswer = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RuntimeanswerRuntimeAnswer) Update(ctx context.Context) error {
	result, err := obj.client.Runtimeanswer().UpdateRuntimeAnswerByName(ctx, obj.RuntimeAnswer)
	if err != nil {
		return err
	}
	obj.RuntimeAnswer = result.RuntimeAnswer
	return nil
}

func (obj *RuntimeanswerRuntimeAnswer) GetParent(ctx context.Context) (result *RuntimequizRuntimeQuiz, err error) {
	hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", obj.Labels, obj.Labels["runtimequizes.runtimequiz.example.com"])
	return obj.client.Runtimequiz().GetRuntimeQuizByName(ctx, hashedName)
}

// GetAnswer returns link of given type
func (obj *RuntimeanswerRuntimeAnswer) GetAnswer(ctx context.Context) (
	result *QuizchoiceQuizChoice, err error) {
	if obj.Spec.AnswerGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Runtimeanswer.RuntimeAnswer", "Answer")
	}
	return obj.client.Quizchoice().GetQuizChoiceByName(ctx, obj.Spec.AnswerGvk.Name)
}

// LinkAnswer links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *RuntimeanswerRuntimeAnswer) LinkAnswer(ctx context.Context,
	linkToAdd *QuizchoiceQuizChoice) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/answerGvk",
		Value: baseruntimeanswerexamplecomv1.Child{
			Group: "quizchoice.example.com",
			Kind:  "QuizChoice",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RuntimeanswerExampleV1().RuntimeAnswers().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.RuntimeAnswer = result
	return nil
}

// UnlinkAnswer unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *RuntimeanswerRuntimeAnswer) UnlinkAnswer(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/answerGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.RuntimeanswerExampleV1().RuntimeAnswers().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.RuntimeAnswer = result
	return nil

}

type runtimeanswerRuntimeanswerExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) Subscribe() {
	key := "runtimeanswers.runtimeanswer.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerruntimeanswerexamplecomv1.NewRuntimeAnswerInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) Unsubscribe() {
	key := "runtimeanswers.runtimeanswer.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) IsSubscribed() bool {
	key := "runtimeanswers.runtimeanswer.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) addCallback(obj *RuntimeanswerRuntimeAnswer) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimequizes.runtimequiz.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", obj.Labels, parentDisplayName)

	AddChild("runtimequizes.runtimequiz.example.com", parentHashName, "runtimeanswers.runtimeanswer.example.com", obj.Name)
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) deleteCallback(obj *RuntimeanswerRuntimeAnswer) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["runtimequizes.runtimequiz.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", obj.Labels, parentDisplayName)

	RemoveChild("runtimequizes.runtimequiz.example.com", parentHashName, "runtimeanswers.runtimeanswer.example.com", obj.Name)
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) RegisterEventHandler(addCB func(obj *RuntimeanswerRuntimeAnswer), updateCB func(oldObj, newObj *RuntimeanswerRuntimeAnswer), deleteCB func(obj *RuntimeanswerRuntimeAnswer)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RuntimeanswerRuntimeAnswer")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "runtimeanswers.runtimeanswer.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RuntimeanswerRuntimeAnswer")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RuntimeanswerRuntimeAnswer, so creating a new one")
		informer = informerruntimeanswerexamplecomv1.NewRuntimeAnswerInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RuntimeanswerRuntimeAnswer{
				client:        c.client,
				RuntimeAnswer: obj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
			}

			var parent *RuntimequizRuntimeQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", nc.Labels, nc.Labels["runtimequizes.runtimequiz.example.com"])
				parent, err = c.client.Runtimequiz().ForceReadRuntimeQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RuntimeanswerRuntimeAnswer{
				client:        c.client,
				RuntimeAnswer: oldObj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
			}
			newData := &RuntimeanswerRuntimeAnswer{
				client:        c.client,
				RuntimeAnswer: newObj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RuntimeanswerRuntimeAnswer{
				client:        c.client,
				RuntimeAnswer: obj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
			}

			var parent *RuntimequizRuntimeQuiz
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", nc.Labels, nc.Labels["runtimequizes.runtimequiz.example.com"])
				parent, err = c.client.Runtimequiz().ForceReadRuntimeQuizByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RuntimeanswerRuntimeAnswer)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RuntimeanswerRuntimeAnswer")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeanswers.runtimeanswer.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RuntimeanswerRuntimeAnswer Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: obj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}

				var parent *RuntimequizRuntimeQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", nc.Labels, nc.Labels["runtimequizes.runtimequiz.example.com"])
					parent, err = c.client.Runtimequiz().ForceReadRuntimeQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RuntimeanswerRuntimeAnswer Create New Informer")
		informer := informerruntimeanswerexamplecomv1.NewRuntimeAnswerInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: obj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}

				var parent *RuntimequizRuntimeQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", nc.Labels, nc.Labels["runtimequizes.runtimequiz.example.com"])
					parent, err = c.client.Runtimequiz().ForceReadRuntimeQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RuntimeanswerRuntimeAnswer)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RuntimeanswerRuntimeAnswer")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeanswers.runtimeanswer.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RuntimeanswerRuntimeAnswer Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: oldObj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}
				newData := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: newObj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RuntimeanswerRuntimeAnswer Create New Informer")
		informer := informerruntimeanswerexamplecomv1.NewRuntimeAnswerInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: oldObj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}
				newData := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: newObj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *runtimeanswerRuntimeanswerExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RuntimeanswerRuntimeAnswer)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RuntimeanswerRuntimeAnswer")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "runtimeanswers.runtimeanswer.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RuntimeanswerRuntimeAnswer Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: obj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}

				var parent *RuntimequizRuntimeQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", nc.Labels, nc.Labels["runtimequizes.runtimequiz.example.com"])
					parent, err = c.client.Runtimequiz().ForceReadRuntimeQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RuntimeanswerRuntimeAnswer Create New Informer")
		informer := informerruntimeanswerexamplecomv1.NewRuntimeAnswerInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RuntimeanswerRuntimeAnswer{
					client:        c.client,
					RuntimeAnswer: obj.(*baseruntimeanswerexamplecomv1.RuntimeAnswer),
				}

				var parent *RuntimequizRuntimeQuiz
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("runtimequizes.runtimequiz.example.com", nc.Labels, nc.Labels["runtimequizes.runtimequiz.example.com"])
					parent, err = c.client.Runtimequiz().ForceReadRuntimeQuizByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}
