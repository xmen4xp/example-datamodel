// Code generated by nexus. DO NOT EDIT.

// Nexus client is a shim layer working over k8s API meant to simplify graph operation on nexus nodes.
// Features of nexus client:
// - create/get/update/delete/list of nexus nodes,
// - name hashing to avoid name collision between objects with same name but different parents,
// - ability to get, create and delete child of given parent object,
// - ability to add link and remove link to given object,
// - recursive delete of object and all it's children.
// To initialize client use NewForConfig function with Rest Config as a parameter. After that you can start using
// nexus client. You can check example in: https://gitlab.eng.vmware.com/nsx-allspark_users/nexus-sdk/docs/-/tree/master/example/crudapp

package nexus_client

import (
	"context"
	"encoding/json"
	customerrors "errors"
	"fmt"
	"os"
	"reflect"
	"strconv"
	"sync"
	"time"

	"github.com/sirupsen/logrus"
	"k8s.io/apimachinery/pkg/api/errors"
	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
	types "k8s.io/apimachinery/pkg/types"
	"k8s.io/client-go/dynamic"
	"k8s.io/client-go/rest"
	cache "k8s.io/client-go/tools/cache"

	baseClientset "example/build/client/clientset/versioned"
	fakeBaseClienset "example/build/client/clientset/versioned/fake"
	"example/build/common"
	"example/build/helper"

	baseconfigexamplecomv1 "example/build/apis/config.example.com/v1"
	baseinterestexamplecomv1 "example/build/apis/interest.example.com/v1"
	baserootexamplecomv1 "example/build/apis/root.example.com/v1"
	basetenantexamplecomv1 "example/build/apis/tenant.example.com/v1"
	baseuserexamplecomv1 "example/build/apis/user.example.com/v1"
	basewannaexamplecomv1 "example/build/apis/wanna.example.com/v1"

	informerconfigexamplecomv1 "example/build/client/informers/externalversions/config.example.com/v1"
	informerinterestexamplecomv1 "example/build/client/informers/externalversions/interest.example.com/v1"
	informerrootexamplecomv1 "example/build/client/informers/externalversions/root.example.com/v1"
	informertenantexamplecomv1 "example/build/client/informers/externalversions/tenant.example.com/v1"
	informeruserexamplecomv1 "example/build/client/informers/externalversions/user.example.com/v1"
	informerwannaexamplecomv1 "example/build/client/informers/externalversions/wanna.example.com/v1"
)

var log = logrus.New()

const maxRetryCount = 60
const sleepTime = 5
const maxRetryCount1SecSleep = 300

const ownershipAnnotation string = "Ownership"

// informerResyncPeriod is in second, default value is 10 Hrs(36000 Sec). INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
var informerResyncPeriod time.Duration = 36000

type Clientset struct {
	baseClient        baseClientset.Interface
	dynamicClient     *dynamic.DynamicClient
	rootExampleV1     *RootExampleV1
	tenantExampleV1   *TenantExampleV1
	configExampleV1   *ConfigExampleV1
	userExampleV1     *UserExampleV1
	wannaExampleV1    *WannaExampleV1
	interestExampleV1 *InterestExampleV1
}

type subscription struct {
	informer          cache.SharedIndexInformer
	stop              chan struct{}
	WriteCacheObjects *sync.Map
}

// subscriptionMap will store crd string as key and value as subscription type,
// for example key="roots.orgchart.vmware.org" and value=subscription{}
var subscriptionMap = sync.Map{}

func subscribe(key string, informer cache.SharedIndexInformer) {
	s := subscription{
		informer:          informer,
		stop:              make(chan struct{}),
		WriteCacheObjects: &sync.Map{},
	}
	go s.informer.Run(s.stop)
	subscriptionMap.Store(key, s)
}

func (c *Clientset) SubscribeAll() {
	var key string

	key = "roots.root.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootexamplecomv1.NewRootInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "tenants.tenant.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenantexamplecomv1.NewTenantInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "configs.config.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigexamplecomv1.NewConfigInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "users.user.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informeruserexamplecomv1.NewUserInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "wannas.wanna.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerwannaexamplecomv1.NewWannaInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

	key = "interests.interest.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerinterestexamplecomv1.NewInterestInformer(c.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}

}

func (c *Clientset) UnsubscribeAll() {
	subscriptionMap.Range(func(key, s interface{}) bool {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
		return true
	})
}

// NewForConfig returns Client which can be which can be used to connect to database
func NewForConfig(config *rest.Config) (*Clientset, error) {
	baseClient, err := baseClientset.NewForConfig(config)
	if err != nil {
		return nil, err
	}

	customFormatter := new(logrus.TextFormatter)
	customFormatter.TimestampFormat = "2006-01-02 15:04:05"
	log.SetFormatter(customFormatter)
	customFormatter.FullTimestamp = true
	if os.Getenv("NEXUS_LOG_LEVEL") == "debug" {
		log.SetLevel(logrus.DebugLevel)
		log.Debug("Nexus debug log enabled")
	}

	// INFORMER_RESYNC_PERIOD is os env to set Resync Period for informers
	stringResyncPeriod := os.Getenv("INFORMER_RESYNC_PERIOD")
	if stringResyncPeriod != "" {
		intResyncPeriod, err := strconv.Atoi(stringResyncPeriod)
		if err != nil {
			log.Errorf("env INFORMER_RESYNC_PERIOD is not set with correct value")
		} else {
			informerResyncPeriod = time.Duration(intResyncPeriod)
			log.Debugf("Resync Period for informers is set to %+v second", informerResyncPeriod)
		}
	}

	client := &Clientset{}
	client.baseClient = baseClient
	client.dynamicClient, _ = dynamic.NewForConfig(config) // TBD: check and react for error
	client.rootExampleV1 = newRootExampleV1(client)
	client.tenantExampleV1 = newTenantExampleV1(client)
	client.configExampleV1 = newConfigExampleV1(client)
	client.userExampleV1 = newUserExampleV1(client)
	client.wannaExampleV1 = newWannaExampleV1(client)
	client.interestExampleV1 = newInterestExampleV1(client)

	return client, nil
}

// NewFakeClient creates simple client which can be used for unit tests
func NewFakeClient() *Clientset {
	client := &Clientset{}
	client.baseClient = fakeBaseClienset.NewSimpleClientset()
	client.rootExampleV1 = newRootExampleV1(client)
	client.tenantExampleV1 = newTenantExampleV1(client)
	client.configExampleV1 = newConfigExampleV1(client)
	client.userExampleV1 = newUserExampleV1(client)
	client.wannaExampleV1 = newWannaExampleV1(client)
	client.interestExampleV1 = newInterestExampleV1(client)

	return client
}

type PatchOp struct {
	Op    string      `json:"op"`
	Path  string      `json:"path"`
	Value interface{} `json:"value,omitempty"`
}

type Patch []PatchOp

func (p Patch) Marshal() ([]byte, error) {
	return json.Marshal(p)
}

func (c *Clientset) Root() *RootExampleV1 {
	return c.rootExampleV1
}
func (c *Clientset) Tenant() *TenantExampleV1 {
	return c.tenantExampleV1
}
func (c *Clientset) Config() *ConfigExampleV1 {
	return c.configExampleV1
}
func (c *Clientset) User() *UserExampleV1 {
	return c.userExampleV1
}
func (c *Clientset) Wanna() *WannaExampleV1 {
	return c.wannaExampleV1
}
func (c *Clientset) Interest() *InterestExampleV1 {
	return c.interestExampleV1
}

type RootExampleV1 struct {
	client *Clientset
}

func newRootExampleV1(client *Clientset) *RootExampleV1 {
	return &RootExampleV1{
		client: client,
	}
}

type TenantExampleV1 struct {
	client *Clientset
}

func newTenantExampleV1(client *Clientset) *TenantExampleV1 {
	return &TenantExampleV1{
		client: client,
	}
}

type ConfigExampleV1 struct {
	client *Clientset
}

func newConfigExampleV1(client *Clientset) *ConfigExampleV1 {
	return &ConfigExampleV1{
		client: client,
	}
}

type UserExampleV1 struct {
	client *Clientset
}

func newUserExampleV1(client *Clientset) *UserExampleV1 {
	return &UserExampleV1{
		client: client,
	}
}

type WannaExampleV1 struct {
	client *Clientset
}

func newWannaExampleV1(client *Clientset) *WannaExampleV1 {
	return &WannaExampleV1{
		client: client,
	}
}

type InterestExampleV1 struct {
	client *Clientset
}

func newInterestExampleV1(client *Clientset) *InterestExampleV1 {
	return &InterestExampleV1{
		client: client,
	}
}

func (group *RootExampleV1) GetRootChildrenMap() map[string]baserootexamplecomv1.Child {
	return map[string]baserootexamplecomv1.Child{}
}

func (group *RootExampleV1) GetRootChild(grp, kind, name string) baserootexamplecomv1.Child {
	return baserootexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetRootByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) GetRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetRootByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baserootexamplecomv1.Root)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetRootByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baserootexamplecomv1.Root).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetRootByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &RootRoot{
					client: group.client,
					Root:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &RootRoot{
				client: group.client,
				Root:   resWrCache.(*baserootexamplecomv1.Root),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetRootByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetRootByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadRootByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) ForceReadRootByName(ctx context.Context, hashedName string) (*RootRoot, error) {
	log.Debugf("[ForceReadRootByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadRootByName] Failed to Get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Roots: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadRootByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadRootByName] Executed Successfully :%s", hashedName)
			return &RootRoot{
				client: group.client,
				Root:   result,
			}, nil
		}
	}
}

// DeleteRootByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *RootExampleV1) DeleteRootByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteRootByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baserootexamplecomv1.Root
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] Failed to get Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("roots.root.example.com", hashedName, "tenants.tenant.example.com") {
		err := group.client.Tenant().DeleteTenantByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("roots.root.example.com", hashedName, "tenants.tenant.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			RootExampleV1().
			Roots().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteRootByName] failed to delete Roots: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Roots: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteRootByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteRootByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteRootByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	return nil
}

// CreateRootByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *RootExampleV1) CreateRootByName(ctx context.Context,
	objToCreate *baserootexamplecomv1.Root) (*RootRoot, error) {
	log.Debugf("[CreateRootByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.TenantGvk = nil

	var (
		retryCount int
		result     *baserootexamplecomv1.Root
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateRootByName] Failed to create Root: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Root: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateRootByName] context canceled while creating Root: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[CreateRootByName] found unexpected error while creating Root: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateRootByName] Root: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				log.Debugf("[CreateRootByName] Root: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	log.Debugf("[CreateRootByName] Executed Successfully: %s", objToCreate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// UpdateRootByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *RootExampleV1) UpdateRootByName(ctx context.Context,
	objToUpdate *baserootexamplecomv1.Root) (*RootRoot, error) {
	log.Debugf("[UpdateRootByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Root().GetRootByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["roots.root.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baserootexamplecomv1.Root
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			RootExampleV1().
			Roots().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateRootByName] Failed to patch Root %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Root: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Root deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateRootByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateRootByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Root Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteRootByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Root: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Root Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateRootByName] Patch Root Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("roots.root.example.com"); ok {
				log.Debugf("[UpdateRootByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateRootByName] Executed Successfully %s", objToUpdate.GetName())
	return &RootRoot{
		client: group.client,
		Root:   result,
	}, nil
}

// ListRoots returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *RootExampleV1) ListRoots(ctx context.Context,
	opts metav1.ListOptions) (result []*RootRoot, err error) {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*RootRoot, len(items))
		for k, v := range items {
			item, _ := v.(*baserootexamplecomv1.Root)
			result[k] = &RootRoot{
				client: group.client,
				Root:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.RootExampleV1().
			Roots().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*RootRoot, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &RootRoot{
				client: group.client,
				Root:   &item,
			}
		}
	}
	return
}

type RootRoot struct {
	client *Clientset
	*baserootexamplecomv1.Root
}

// Delete removes obj and all it's children from the database.
func (obj *RootRoot) Delete(ctx context.Context) error {
	err := obj.client.Root().DeleteRootByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Root = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *RootRoot) Update(ctx context.Context) error {
	result, err := obj.client.Root().UpdateRootByName(ctx, obj.Root)
	if err != nil {
		return err
	}
	obj.Root = result.Root
	return nil
}

// GetRootRoot calculates the hashed name based on parents and
// returns given object
func (c *Clientset) GetRootRoot(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", nil, helper.DEFAULT_KEY)
	return c.Root().GetRootByName(ctx, hashedName)
}

func (c *Clientset) RootRoot() *rootRootExampleV1Chainer {
	parentLabels := make(map[string]string)
	parentLabels["roots.root.example.com"] = helper.DEFAULT_KEY
	return &rootRootExampleV1Chainer{
		client:       c,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// AddRootRoot calculates hashed name of the object based on
// parents names and creates it. objToCreate.Name is changed to the hashed name. Original name (helper.DEFAULT_KEY) is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *Clientset) AddRootRoot(ctx context.Context,
	objToCreate *baserootexamplecomv1.Root) (result *RootRoot, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), nil, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.Root().CreateRootByName(ctx, objToCreate)
}

// DeleteRootRoot calculates hashedName of object based on
// parents and deletes given object
func (c *Clientset) DeleteRootRoot(ctx context.Context) (err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", nil, helper.DEFAULT_KEY)
	return c.Root().DeleteRootByName(ctx, hashedName)
}

type RootRootTenant struct {
	client *Clientset
	Tenant []baserootexamplecomv1.Child
}

func (n *RootRootTenant) Next(ctx context.Context) (*TenantTenant, error) {
	for index, child := range n.Tenant {
		obj, err := n.client.Tenant().GetTenantByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Tenant)-1 {
				n.Tenant = nil
			} else {
				n.Tenant = n.Tenant[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllTenantIter returns an iterator for all children of given type
func (obj *RootRoot) GetAllTenantIter(ctx context.Context) (
	result RootRootTenant) {
	result.client = obj.client
	for _, v := range GetChildren("roots.root.example.com", obj.Name, "tenants.tenant.example.com") {
		result.Tenant = append(result.Tenant, baserootexamplecomv1.Child{
			Group: "tenant.example.com",
			Kind:  "Tenant",
			Name:  v,
		})
	}
	return
}

// GetAllTenant returns all children of a given type
func (obj *RootRoot) GetAllTenant(ctx context.Context) (
	result []*TenantTenant, err error) {
	for _, v := range GetChildren("roots.root.example.com", obj.Name, "tenants.tenant.example.com") {
		l, err := obj.client.Tenant().GetTenantByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetTenant returns child which has given displayName
func (obj *RootRoot) GetTenant(ctx context.Context,
	displayName string) (result *TenantTenant, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["roots.root.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("tenants.tenant.example.com", parentLabels, displayName)
	if IsChildExists("roots.root.example.com", obj.Name, "tenants.tenant.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Root.Root", "Tenant", displayName)
	}

	result, err = obj.client.Tenant().GetTenantByName(ctx, childHashName)
	return
}

// AddTenant calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *RootRoot) AddTenant(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (result *TenantTenant, err error) {
	log.Debugf("[AddTenant] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["roots.root.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["roots.root.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Tenant().CreateTenantByName(ctx, objToCreate)
	log.Debugf("[AddTenant] Tenant created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Root = updatedObj.Root
	}
	log.Debugf("[AddTenant] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteTenant calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *RootRoot) DeleteTenant(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteTenant] Received for Tenant object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["roots.root.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("tenants.tenant.example.com", parentLabels, displayName)
	if IsChildExists("roots.root.example.com", obj.Name, "tenants.tenant.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Root.Root", "Tenant", displayName)
	}

	err = obj.client.Tenant().DeleteTenantByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteTenant] Tenant object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Root().GetRootByName(ctx, obj.GetName())
	if err == nil {
		obj.Root = updatedObj.Root
	}
	return
}

type rootRootExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *rootRootExampleV1Chainer) Subscribe() {
	key := "roots.root.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

	}
}

func (c *rootRootExampleV1Chainer) Unsubscribe() {
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *rootRootExampleV1Chainer) IsSubscribed() bool {
	key := "roots.root.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *rootRootExampleV1Chainer) RegisterEventHandler(addCB func(obj *RootRoot), updateCB func(oldObj, newObj *RootRoot), deleteCB func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "roots.root.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for RootRoot")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for RootRoot, so creating a new one")
		informer = informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &RootRoot{
				client: c.client,
				Root:   oldObj.(*baserootexamplecomv1.Root),
			}
			newData := &RootRoot{
				client: c.client,
				Root:   newObj.(*baserootexamplecomv1.Root),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &RootRoot{
				client: c.client,
				Root:   obj.(*baserootexamplecomv1.Root),
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterAddCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "roots.root.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] RootRoot Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] RootRoot Create New Informer")
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "roots.root.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] RootRoot Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootRoot{
					client: c.client,
					Root:   oldObj.(*baserootexamplecomv1.Root),
				}
				newData := &RootRoot{
					client: c.client,
					Root:   newObj.(*baserootexamplecomv1.Root),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] RootRoot Create New Informer")
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &RootRoot{
					client: c.client,
					Root:   oldObj.(*baserootexamplecomv1.Root),
				}
				newData := &RootRoot{
					client: c.client,
					Root:   newObj.(*baserootexamplecomv1.Root),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *RootRoot)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for RootRoot")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "roots.root.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] RootRoot Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] RootRoot Create New Informer")
		informer := informerrootexamplecomv1.NewRootInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &RootRoot{
					client: c.client,
					Root:   obj.(*baserootexamplecomv1.Root),
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *rootRootExampleV1Chainer) Tenant(name string) *tenantTenantExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["tenants.tenant.example.com"] = name
	return &tenantTenantExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetTenant calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *rootRootExampleV1Chainer) GetTenant(ctx context.Context, displayName string) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, displayName)
	return c.client.Tenant().GetTenantByName(ctx, hashedName)
}

// AddTenant calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *rootRootExampleV1Chainer) AddTenant(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (result *TenantTenant, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Tenant().CreateTenantByName(ctx, objToCreate)
}

// DeleteTenant calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *rootRootExampleV1Chainer) DeleteTenant(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("tenants.tenant.example.com", c.parentLabels, name)
	return c.client.Tenant().DeleteTenantByName(ctx, hashedName)
}

func (group *TenantExampleV1) GetTenantChildrenMap() map[string]basetenantexamplecomv1.Child {
	return map[string]basetenantexamplecomv1.Child{}
}

func (group *TenantExampleV1) GetTenantChild(grp, kind, name string) basetenantexamplecomv1.Child {
	return basetenantexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetTenantByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) GetTenantByName(ctx context.Context, hashedName string) (*TenantTenant, error) {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetTenantByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basetenantexamplecomv1.Tenant)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetTenantByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basetenantexamplecomv1.Tenant).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetTenantByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &TenantTenant{
					client: group.client,
					Tenant: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &TenantTenant{
				client: group.client,
				Tenant: resWrCache.(*basetenantexamplecomv1.Tenant),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &TenantTenant{
				client: group.client,
				Tenant: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetTenantByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Tenants: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetTenantByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetTenantByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadTenantByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) ForceReadTenantByName(ctx context.Context, hashedName string) (*TenantTenant, error) {
	log.Debugf("[ForceReadTenantByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadTenantByName] Failed to Get Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Tenants: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadTenantByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadTenantByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadTenantByName] Executed Successfully :%s", hashedName)
			return &TenantTenant{
				client: group.client,
				Tenant: result,
			}, nil
		}
	}
}

// DeleteTenantByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *TenantExampleV1) DeleteTenantByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteTenantByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basetenantexamplecomv1.Tenant
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteTenantByName] Failed to get Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Tenants: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteTenantByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteTenantByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteTenantByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("tenants.tenant.example.com", hashedName, "configs.config.example.com") {
		err := group.client.Config().DeleteConfigByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("tenants.tenant.example.com", hashedName, "configs.config.example.com", child)
	}

	for _, child := range GetChildren("tenants.tenant.example.com", hashedName, "interests.interest.example.com") {
		err := group.client.Interest().DeleteInterestByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("tenants.tenant.example.com", hashedName, "interests.interest.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteTenantByName] failed to delete Tenants: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Tenants: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteTenantByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteTenantByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteTenantByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteTenantByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("roots.root.example.com", parents, parentName)
	}
	RemoveChild("roots.root.example.com", parentName, "tenants.tenant.example.com", hashedName)

	return nil
}

// CreateTenantByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *TenantExampleV1) CreateTenantByName(ctx context.Context,
	objToCreate *basetenantexamplecomv1.Tenant) (*TenantTenant, error) {
	log.Debugf("[CreateTenantByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.ConfigGvk = nil
	objToCreate.Spec.InterestGvk = nil

	var (
		retryCount int
		result     *basetenantexamplecomv1.Tenant
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateTenantByName] Failed to create Tenant: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Tenant: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateTenantByName] context canceled while creating Tenant: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateTenantByName] Tenant: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.TenantExampleV1().Tenants().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateTenantByName] Unable to Get Tenant %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateTenantByName] found unexpected error while creating Tenant: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateTenantByName] Tenant: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				log.Debugf("[CreateTenantByName] Tenant: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["roots.root.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("roots.root.example.com", objToCreate.GetLabels(), parentName)

	AddChild("roots.root.example.com", parentHashedName, "tenants.tenant.example.com", objToCreate.Name)

	log.Debugf("[CreateTenantByName] Executed Successfully: %s", objToCreate.GetName())
	return &TenantTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// UpdateTenantByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *TenantExampleV1) UpdateTenantByName(ctx context.Context,
	objToUpdate *basetenantexamplecomv1.Tenant) (*TenantTenant, error) {
	log.Debugf("[UpdateTenantByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Tenant().GetTenantByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["tenants.tenant.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basetenantexamplecomv1.Tenant
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			TenantExampleV1().
			Tenants().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateTenantByName] Failed to patch Tenant %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Tenant Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteTenantByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Tenant: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Tenant deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateTenantByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateTenantByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Tenant Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteTenantByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Tenant: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Tenant Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateTenantByName] Patch Tenant Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("tenants.tenant.example.com"); ok {
				log.Debugf("[UpdateTenantByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateTenantByName] Executed Successfully %s", objToUpdate.GetName())
	return &TenantTenant{
		client: group.client,
		Tenant: result,
	}, nil
}

// ListTenants returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *TenantExampleV1) ListTenants(ctx context.Context,
	opts metav1.ListOptions) (result []*TenantTenant, err error) {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*TenantTenant, len(items))
		for k, v := range items {
			item, _ := v.(*basetenantexamplecomv1.Tenant)
			result[k] = &TenantTenant{
				client: group.client,
				Tenant: item,
			}
		}
	} else {
		list, err := group.client.baseClient.TenantExampleV1().
			Tenants().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*TenantTenant, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &TenantTenant{
				client: group.client,
				Tenant: &item,
			}
		}
	}
	return
}

type TenantTenant struct {
	client *Clientset
	*basetenantexamplecomv1.Tenant
}

// Delete removes obj and all it's children from the database.
func (obj *TenantTenant) Delete(ctx context.Context) error {
	err := obj.client.Tenant().DeleteTenantByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Tenant = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *TenantTenant) Update(ctx context.Context) error {
	result, err := obj.client.Tenant().UpdateTenantByName(ctx, obj.Tenant)
	if err != nil {
		return err
	}
	obj.Tenant = result.Tenant
	return nil
}

func (obj *TenantTenant) GetParent(ctx context.Context) (result *RootRoot, err error) {
	hashedName := helper.GetHashedName("roots.root.example.com", obj.Labels, obj.Labels["roots.root.example.com"])
	return obj.client.Root().GetRootByName(ctx, hashedName)
}

// GetConfig returns child of given type
func (obj *TenantTenant) GetConfig(ctx context.Context) (
	result *ConfigConfig, err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "configs.config.example.com")
	if len(children) == 0 {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Config")
	}
	return obj.client.Config().GetConfigByName(ctx, children[0])
}

// AddConfig calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenantTenant) AddConfig(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (result *ConfigConfig, err error) {
	log.Debugf("[AddConfig] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.tenant.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.tenant.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		if objToCreate.GetName() == "" {
			objToCreate.SetName(helper.DEFAULT_KEY)
		}
		if objToCreate.GetName() != helper.DEFAULT_KEY {
			return nil, NewSingletonNameError(objToCreate.GetName())
		}
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Config().CreateConfigByName(ctx, objToCreate)
	log.Debugf("[AddConfig] Config created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	log.Debugf("[AddConfig] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenantTenant) DeleteConfig(ctx context.Context) (err error) {
	children := GetChildren("tenants.tenant.example.com", obj.Name, "configs.config.example.com")
	if len(children) > 1 {
		log.Panicf("[ DeleteConfig] Cannot have more than 1 unnamed link for object %s. Current children %d", obj.GetName(), len(children))
	}

	if len(children) > 0 {
		err = obj.client.
			Config().DeleteConfigByName(ctx, children[0])
		if err != nil {
			return err
		}
	}

	updatedObj, err := obj.client.
		Tenant().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

type TenantTenantInterest struct {
	client   *Clientset
	Interest []basetenantexamplecomv1.Child
}

func (n *TenantTenantInterest) Next(ctx context.Context) (*InterestInterest, error) {
	for index, child := range n.Interest {
		obj, err := n.client.Interest().GetInterestByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Interest)-1 {
				n.Interest = nil
			} else {
				n.Interest = n.Interest[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllInterestIter returns an iterator for all children of given type
func (obj *TenantTenant) GetAllInterestIter(ctx context.Context) (
	result TenantTenantInterest) {
	result.client = obj.client
	for _, v := range GetChildren("tenants.tenant.example.com", obj.Name, "interests.interest.example.com") {
		result.Interest = append(result.Interest, basetenantexamplecomv1.Child{
			Group: "interest.example.com",
			Kind:  "Interest",
			Name:  v,
		})
	}
	return
}

// GetAllInterest returns all children of a given type
func (obj *TenantTenant) GetAllInterest(ctx context.Context) (
	result []*InterestInterest, err error) {
	for _, v := range GetChildren("tenants.tenant.example.com", obj.Name, "interests.interest.example.com") {
		l, err := obj.client.Interest().GetInterestByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetInterest returns child which has given displayName
func (obj *TenantTenant) GetInterest(ctx context.Context,
	displayName string) (result *InterestInterest, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["tenants.tenant.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("interests.interest.example.com", parentLabels, displayName)
	if IsChildExists("tenants.tenant.example.com", obj.Name, "interests.interest.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Interest", displayName)
	}

	result, err = obj.client.Interest().GetInterestByName(ctx, childHashName)
	return
}

// AddInterest calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *TenantTenant) AddInterest(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (result *InterestInterest, err error) {
	log.Debugf("[AddInterest] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["tenants.tenant.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["tenants.tenant.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Interest().CreateInterestByName(ctx, objToCreate)
	log.Debugf("[AddInterest] Interest created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Tenant = updatedObj.Tenant
	}
	log.Debugf("[AddInterest] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteInterest calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *TenantTenant) DeleteInterest(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteInterest] Received for Interest object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["tenants.tenant.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("interests.interest.example.com", parentLabels, displayName)
	if IsChildExists("tenants.tenant.example.com", obj.Name, "interests.interest.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Tenant.Tenant", "Interest", displayName)
	}

	err = obj.client.Interest().DeleteInterestByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteInterest] Interest object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Tenant().GetTenantByName(ctx, obj.GetName())
	if err == nil {
		obj.Tenant = updatedObj.Tenant
	}
	return
}

type tenantTenantExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *tenantTenantExampleV1Chainer) Subscribe() {
	key := "tenants.tenant.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *tenantTenantExampleV1Chainer) Unsubscribe() {
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *tenantTenantExampleV1Chainer) IsSubscribed() bool {
	key := "tenants.tenant.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *tenantTenantExampleV1Chainer) addCallback(obj *TenantTenant) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	AddChild("roots.root.example.com", parentHashName, "tenants.tenant.example.com", obj.Name)
}

func (c *tenantTenantExampleV1Chainer) deleteCallback(obj *TenantTenant) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["roots.root.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("roots.root.example.com", obj.Labels, parentDisplayName)

	RemoveChild("roots.root.example.com", parentHashName, "tenants.tenant.example.com", obj.Name)
}

func (c *tenantTenantExampleV1Chainer) RegisterEventHandler(addCB func(obj *TenantTenant), updateCB func(oldObj, newObj *TenantTenant), deleteCB func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "tenants.tenant.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for TenantTenant")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for TenantTenant, so creating a new one")
		informer = informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &TenantTenant{
				client: c.client,
				Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
			}
			newData := &TenantTenant{
				client: c.client,
				Tenant: newObj.(*basetenantexamplecomv1.Tenant),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &TenantTenant{
				client: c.client,
				Tenant: obj.(*basetenantexamplecomv1.Tenant),
			}

			var parent *RootRoot
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
				parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterAddCallback(cbfn func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "tenants.tenant.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] TenantTenant Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] TenantTenant Create New Informer")
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "tenants.tenant.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] TenantTenant Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &TenantTenant{
					client: c.client,
					Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
				}
				newData := &TenantTenant{
					client: c.client,
					Tenant: newObj.(*basetenantexamplecomv1.Tenant),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] TenantTenant Create New Informer")
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &TenantTenant{
					client: c.client,
					Tenant: oldObj.(*basetenantexamplecomv1.Tenant),
				}
				newData := &TenantTenant{
					client: c.client,
					Tenant: newObj.(*basetenantexamplecomv1.Tenant),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *TenantTenant)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for TenantTenant")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "tenants.tenant.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] TenantTenant Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] TenantTenant Create New Informer")
		informer := informertenantexamplecomv1.NewTenantInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &TenantTenant{
					client: c.client,
					Tenant: obj.(*basetenantexamplecomv1.Tenant),
				}

				var parent *RootRoot
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("roots.root.example.com", nc.Labels, nc.Labels["roots.root.example.com"])
					parent, err = c.client.Root().ForceReadRootByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *tenantTenantExampleV1Chainer) Config() *configConfigExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["configs.config.example.com"] = helper.DEFAULT_KEY
	return &configConfigExampleV1Chainer{
		client:       c.client,
		name:         helper.DEFAULT_KEY,
		parentLabels: parentLabels,
	}
}

// GetConfig calculates hashed name of the object based on it's parents and returns the object
func (c *tenantTenantExampleV1Chainer) GetConfig(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, helper.DEFAULT_KEY)
	return c.client.Config().GetConfigByName(ctx, hashedName)
}

// AddConfig calculates hashed name of the child to create based on parents names and creates it.
// objToCreate.Name is changed to the hashed name. Original name ('default') is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantTenantExampleV1Chainer) AddConfig(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (result *ConfigConfig, err error) {
	if objToCreate.GetName() == "" {
		objToCreate.SetName(helper.DEFAULT_KEY)
	}
	if objToCreate.GetName() != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.GetName())
	}
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Config().CreateConfigByName(ctx, objToCreate)
}

// DeleteConfig calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantTenantExampleV1Chainer) DeleteConfig(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("configs.config.example.com", c.parentLabels, name)
	return c.client.Config().DeleteConfigByName(ctx, hashedName)
}

func (c *tenantTenantExampleV1Chainer) Interest(name string) *interestInterestExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["interests.interest.example.com"] = name
	return &interestInterestExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetInterest calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *tenantTenantExampleV1Chainer) GetInterest(ctx context.Context, displayName string) (result *InterestInterest, err error) {
	hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, displayName)
	return c.client.Interest().GetInterestByName(ctx, hashedName)
}

// AddInterest calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *tenantTenantExampleV1Chainer) AddInterest(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (result *InterestInterest, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Interest().CreateInterestByName(ctx, objToCreate)
}

// DeleteInterest calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *tenantTenantExampleV1Chainer) DeleteInterest(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("interests.interest.example.com", c.parentLabels, name)
	return c.client.Interest().DeleteInterestByName(ctx, hashedName)
}

func (group *ConfigExampleV1) GetConfigChildrenMap() map[string]baseconfigexamplecomv1.Child {
	return map[string]baseconfigexamplecomv1.Child{}
}

func (group *ConfigExampleV1) GetConfigChild(grp, kind, name string) baseconfigexamplecomv1.Child {
	return baseconfigexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetConfigByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) GetConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetConfigByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseconfigexamplecomv1.Config)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetConfigByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseconfigexamplecomv1.Config).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetConfigByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &ConfigConfig{
					client: group.client,
					Config: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &ConfigConfig{
				client: group.client,
				Config: resWrCache.(*baseconfigexamplecomv1.Config),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetConfigByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetConfigByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadConfigByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) ForceReadConfigByName(ctx context.Context, hashedName string) (*ConfigConfig, error) {
	log.Debugf("[ForceReadConfigByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadConfigByName] Failed to Get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Configs: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadConfigByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadConfigByName] Executed Successfully :%s", hashedName)
			return &ConfigConfig{
				client: group.client,
				Config: result,
			}, nil
		}
	}
}

// DeleteConfigByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *ConfigExampleV1) DeleteConfigByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteConfigByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseconfigexamplecomv1.Config
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] Failed to get Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("configs.config.example.com", hashedName, "users.user.example.com") {
		err := group.client.User().DeleteUserByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("configs.config.example.com", hashedName, "users.user.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteConfigByName] failed to delete Configs: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Configs: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteConfigByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteConfigByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteConfigByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteConfigByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
	}
	RemoveChild("tenants.tenant.example.com", parentName, "configs.config.example.com", hashedName)

	return nil
}

// CreateConfigByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *ConfigExampleV1) CreateConfigByName(ctx context.Context,
	objToCreate *baseconfigexamplecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[CreateConfigByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] == "" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = helper.DEFAULT_KEY
	}
	if objToCreate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToCreate.Labels[common.DISPLAY_NAME_LABEL])
	}

	objToCreate.Spec.UserGvk = nil

	var (
		retryCount int
		result     *baseconfigexamplecomv1.Config
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateConfigByName] Failed to create Config: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Config: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateConfigByName] context canceled while creating Config: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateConfigByName] Config: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.ConfigExampleV1().Configs().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateConfigByName] Unable to Get Config %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateConfigByName] found unexpected error while creating Config: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateConfigByName] Config: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				log.Debugf("[CreateConfigByName] Config: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("tenants.tenant.example.com", objToCreate.GetLabels(), parentName)

	AddChild("tenants.tenant.example.com", parentHashedName, "configs.config.example.com", objToCreate.Name)

	log.Debugf("[CreateConfigByName] Executed Successfully: %s", objToCreate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// UpdateConfigByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *ConfigExampleV1) UpdateConfigByName(ctx context.Context,
	objToUpdate *baseconfigexamplecomv1.Config) (*ConfigConfig, error) {
	log.Debugf("[UpdateConfigByName] Received objToUpdate: %s", objToUpdate.GetName())
	if objToUpdate.Labels[common.DISPLAY_NAME_LABEL] != helper.DEFAULT_KEY {
		return nil, NewSingletonNameError(objToUpdate.Labels[common.DISPLAY_NAME_LABEL])
	}

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Config().GetConfigByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["configs.config.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseconfigexamplecomv1.Config
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			ConfigExampleV1().
			Configs().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateConfigByName] Failed to patch Config %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Config: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Config deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateConfigByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateConfigByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Config Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteConfigByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Config: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Config Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateConfigByName] Patch Config Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("configs.config.example.com"); ok {
				log.Debugf("[UpdateConfigByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateConfigByName] Executed Successfully %s", objToUpdate.GetName())
	return &ConfigConfig{
		client: group.client,
		Config: result,
	}, nil
}

// ListConfigs returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *ConfigExampleV1) ListConfigs(ctx context.Context,
	opts metav1.ListOptions) (result []*ConfigConfig, err error) {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*ConfigConfig, len(items))
		for k, v := range items {
			item, _ := v.(*baseconfigexamplecomv1.Config)
			result[k] = &ConfigConfig{
				client: group.client,
				Config: item,
			}
		}
	} else {
		list, err := group.client.baseClient.ConfigExampleV1().
			Configs().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*ConfigConfig, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &ConfigConfig{
				client: group.client,
				Config: &item,
			}
		}
	}
	return
}

type ConfigConfig struct {
	client *Clientset
	*baseconfigexamplecomv1.Config
}

// Delete removes obj and all it's children from the database.
func (obj *ConfigConfig) Delete(ctx context.Context) error {
	err := obj.client.Config().DeleteConfigByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Config = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *ConfigConfig) Update(ctx context.Context) error {
	result, err := obj.client.Config().UpdateConfigByName(ctx, obj.Config)
	if err != nil {
		return err
	}
	obj.Config = result.Config
	return nil
}

func (obj *ConfigConfig) GetParent(ctx context.Context) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, obj.Labels["tenants.tenant.example.com"])
	return obj.client.Tenant().GetTenantByName(ctx, hashedName)
}

type ConfigConfigUser struct {
	client *Clientset
	User   []baseconfigexamplecomv1.Child
}

func (n *ConfigConfigUser) Next(ctx context.Context) (*UserUser, error) {
	for index, child := range n.User {
		obj, err := n.client.User().GetUserByName(ctx, child.Name)
		if err == nil {
			if index == len(n.User)-1 {
				n.User = nil
			} else {
				n.User = n.User[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllUserIter returns an iterator for all children of given type
func (obj *ConfigConfig) GetAllUserIter(ctx context.Context) (
	result ConfigConfigUser) {
	result.client = obj.client
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "users.user.example.com") {
		result.User = append(result.User, baseconfigexamplecomv1.Child{
			Group: "user.example.com",
			Kind:  "User",
			Name:  v,
		})
	}
	return
}

// GetAllUser returns all children of a given type
func (obj *ConfigConfig) GetAllUser(ctx context.Context) (
	result []*UserUser, err error) {
	for _, v := range GetChildren("configs.config.example.com", obj.Name, "users.user.example.com") {
		l, err := obj.client.User().GetUserByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetUser returns child which has given displayName
func (obj *ConfigConfig) GetUser(ctx context.Context,
	displayName string) (result *UserUser, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("users.user.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "users.user.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "Config.Config", "User", displayName)
	}

	result, err = obj.client.User().GetUserByName(ctx, childHashName)
	return
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *ConfigConfig) AddUser(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (result *UserUser, err error) {
	log.Debugf("[AddUser] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["configs.config.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["configs.config.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.User().CreateUserByName(ctx, objToCreate)
	log.Debugf("[AddUser] User created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if getErr == nil {
		obj.Config = updatedObj.Config
	}
	log.Debugf("[AddUser] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *ConfigConfig) DeleteUser(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteUser] Received for User object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["configs.config.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("users.user.example.com", parentLabels, displayName)
	if IsChildExists("configs.config.example.com", obj.Name, "users.user.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "Config.Config", "User", displayName)
	}

	err = obj.client.User().DeleteUserByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteUser] User object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.Config().GetConfigByName(ctx, obj.GetName())
	if err == nil {
		obj.Config = updatedObj.Config
	}
	return
}

type configConfigExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *configConfigExampleV1Chainer) Subscribe() {
	key := "configs.config.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *configConfigExampleV1Chainer) Unsubscribe() {
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *configConfigExampleV1Chainer) IsSubscribed() bool {
	key := "configs.config.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *configConfigExampleV1Chainer) addCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	AddChild("tenants.tenant.example.com", parentHashName, "configs.config.example.com", obj.Name)
}

func (c *configConfigExampleV1Chainer) deleteCallback(obj *ConfigConfig) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	RemoveChild("tenants.tenant.example.com", parentHashName, "configs.config.example.com", obj.Name)
}

func (c *configConfigExampleV1Chainer) RegisterEventHandler(addCB func(obj *ConfigConfig), updateCB func(oldObj, newObj *ConfigConfig), deleteCB func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "configs.config.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for ConfigConfig")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for ConfigConfig, so creating a new one")
		informer = informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &ConfigConfig{
				client: c.client,
				Config: oldObj.(*baseconfigexamplecomv1.Config),
			}
			newData := &ConfigConfig{
				client: c.client,
				Config: newObj.(*baseconfigexamplecomv1.Config),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &ConfigConfig{
				client: c.client,
				Config: obj.(*baseconfigexamplecomv1.Config),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterAddCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "configs.config.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] ConfigConfig Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] ConfigConfig Create New Informer")
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "configs.config.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] ConfigConfig Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &ConfigConfig{
					client: c.client,
					Config: oldObj.(*baseconfigexamplecomv1.Config),
				}
				newData := &ConfigConfig{
					client: c.client,
					Config: newObj.(*baseconfigexamplecomv1.Config),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] ConfigConfig Create New Informer")
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &ConfigConfig{
					client: c.client,
					Config: oldObj.(*baseconfigexamplecomv1.Config),
				}
				newData := &ConfigConfig{
					client: c.client,
					Config: newObj.(*baseconfigexamplecomv1.Config),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *ConfigConfig)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for ConfigConfig")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "configs.config.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] ConfigConfig Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] ConfigConfig Create New Informer")
		informer := informerconfigexamplecomv1.NewConfigInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &ConfigConfig{
					client: c.client,
					Config: obj.(*baseconfigexamplecomv1.Config),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *configConfigExampleV1Chainer) User(name string) *userUserExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["users.user.example.com"] = name
	return &userUserExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetUser calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *configConfigExampleV1Chainer) GetUser(ctx context.Context, displayName string) (result *UserUser, err error) {
	hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, displayName)
	return c.client.User().GetUserByName(ctx, hashedName)
}

// AddUser calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *configConfigExampleV1Chainer) AddUser(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (result *UserUser, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.User().CreateUserByName(ctx, objToCreate)
}

// DeleteUser calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *configConfigExampleV1Chainer) DeleteUser(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("users.user.example.com", c.parentLabels, name)
	return c.client.User().DeleteUserByName(ctx, hashedName)
}

func (group *UserExampleV1) GetUserChildrenMap() map[string]baseuserexamplecomv1.Child {
	return map[string]baseuserexamplecomv1.Child{}
}

func (group *UserExampleV1) GetUserChild(grp, kind, name string) baseuserexamplecomv1.Child {
	return baseuserexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetUserByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) GetUserByName(ctx context.Context, hashedName string) (*UserUser, error) {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetUserByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseuserexamplecomv1.User)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetUserByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseuserexamplecomv1.User).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetUserByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &UserUser{
					client: group.client,
					User:   resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &UserUser{
				client: group.client,
				User:   resWrCache.(*baseuserexamplecomv1.User),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &UserUser{
				client: group.client,
				User:   result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetUserByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Users: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetUserByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadUserByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) ForceReadUserByName(ctx context.Context, hashedName string) (*UserUser, error) {
	log.Debugf("[ForceReadUserByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadUserByName] Failed to Get Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Users: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadUserByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadUserByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadUserByName] Executed Successfully :%s", hashedName)
			return &UserUser{
				client: group.client,
				User:   result,
			}, nil
		}
	}
}

// DeleteUserByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *UserExampleV1) DeleteUserByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteUserByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseuserexamplecomv1.User
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteUserByName] Failed to get Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Users: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteUserByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	for _, child := range GetChildren("users.user.example.com", hashedName, "wannas.wanna.example.com") {
		err := group.client.Wanna().DeleteWannaByName(ctx, child)
		if err != nil && errors.IsNotFound(err) == false {
			return err
		}
		RemoveChild("users.user.example.com", hashedName, "wannas.wanna.example.com", child)
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			UserExampleV1().
			Users().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteUserByName] failed to delete Users: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Users: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteUserByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteUserByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteUserByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteUserByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("configs.config.example.com", parents, parentName)
	}
	RemoveChild("configs.config.example.com", parentName, "users.user.example.com", hashedName)

	return nil
}

// CreateUserByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *UserExampleV1) CreateUserByName(ctx context.Context,
	objToCreate *baseuserexamplecomv1.User) (*UserUser, error) {
	log.Debugf("[CreateUserByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.WannaGvk = nil

	var (
		retryCount int
		result     *baseuserexamplecomv1.User
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateUserByName] Failed to create User: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create User: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateUserByName] context canceled while creating User: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateUserByName] User: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.UserExampleV1().Users().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateUserByName] Unable to Get User %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateUserByName] found unexpected error while creating User: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateUserByName] User: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				log.Debugf("[CreateUserByName] User: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["configs.config.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("configs.config.example.com", objToCreate.GetLabels(), parentName)

	AddChild("configs.config.example.com", parentHashedName, "users.user.example.com", objToCreate.Name)

	log.Debugf("[CreateUserByName] Executed Successfully: %s", objToCreate.GetName())
	return &UserUser{
		client: group.client,
		User:   result,
	}, nil
}

// UpdateUserByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *UserExampleV1) UpdateUserByName(ctx context.Context,
	objToUpdate *baseuserexamplecomv1.User) (*UserUser, error) {
	log.Debugf("[UpdateUserByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.User().GetUserByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["users.user.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Username)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Username).IsNil() {
			patchValueUsername := objToUpdate.Spec.Username
			patchOpUsername := PatchOp{
				Op:    "replace",
				Path:  "/spec/username",
				Value: patchValueUsername,
			}
			patch = append(patch, patchOpUsername)
		}
	} else {
		patchValueUsername := objToUpdate.Spec.Username
		patchOpUsername := PatchOp{
			Op:    "replace",
			Path:  "/spec/username",
			Value: patchValueUsername,
		}
		patch = append(patch, patchOpUsername)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Mail)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Mail).IsNil() {
			patchValueMail := objToUpdate.Spec.Mail
			patchOpMail := PatchOp{
				Op:    "replace",
				Path:  "/spec/email",
				Value: patchValueMail,
			}
			patch = append(patch, patchOpMail)
		}
	} else {
		patchValueMail := objToUpdate.Spec.Mail
		patchOpMail := PatchOp{
			Op:    "replace",
			Path:  "/spec/email",
			Value: patchValueMail,
		}
		patch = append(patch, patchOpMail)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.FirstName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.FirstName).IsNil() {
			patchValueFirstName := objToUpdate.Spec.FirstName
			patchOpFirstName := PatchOp{
				Op:    "replace",
				Path:  "/spec/firstName",
				Value: patchValueFirstName,
			}
			patch = append(patch, patchOpFirstName)
		}
	} else {
		patchValueFirstName := objToUpdate.Spec.FirstName
		patchOpFirstName := PatchOp{
			Op:    "replace",
			Path:  "/spec/firstName",
			Value: patchValueFirstName,
		}
		patch = append(patch, patchOpFirstName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.LastName)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.LastName).IsNil() {
			patchValueLastName := objToUpdate.Spec.LastName
			patchOpLastName := PatchOp{
				Op:    "replace",
				Path:  "/spec/lastName",
				Value: patchValueLastName,
			}
			patch = append(patch, patchOpLastName)
		}
	} else {
		patchValueLastName := objToUpdate.Spec.LastName
		patchOpLastName := PatchOp{
			Op:    "replace",
			Path:  "/spec/lastName",
			Value: patchValueLastName,
		}
		patch = append(patch, patchOpLastName)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Password)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Password).IsNil() {
			patchValuePassword := objToUpdate.Spec.Password
			patchOpPassword := PatchOp{
				Op:    "replace",
				Path:  "/spec/password",
				Value: patchValuePassword,
			}
			patch = append(patch, patchOpPassword)
		}
	} else {
		patchValuePassword := objToUpdate.Spec.Password
		patchOpPassword := PatchOp{
			Op:    "replace",
			Path:  "/spec/password",
			Value: patchValuePassword,
		}
		patch = append(patch, patchOpPassword)
	}

	rt = reflect.TypeOf(objToUpdate.Spec.Realm)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Realm).IsNil() {
			patchValueRealm := objToUpdate.Spec.Realm
			patchOpRealm := PatchOp{
				Op:    "replace",
				Path:  "/spec/realm",
				Value: patchValueRealm,
			}
			patch = append(patch, patchOpRealm)
		}
	} else {
		patchValueRealm := objToUpdate.Spec.Realm
		patchOpRealm := PatchOp{
			Op:    "replace",
			Path:  "/spec/realm",
			Value: patchValueRealm,
		}
		patch = append(patch, patchOpRealm)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseuserexamplecomv1.User
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			UserExampleV1().
			Users().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateUserByName] Failed to patch User %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger User Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteUserByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting User: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("User deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateUserByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateUserByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger User Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteUserByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting User: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("User Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateUserByName] Patch User Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("users.user.example.com"); ok {
				log.Debugf("[UpdateUserByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateUserByName] Executed Successfully %s", objToUpdate.GetName())
	return &UserUser{
		client: group.client,
		User:   result,
	}, nil
}

// ListUsers returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *UserExampleV1) ListUsers(ctx context.Context,
	opts metav1.ListOptions) (result []*UserUser, err error) {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*UserUser, len(items))
		for k, v := range items {
			item, _ := v.(*baseuserexamplecomv1.User)
			result[k] = &UserUser{
				client: group.client,
				User:   item,
			}
		}
	} else {
		list, err := group.client.baseClient.UserExampleV1().
			Users().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*UserUser, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &UserUser{
				client: group.client,
				User:   &item,
			}
		}
	}
	return
}

type UserUser struct {
	client *Clientset
	*baseuserexamplecomv1.User
}

// Delete removes obj and all it's children from the database.
func (obj *UserUser) Delete(ctx context.Context) error {
	err := obj.client.User().DeleteUserByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.User = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *UserUser) Update(ctx context.Context) error {
	result, err := obj.client.User().UpdateUserByName(ctx, obj.User)
	if err != nil {
		return err
	}
	obj.User = result.User
	return nil
}

func (obj *UserUser) GetParent(ctx context.Context) (result *ConfigConfig, err error) {
	hashedName := helper.GetHashedName("configs.config.example.com", obj.Labels, obj.Labels["configs.config.example.com"])
	return obj.client.Config().GetConfigByName(ctx, hashedName)
}

type UserUserWanna struct {
	client *Clientset
	Wanna  []baseuserexamplecomv1.Child
}

func (n *UserUserWanna) Next(ctx context.Context) (*WannaWanna, error) {
	for index, child := range n.Wanna {
		obj, err := n.client.Wanna().GetWannaByName(ctx, child.Name)
		if err == nil {
			if index == len(n.Wanna)-1 {
				n.Wanna = nil
			} else {
				n.Wanna = n.Wanna[index+1:]
			}
			return obj, nil
		} else if errors.IsNotFound(err) {
			continue
		} else {
			return nil, err
		}
	}
	return nil, nil
}

// GetAllWannaIter returns an iterator for all children of given type
func (obj *UserUser) GetAllWannaIter(ctx context.Context) (
	result UserUserWanna) {
	result.client = obj.client
	for _, v := range GetChildren("users.user.example.com", obj.Name, "wannas.wanna.example.com") {
		result.Wanna = append(result.Wanna, baseuserexamplecomv1.Child{
			Group: "wanna.example.com",
			Kind:  "Wanna",
			Name:  v,
		})
	}
	return
}

// GetAllWanna returns all children of a given type
func (obj *UserUser) GetAllWanna(ctx context.Context) (
	result []*WannaWanna, err error) {
	for _, v := range GetChildren("users.user.example.com", obj.Name, "wannas.wanna.example.com") {
		l, err := obj.client.Wanna().GetWannaByName(ctx, v)
		if err != nil {
			return nil, err
		}
		result = append(result, l)
	}
	return
}

// GetWanna returns child which has given displayName
func (obj *UserUser) GetWanna(ctx context.Context,
	displayName string) (result *WannaWanna, err error) {

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["users.user.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("wannas.wanna.example.com", parentLabels, displayName)
	if IsChildExists("users.user.example.com", obj.Name, "wannas.wanna.example.com", childHashName) == false {
		return nil, NewChildNotFound(obj.DisplayName(), "User.User", "Wanna", displayName)
	}

	result, err = obj.client.Wanna().GetWannaByName(ctx, childHashName)
	return
}

// AddWanna calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (obj *UserUser) AddWanna(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (result *WannaWanna, err error) {
	log.Debugf("[AddWanna] Received objToAdd: %s", objToCreate.GetName())
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for _, v := range helper.GetCRDParentsMap()["users.user.example.com"] {
		objToCreate.Labels[v] = obj.Labels[v]
	}
	objToCreate.Labels["users.user.example.com"] = obj.DisplayName()
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName(objToCreate.CRDName(), objToCreate.Labels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	result, err = obj.client.Wanna().CreateWannaByName(ctx, objToCreate)
	log.Debugf("[AddWanna] Wanna created successfully: %s", objToCreate.GetName())
	updatedObj, getErr := obj.client.User().GetUserByName(ctx, obj.GetName())
	if getErr == nil {
		obj.User = updatedObj.User
	}
	log.Debugf("[AddWanna] Executed Successfully: %s", objToCreate.GetName())
	return
}

// DeleteWanna calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.

func (obj *UserUser) DeleteWanna(ctx context.Context, displayName string) (err error) {
	log.Debugf("[ DeleteWanna] Received for Wanna object: %s to delete", displayName)

	parentLabels := make(map[string]string)
	for k, v := range obj.Labels {
		parentLabels[k] = v
	}
	parentLabels["users.user.example.com"] = obj.DisplayName()
	childHashName := helper.GetHashedName("wannas.wanna.example.com", parentLabels, displayName)
	if IsChildExists("users.user.example.com", obj.Name, "wannas.wanna.example.com", childHashName) == false {
		return NewChildNotFound(obj.DisplayName(), "User.User", "Wanna", displayName)
	}

	err = obj.client.Wanna().DeleteWannaByName(ctx, childHashName)
	if err != nil {
		return err
	}
	log.Debugf("[ DeleteWanna] Wanna object: %s deleted successfully", displayName)
	updatedObj, err := obj.client.User().GetUserByName(ctx, obj.GetName())
	if err == nil {
		obj.User = updatedObj.User
	}
	return
}

type userUserExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *userUserExampleV1Chainer) Subscribe() {
	key := "users.user.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *userUserExampleV1Chainer) Unsubscribe() {
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *userUserExampleV1Chainer) IsSubscribed() bool {
	key := "users.user.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *userUserExampleV1Chainer) addCallback(obj *UserUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	AddChild("configs.config.example.com", parentHashName, "users.user.example.com", obj.Name)
}

func (c *userUserExampleV1Chainer) deleteCallback(obj *UserUser) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["configs.config.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("configs.config.example.com", obj.Labels, parentDisplayName)

	RemoveChild("configs.config.example.com", parentHashName, "users.user.example.com", obj.Name)
}

func (c *userUserExampleV1Chainer) RegisterEventHandler(addCB func(obj *UserUser), updateCB func(oldObj, newObj *UserUser), deleteCB func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "users.user.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for UserUser")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for UserUser, so creating a new one")
		informer = informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &UserUser{
				client: c.client,
				User:   oldObj.(*baseuserexamplecomv1.User),
			}
			newData := &UserUser{
				client: c.client,
				User:   newObj.(*baseuserexamplecomv1.User),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &UserUser{
				client: c.client,
				User:   obj.(*baseuserexamplecomv1.User),
			}

			var parent *ConfigConfig
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
				parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterAddCallback(cbfn func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "users.user.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] UserUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] UserUser Create New Informer")
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "users.user.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] UserUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &UserUser{
					client: c.client,
					User:   oldObj.(*baseuserexamplecomv1.User),
				}
				newData := &UserUser{
					client: c.client,
					User:   newObj.(*baseuserexamplecomv1.User),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] UserUser Create New Informer")
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &UserUser{
					client: c.client,
					User:   oldObj.(*baseuserexamplecomv1.User),
				}
				newData := &UserUser{
					client: c.client,
					User:   newObj.(*baseuserexamplecomv1.User),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *userUserExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *UserUser)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for UserUser")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "users.user.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] UserUser Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] UserUser Create New Informer")
		informer := informeruserexamplecomv1.NewUserInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &UserUser{
					client: c.client,
					User:   obj.(*baseuserexamplecomv1.User),
				}

				var parent *ConfigConfig
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("configs.config.example.com", nc.Labels, nc.Labels["configs.config.example.com"])
					parent, err = c.client.Config().ForceReadConfigByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *userUserExampleV1Chainer) Wanna(name string) *wannaWannaExampleV1Chainer {
	parentLabels := c.parentLabels
	parentLabels["wannas.wanna.example.com"] = name
	return &wannaWannaExampleV1Chainer{
		client:       c.client,
		name:         name,
		parentLabels: parentLabels,
	}
}

// GetWanna calculates hashed name of the object based on displayName and it's parents and returns the object
func (c *userUserExampleV1Chainer) GetWanna(ctx context.Context, displayName string) (result *WannaWanna, err error) {
	hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, displayName)
	return c.client.Wanna().GetWannaByName(ctx, hashedName)
}

// AddWanna calculates hashed name of the child to create based on objToCreate.Name
// and parents names and creates it. objToCreate.Name is changed to the hashed name. Original name is preserved in
// nexus/display_name label and can be obtained using DisplayName() method.
func (c *userUserExampleV1Chainer) AddWanna(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (result *WannaWanna, err error) {
	if objToCreate.Labels == nil {
		objToCreate.Labels = map[string]string{}
	}
	for k, v := range c.parentLabels {
		objToCreate.Labels[k] = v
	}
	if objToCreate.Labels[common.IS_NAME_HASHED_LABEL] != "true" {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
		objToCreate.Labels[common.IS_NAME_HASHED_LABEL] = "true"
		hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, objToCreate.GetName())
		objToCreate.Name = hashedName
	}
	return c.client.Wanna().CreateWannaByName(ctx, objToCreate)
}

// DeleteWanna calculates hashed name of the child to delete based on displayName
// and parents names and deletes it.
func (c *userUserExampleV1Chainer) DeleteWanna(ctx context.Context, name string) (err error) {
	if c.parentLabels == nil {
		c.parentLabels = map[string]string{}
	}
	c.parentLabels[common.IS_NAME_HASHED_LABEL] = "true"
	hashedName := helper.GetHashedName("wannas.wanna.example.com", c.parentLabels, name)
	return c.client.Wanna().DeleteWannaByName(ctx, hashedName)
}

func (group *WannaExampleV1) GetWannaChildrenMap() map[string]basewannaexamplecomv1.Child {
	return map[string]basewannaexamplecomv1.Child{}
}

func (group *WannaExampleV1) GetWannaChild(grp, kind, name string) basewannaexamplecomv1.Child {
	return basewannaexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetWannaByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) GetWannaByName(ctx context.Context, hashedName string) (*WannaWanna, error) {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetWannaByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*basewannaexamplecomv1.Wanna)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetWannaByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*basewannaexamplecomv1.Wanna).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetWannaByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &WannaWanna{
					client: group.client,
					Wanna:  resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &WannaWanna{
				client: group.client,
				Wanna:  resWrCache.(*basewannaexamplecomv1.Wanna),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &WannaWanna{
				client: group.client,
				Wanna:  result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetWannaByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Wannas: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetWannaByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetWannaByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadWannaByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) ForceReadWannaByName(ctx context.Context, hashedName string) (*WannaWanna, error) {
	log.Debugf("[ForceReadWannaByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadWannaByName] Failed to Get Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Wannas: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadWannaByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadWannaByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadWannaByName] Executed Successfully :%s", hashedName)
			return &WannaWanna{
				client: group.client,
				Wanna:  result,
			}, nil
		}
	}
}

// DeleteWannaByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *WannaExampleV1) DeleteWannaByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteWannaByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *basewannaexamplecomv1.Wanna
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteWannaByName] Failed to get Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Wannas: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteWannaByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteWannaByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteWannaByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteWannaByName] failed to delete Wannas: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Wannas: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteWannaByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteWannaByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteWannaByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteWannaByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["users.user.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("users.user.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("users.user.example.com", parents, parentName)
	}
	RemoveChild("users.user.example.com", parentName, "wannas.wanna.example.com", hashedName)

	return nil
}

// CreateWannaByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *WannaExampleV1) CreateWannaByName(ctx context.Context,
	objToCreate *basewannaexamplecomv1.Wanna) (*WannaWanna, error) {
	log.Debugf("[CreateWannaByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	objToCreate.Spec.InterestGvk = nil

	var (
		retryCount int
		result     *basewannaexamplecomv1.Wanna
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateWannaByName] Failed to create Wanna: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Wanna: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateWannaByName] context canceled while creating Wanna: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateWannaByName] Wanna: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.WannaExampleV1().Wannas().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateWannaByName] Unable to Get Wanna %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateWannaByName] found unexpected error while creating Wanna: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateWannaByName] Wanna: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				log.Debugf("[CreateWannaByName] Wanna: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["users.user.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("users.user.example.com", objToCreate.GetLabels(), parentName)

	AddChild("users.user.example.com", parentHashedName, "wannas.wanna.example.com", objToCreate.Name)

	log.Debugf("[CreateWannaByName] Executed Successfully: %s", objToCreate.GetName())
	return &WannaWanna{
		client: group.client,
		Wanna:  result,
	}, nil
}

// UpdateWannaByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *WannaExampleV1) UpdateWannaByName(ctx context.Context,
	objToUpdate *basewannaexamplecomv1.Wanna) (*WannaWanna, error) {
	log.Debugf("[UpdateWannaByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Wanna().GetWannaByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["wannas.wanna.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *basewannaexamplecomv1.Wanna
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			WannaExampleV1().
			Wannas().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateWannaByName] Failed to patch Wanna %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Wanna Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteWannaByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Wanna: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Wanna deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateWannaByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateWannaByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Wanna Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteWannaByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Wanna: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Wanna Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateWannaByName] Patch Wanna Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("wannas.wanna.example.com"); ok {
				log.Debugf("[UpdateWannaByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateWannaByName] Executed Successfully %s", objToUpdate.GetName())
	return &WannaWanna{
		client: group.client,
		Wanna:  result,
	}, nil
}

// ListWannas returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *WannaExampleV1) ListWannas(ctx context.Context,
	opts metav1.ListOptions) (result []*WannaWanna, err error) {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*WannaWanna, len(items))
		for k, v := range items {
			item, _ := v.(*basewannaexamplecomv1.Wanna)
			result[k] = &WannaWanna{
				client: group.client,
				Wanna:  item,
			}
		}
	} else {
		list, err := group.client.baseClient.WannaExampleV1().
			Wannas().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*WannaWanna, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &WannaWanna{
				client: group.client,
				Wanna:  &item,
			}
		}
	}
	return
}

type WannaWanna struct {
	client *Clientset
	*basewannaexamplecomv1.Wanna
}

// Delete removes obj and all it's children from the database.
func (obj *WannaWanna) Delete(ctx context.Context) error {
	err := obj.client.Wanna().DeleteWannaByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Wanna = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *WannaWanna) Update(ctx context.Context) error {
	result, err := obj.client.Wanna().UpdateWannaByName(ctx, obj.Wanna)
	if err != nil {
		return err
	}
	obj.Wanna = result.Wanna
	return nil
}

func (obj *WannaWanna) GetParent(ctx context.Context) (result *UserUser, err error) {
	hashedName := helper.GetHashedName("users.user.example.com", obj.Labels, obj.Labels["users.user.example.com"])
	return obj.client.User().GetUserByName(ctx, hashedName)
}

// GetInterest returns link of given type
func (obj *WannaWanna) GetInterest(ctx context.Context) (
	result *InterestInterest, err error) {
	if obj.Spec.InterestGvk == nil {
		return nil, NewLinkNotFound(obj.DisplayName(), "Wanna.Wanna", "Interest")
	}
	return obj.client.Interest().GetInterestByName(ctx, obj.Spec.InterestGvk.Name)
}

// LinkInterest links obj with linkToAdd object. This function doesn't create linked object, it must be
// already created.
func (obj *WannaWanna) LinkInterest(ctx context.Context,
	linkToAdd *InterestInterest) error {

	var patch Patch
	patchOp := PatchOp{
		Op:   "replace",
		Path: "/spec/interestGvk",
		Value: basewannaexamplecomv1.Child{
			Group: "interest.example.com",
			Kind:  "Interest",
			Name:  linkToAdd.Name,
		},
	}
	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.WannaExampleV1().Wannas().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}

	obj.Wanna = result
	return nil
}

// UnlinkInterest unlinks linkToRemove object from obj. This function doesn't delete linked object.
func (obj *WannaWanna) UnlinkInterest(ctx context.Context) (err error) {
	var patch Patch

	patchOp := PatchOp{
		Op:   "remove",
		Path: "/spec/interestGvk",
	}

	patch = append(patch, patchOp)
	marshaled, err := patch.Marshal()
	if err != nil {
		return err
	}
	result, err := obj.client.baseClient.WannaExampleV1().Wannas().Patch(ctx, obj.Name, types.JSONPatchType, marshaled, metav1.PatchOptions{})
	if err != nil {
		return err
	}
	obj.Wanna = result
	return nil

}

type wannaWannaExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *wannaWannaExampleV1Chainer) Subscribe() {
	key := "wannas.wanna.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *wannaWannaExampleV1Chainer) Unsubscribe() {
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *wannaWannaExampleV1Chainer) IsSubscribed() bool {
	key := "wannas.wanna.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *wannaWannaExampleV1Chainer) addCallback(obj *WannaWanna) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["users.user.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("users.user.example.com", obj.Labels, parentDisplayName)

	AddChild("users.user.example.com", parentHashName, "wannas.wanna.example.com", obj.Name)
}

func (c *wannaWannaExampleV1Chainer) deleteCallback(obj *WannaWanna) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["users.user.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("users.user.example.com", obj.Labels, parentDisplayName)

	RemoveChild("users.user.example.com", parentHashName, "wannas.wanna.example.com", obj.Name)
}

func (c *wannaWannaExampleV1Chainer) RegisterEventHandler(addCB func(obj *WannaWanna), updateCB func(oldObj, newObj *WannaWanna), deleteCB func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "wannas.wanna.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for WannaWanna")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for WannaWanna, so creating a new one")
		informer = informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &WannaWanna{
				client: c.client,
				Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
			}
			newData := &WannaWanna{
				client: c.client,
				Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &WannaWanna{
				client: c.client,
				Wanna:  obj.(*basewannaexamplecomv1.Wanna),
			}

			var parent *UserUser
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
				parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterAddCallback(cbfn func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "wannas.wanna.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] WannaWanna Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] WannaWanna Create New Informer")
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "wannas.wanna.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] WannaWanna Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &WannaWanna{
					client: c.client,
					Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
				}
				newData := &WannaWanna{
					client: c.client,
					Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] WannaWanna Create New Informer")
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &WannaWanna{
					client: c.client,
					Wanna:  oldObj.(*basewannaexamplecomv1.Wanna),
				}
				newData := &WannaWanna{
					client: c.client,
					Wanna:  newObj.(*basewannaexamplecomv1.Wanna),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *wannaWannaExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *WannaWanna)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for WannaWanna")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "wannas.wanna.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] WannaWanna Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] WannaWanna Create New Informer")
		informer := informerwannaexamplecomv1.NewWannaInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &WannaWanna{
					client: c.client,
					Wanna:  obj.(*basewannaexamplecomv1.Wanna),
				}

				var parent *UserUser
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("users.user.example.com", nc.Labels, nc.Labels["users.user.example.com"])
					parent, err = c.client.User().ForceReadUserByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (group *InterestExampleV1) GetInterestChildrenMap() map[string]baseinterestexamplecomv1.Child {
	return map[string]baseinterestexamplecomv1.Child{}
}

func (group *InterestExampleV1) GetInterestChild(grp, kind, name string) baseinterestexamplecomv1.Child {
	return baseinterestexamplecomv1.Child{
		Group: grp,
		Kind:  kind,
		Name:  name,
	}
}

// GetInterestByName returns object stored in the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) GetInterestByName(ctx context.Context, hashedName string) (*InterestInterest, error) {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		// Check if the object is in write cache.
		resWrCache, inWrCache := s.(subscription).WriteCacheObjects.Load(hashedName)
		item, exists, _ := s.(subscription).informer.GetStore().GetByKey(hashedName)
		if exists {
			log.Debugf("[GetInterestByName] Object: %s exists in cache", hashedName)
			resultCache, _ := item.(*baseinterestexamplecomv1.Interest)
			subsCacheVersion, subsCacheVersionErr := strconv.Atoi(resultCache.ResourceVersion)
			if subsCacheVersionErr != nil {
				log.Fatalf("[GetInterestByName] Getting version of Object: %s failed with error %v", hashedName, subsCacheVersionErr)
			}

			writeCacheVersion := 0
			var writeCacheVersionErr error
			if inWrCache {
				writeCacheVersion, writeCacheVersionErr = strconv.Atoi(resWrCache.(*baseinterestexamplecomv1.Interest).ResourceVersion)
				if writeCacheVersionErr != nil {
					log.Fatalf("[GetInterestByName] Getting version of Object: %s in write cache failed with error %v", hashedName, writeCacheVersionErr)
				}
			}

			if !inWrCache || subsCacheVersion >= writeCacheVersion {
				if inWrCache {
					s.(subscription).WriteCacheObjects.Delete(hashedName)
				}
				return &InterestInterest{
					client:   group.client,
					Interest: resultCache,
				}, nil
			}
		}
		if inWrCache {
			return &InterestInterest{
				client:   group.client,
				Interest: resWrCache.(*baseinterestexamplecomv1.Interest),
			}, nil
		}
	}

	retryCount := 0
	for {
		result, err := group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err == nil {
			return &InterestInterest{
				client:   group.client,
				Interest: result,
			}, nil
		} else if errors.IsNotFound(err) {
			log.Debugf("[GetInterestByName]: object %v not found", hashedName)
			return nil, err
		} else {
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on Get Interests: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[GetInterestByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[GetInterestByName]: %+v", err)
				return nil, err
			}
		}
	}
}

// ForceReadInterestByName read object directly from the database under the hashedName which is a hash of display
// name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) ForceReadInterestByName(ctx context.Context, hashedName string) (*InterestInterest, error) {
	log.Debugf("[ForceReadInterestByName] Received object :%s to read from DB", hashedName)
	retryCount := 0
	for {
		result, err := group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[ForceReadInterestByName] Failed to Get Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Errorf("[Retry Count: %d ] %+v", retryCount, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max Retry exceed on Get Interests: %s", hashedName)
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[ForceReadInterestByName]: %+v", err)
				return nil, context.Canceled
			} else {
				log.Errorf("[ForceReadInterestByName]: %+v", err)
				return nil, err
			}
		} else {
			log.Debugf("[ForceReadInterestByName] Executed Successfully :%s", hashedName)
			return &InterestInterest{
				client:   group.client,
				Interest: result,
			}, nil
		}
	}
}

// DeleteInterestByName deletes object stored in the database under the hashedName which is a hash of
// display name and parents names. Use it when you know hashed name of object.
func (group *InterestExampleV1) DeleteInterestByName(ctx context.Context, hashedName string) (err error) {
	log.Debugf("[DeleteInterestByName] Received objectToDelete: %s", hashedName)
	var (
		retryCount int
		result     *baseinterestexamplecomv1.Interest
	)

	retryCount = 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Get(ctx, hashedName, metav1.GetOptions{})
		if err != nil {
			log.Errorf("[DeleteInterestByName] Failed to get Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on get Interests: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteInterestByName] context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteInterestByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteInterestByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			break
		}
	}

	if result == nil {
		return err
	}

	retryCount = 0
	for {
		err = group.client.baseClient.
			InterestExampleV1().
			Interests().Delete(ctx, hashedName, metav1.DeleteOptions{})
		if err != nil {
			log.Errorf("[DeleteInterestByName] failed to delete Interests: %+v", err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, hashedName, err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on delete Interests: %s", hashedName)
					return err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[DeleteInterestByName]: context canceled: %s", hashedName)
				return context.Canceled
			} else if errors.IsNotFound(err) {
				log.Errorf("[DeleteInterestByName] Object: %s not found", hashedName)
				break
			} else {
				log.Errorf("[DeleteInterestByName] Object: %s unexpected error: %+v", hashedName, err)
				return err
			}
		} else {
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				s.(subscription).WriteCacheObjects.Delete(hashedName)
			}
			break
		}
	}
	// Get Parent Node and check if gvk present before patch

	log.Debugf("[DeleteInterestByName] Get parent details for object: %s", hashedName)
	// var patch Patch
	parents := result.GetLabels()
	if parents == nil {
		parents = make(map[string]string)
	}
	parentName, ok := parents["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	if result.GetLabels() != nil {
		if parents[common.IS_NAME_HASHED_LABEL] == "true" {
			parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
		}
	} else {
		parentName = helper.GetHashedName("tenants.tenant.example.com", parents, parentName)
	}
	RemoveChild("tenants.tenant.example.com", parentName, "interests.interest.example.com", hashedName)

	return nil
}

// CreateInterestByName creates object in the database without hashing the name.
// Use it directly ONLY when objToCreate.Name is hashed name of the object.
func (group *InterestExampleV1) CreateInterestByName(ctx context.Context,
	objToCreate *baseinterestexamplecomv1.Interest) (*InterestInterest, error) {
	log.Debugf("[CreateInterestByName] Received objToCreate: %s", objToCreate.GetName())
	if objToCreate.GetLabels() == nil {
		objToCreate.Labels = make(map[string]string)
	}
	if _, ok := objToCreate.Labels[common.DISPLAY_NAME_LABEL]; !ok {
		objToCreate.Labels[common.DISPLAY_NAME_LABEL] = objToCreate.GetName()
	}

	var (
		retryCount int
		result     *baseinterestexamplecomv1.Interest
		err        error
	)
	retryCount = 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Create(ctx, objToCreate, metav1.CreateOptions{})
		if err != nil {
			log.Errorf("[CreateInterestByName] Failed to create Interest: %s, error: %+v", objToCreate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToCreate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on create Interest: %s", objToCreate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[CreateInterestByName] context canceled while creating Interest: %s", objToCreate.GetName())
				return nil, context.Canceled
			} else if errors.IsAlreadyExists(err) {
				log.Debugf("[CreateInterestByName] Interest: %s already exists, error: %+v", objToCreate.GetName(), err)
				result, err = group.client.baseClient.InterestExampleV1().Interests().Get(ctx, objToCreate.GetName(), metav1.GetOptions{})
				if err != nil {
					log.Fatalf("[CreateInterestByName] Unable to Get Interest %s after it was flagged as already exists, error: %+v", objToCreate.GetName(), err)
				}
				break
			} else {
				log.Errorf("[CreateInterestByName] found unexpected error while creating Interest: %s, error: %+v", objToCreate.GetName(), err)
				return nil, err
			}
		} else {
			log.Debugf("[CreateInterestByName] Interest: %s created successfully", objToCreate.GetName())
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				log.Debugf("[CreateInterestByName] Interest: %s stored in wr-cache", objToCreate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToCreate.GetName(), result)
			}
			break
		}
	}

	parentName, ok := objToCreate.GetLabels()["tenants.tenant.example.com"]
	if !ok {
		parentName = helper.DEFAULT_KEY
	}
	parentHashedName := helper.GetHashedName("tenants.tenant.example.com", objToCreate.GetLabels(), parentName)

	AddChild("tenants.tenant.example.com", parentHashedName, "interests.interest.example.com", objToCreate.Name)

	log.Debugf("[CreateInterestByName] Executed Successfully: %s", objToCreate.GetName())
	return &InterestInterest{
		client:   group.client,
		Interest: result,
	}, nil
}

// UpdateInterestByName updates object stored in the database under the hashedName which is a hash of
// display name and parents names.
func (group *InterestExampleV1) UpdateInterestByName(ctx context.Context,
	objToUpdate *baseinterestexamplecomv1.Interest) (*InterestInterest, error) {
	log.Debugf("[UpdateInterestByName] Received objToUpdate: %s", objToUpdate.GetName())

	var patch Patch

	if objToUpdate.Annotations != nil || objToUpdate.Labels != nil {
		current, err := group.client.Interest().GetInterestByName(ctx, objToUpdate.Name)
		if err != nil {
			return nil, err
		}

		if objToUpdate.Annotations != nil {
			if current.Annotations[ownershipAnnotation] != "" {
				objToUpdate.Annotations[ownershipAnnotation] = current.Annotations[ownershipAnnotation]
			}
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/annotations",
				Value: objToUpdate.Annotations,
			})
		}

		if objToUpdate.Labels != nil {
			parentsList := helper.GetCRDParentsMap()["interests.interest.example.com"]
			for _, k := range parentsList {
				objToUpdate.Labels[k] = current.Labels[k]
			}
			objToUpdate.Labels[common.IS_NAME_HASHED_LABEL] = current.Labels[common.IS_NAME_HASHED_LABEL]
			objToUpdate.Labels[common.DISPLAY_NAME_LABEL] = current.Labels[common.DISPLAY_NAME_LABEL]
			patch = append(patch, PatchOp{
				Op:    "replace",
				Path:  "/metadata/labels",
				Value: objToUpdate.Labels,
			})
		}
	}

	var rt reflect.Type

	rt = reflect.TypeOf(objToUpdate.Spec.Name)
	if rt.Kind() == reflect.Slice || rt.Kind() == reflect.Array || rt.Kind() == reflect.Map {
		if !reflect.ValueOf(objToUpdate.Spec.Name).IsNil() {
			patchValueName := objToUpdate.Spec.Name
			patchOpName := PatchOp{
				Op:    "replace",
				Path:  "/spec/name",
				Value: patchValueName,
			}
			patch = append(patch, patchOpName)
		}
	} else {
		patchValueName := objToUpdate.Spec.Name
		patchOpName := PatchOp{
			Op:    "replace",
			Path:  "/spec/name",
			Value: patchValueName,
		}
		patch = append(patch, patchOpName)
	}

	marshaled, err := patch.Marshal()
	if err != nil {
		return nil, err
	}

	var (
		result *baseinterestexamplecomv1.Interest
	)
	newCtx := context.TODO()
	retryCount := 0
	for {
		result, err = group.client.baseClient.
			InterestExampleV1().
			Interests().Patch(newCtx, objToUpdate.GetName(), types.JSONPatchType, marshaled, metav1.PatchOptions{}, "")
		if err != nil {
			log.Errorf("[UpdateInterestByName] Failed to patch Interest %s with error: %+v", objToUpdate.GetName(), err)
			if errors.IsTimeout(err) || customerrors.Is(err, context.DeadlineExceeded) {
				log.Debugf("[Retry count: (%d) obj: %s ] %+v", retryCount, objToUpdate.GetName(), err)
				if retryCount == maxRetryCount {
					log.Errorf("Max retry exceed on patching: %s", objToUpdate.GetName())
					log.Debugf("Trigger Interest Delete: %s", objToUpdate.GetName())
					delErr := group.DeleteInterestByName(newCtx, objToUpdate.GetName())
					if delErr != nil {
						log.Debugf("Error occur while deleting Interest: %s", objToUpdate.GetName())
						return nil, delErr
					}
					log.Debugf("Interest deleted: %s", objToUpdate.GetName())
					return nil, err
				}
				retryCount += 1
				time.Sleep(sleepTime * time.Second)
			} else if customerrors.Is(err, context.Canceled) {
				log.Errorf("[UpdateInterestByName]: context canceled: %s", objToUpdate.GetName())
				return nil, context.Canceled
			} else {
				log.Errorf("[UpdateInterestByName] Object: %s unexpected error: %+v", objToUpdate.GetName(), err)
				log.Debugf("Trigger Interest Delete: %s", objToUpdate.GetName())
				delErr := group.DeleteInterestByName(newCtx, objToUpdate.GetName())
				if delErr != nil {
					log.Debugf("Error occur while deleting Interest: %+v", objToUpdate.GetName())
					return nil, delErr
				}
				log.Debugf("Interest Deleted: %s", objToUpdate.GetName())
				return nil, err
			}
		} else {
			log.Debugf("[UpdateInterestByName] Patch Interest Success :%s", objToUpdate.GetName())
			if s, ok := subscriptionMap.Load("interests.interest.example.com"); ok {
				log.Debugf("[UpdateInterestByName] %s stored in wr-cache", objToUpdate.GetName())
				s.(subscription).WriteCacheObjects.Store(objToUpdate.GetName(), result)
			}
			break
		}
	}
	log.Debugf("[UpdateInterestByName] Executed Successfully %s", objToUpdate.GetName())
	return &InterestInterest{
		client:   group.client,
		Interest: result,
	}, nil
}

// ListInterests returns slice of all existing objects of this type. Selectors can be provided in opts parameter.
func (group *InterestExampleV1) ListInterests(ctx context.Context,
	opts metav1.ListOptions) (result []*InterestInterest, err error) {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		items := s.(subscription).informer.GetStore().List()
		result = make([]*InterestInterest, len(items))
		for k, v := range items {
			item, _ := v.(*baseinterestexamplecomv1.Interest)
			result[k] = &InterestInterest{
				client:   group.client,
				Interest: item,
			}
		}
	} else {
		list, err := group.client.baseClient.InterestExampleV1().
			Interests().List(ctx, opts)
		if err != nil {
			return nil, err
		}
		result = make([]*InterestInterest, len(list.Items))
		for k, v := range list.Items {
			item := v
			result[k] = &InterestInterest{
				client:   group.client,
				Interest: &item,
			}
		}
	}
	return
}

type InterestInterest struct {
	client *Clientset
	*baseinterestexamplecomv1.Interest
}

// Delete removes obj and all it's children from the database.
func (obj *InterestInterest) Delete(ctx context.Context) error {
	err := obj.client.Interest().DeleteInterestByName(ctx, obj.GetName())
	if err != nil {
		return err
	}
	obj.Interest = nil
	return nil
}

// Update updates spec of object in database. Children and Link can not be updated using this function.
func (obj *InterestInterest) Update(ctx context.Context) error {
	result, err := obj.client.Interest().UpdateInterestByName(ctx, obj.Interest)
	if err != nil {
		return err
	}
	obj.Interest = result.Interest
	return nil
}

func (obj *InterestInterest) GetParent(ctx context.Context) (result *TenantTenant, err error) {
	hashedName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, obj.Labels["tenants.tenant.example.com"])
	return obj.client.Tenant().GetTenantByName(ctx, hashedName)
}

type interestInterestExampleV1Chainer struct {
	client       *Clientset
	name         string
	parentLabels map[string]string
}

func (c *interestInterestExampleV1Chainer) Subscribe() {
	key := "interests.interest.example.com"
	if _, ok := subscriptionMap.Load(key); !ok {
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)

		c.RegisterAddCallback(c.addCallback)
		c.RegisterDeleteCallback(c.deleteCallback)

	}
}

func (c *interestInterestExampleV1Chainer) Unsubscribe() {
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		close(s.(subscription).stop)
		subscriptionMap.Delete(key)
	}
}

func (c *interestInterestExampleV1Chainer) IsSubscribed() bool {
	key := "interests.interest.example.com"
	_, ok := subscriptionMap.Load(key)
	return ok
}

func (c *interestInterestExampleV1Chainer) addCallback(obj *InterestInterest) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	AddChild("tenants.tenant.example.com", parentHashName, "interests.interest.example.com", obj.Name)
}

func (c *interestInterestExampleV1Chainer) deleteCallback(obj *InterestInterest) {
	parentDisplayName := helper.DEFAULT_KEY
	if value, ok := obj.Labels["tenants.tenant.example.com"]; ok {
		parentDisplayName = value
	}
	parentHashName := helper.GetHashedName("tenants.tenant.example.com", obj.Labels, parentDisplayName)

	RemoveChild("tenants.tenant.example.com", parentHashName, "interests.interest.example.com", obj.Name)
}

func (c *interestInterestExampleV1Chainer) RegisterEventHandler(addCB func(obj *InterestInterest), updateCB func(oldObj, newObj *InterestInterest), deleteCB func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	fmt.Println("RegisterEventHandler for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
		informer       cache.SharedIndexInformer
	)
	key := "interests.interest.example.com"
	if s, ok := subscriptionMap.Load(key); ok {
		fmt.Println("Informer exists for InterestInterest")
		sub := s.(subscription)
		informer = sub.informer
	} else {
		fmt.Println("Informer doesn't exists for InterestInterest, so creating a new one")
		informer = informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		subscribe(key, informer)
	}
	registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
		AddFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			addCB(nc)
		},

		UpdateFunc: func(oldObj, newObj interface{}) {
			oldData := &InterestInterest{
				client:   c.client,
				Interest: oldObj.(*baseinterestexamplecomv1.Interest),
			}
			newData := &InterestInterest{
				client:   c.client,
				Interest: newObj.(*baseinterestexamplecomv1.Interest),
			}
			updateCB(oldData, newData)
		},

		DeleteFunc: func(obj interface{}) {
			nc := &InterestInterest{
				client:   c.client,
				Interest: obj.(*baseinterestexamplecomv1.Interest),
			}

			var parent *TenantTenant
			for i := 0; i < 600; i++ {
				// Check if parent exists
				p, err := nc.GetParent(context.TODO())
				if err != nil || p == nil {
					time.Sleep(500 * time.Millisecond)
					continue
				}
				parent = p
				break
			}
			if parent == nil {
				hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
				parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
				if err != nil {
					if errors.IsNotFound(err) {
						return
					}
					panic("error occurred while fetching parent " + err.Error())
				}
				panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
			}

			deleteCB(nc)
		},
	})
	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterAddCallback(cbfn func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterAddCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "interests.interest.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterAddCallback] InterestInterest Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterAddCallback] InterestInterest Create New Informer")
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			AddFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterUpdateCallback(cbfn func(oldObj, newObj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterUpdateCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "interests.interest.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterUpdateCallback] InterestInterest Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &InterestInterest{
					client:   c.client,
					Interest: oldObj.(*baseinterestexamplecomv1.Interest),
				}
				newData := &InterestInterest{
					client:   c.client,
					Interest: newObj.(*baseinterestexamplecomv1.Interest),
				}
				cbfn(oldData, newData)
			},
		})
	} else {
		log.Debugf("[RegisterUpdateCallback] InterestInterest Create New Informer")
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			UpdateFunc: func(oldObj, newObj interface{}) {
				oldData := &InterestInterest{
					client:   c.client,
					Interest: oldObj.(*baseinterestexamplecomv1.Interest),
				}
				newData := &InterestInterest{
					client:   c.client,
					Interest: newObj.(*baseinterestexamplecomv1.Interest),
				}
				cbfn(oldData, newData)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}

func (c *interestInterestExampleV1Chainer) RegisterDeleteCallback(cbfn func(obj *InterestInterest)) (cache.ResourceEventHandlerRegistration, error) {
	log.Debugf("[RegisterDeleteCallback] Received for InterestInterest")
	var (
		registrationId cache.ResourceEventHandlerRegistration
		err            error
	)
	key := "interests.interest.example.com"
	stopper := make(chan struct{})
	if s, ok := subscriptionMap.Load(key); ok {
		log.Debugf("[RegisterDeleteCallback] InterestInterest Use Subscription Informer")
		sub := s.(subscription)
		registrationId, err = sub.informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
	} else {
		log.Debugf("[RegisterDeleteCallback] InterestInterest Create New Informer")
		informer := informerinterestexamplecomv1.NewInterestInformer(c.client.baseClient, informerResyncPeriod*time.Second, cache.Indexers{})
		registrationId, err = informer.AddEventHandler(cache.ResourceEventHandlerFuncs{
			DeleteFunc: func(obj interface{}) {
				nc := &InterestInterest{
					client:   c.client,
					Interest: obj.(*baseinterestexamplecomv1.Interest),
				}

				var parent *TenantTenant
				for i := 0; i < 600; i++ {
					// Check if parent exists
					p, err := nc.GetParent(context.TODO())
					if err != nil || p == nil {
						time.Sleep(500 * time.Millisecond)
						continue
					}
					parent = p
					break
				}

				if parent == nil {
					hashedName := helper.GetHashedName("tenants.tenant.example.com", nc.Labels, nc.Labels["tenants.tenant.example.com"])
					parent, err = c.client.Tenant().ForceReadTenantByName(context.TODO(), hashedName)
					if err != nil {
						if errors.IsNotFound(err) {
							return
						}

						panic("error occurred while fetching parent " + err.Error())
					}
					panic(fmt.Sprintf("parent found (event loop is stalled) " + nc.DisplayName()))
				}

				cbfn(nc)
			},
		})
		go informer.Run(stopper)
	}
	return registrationId, err
}
